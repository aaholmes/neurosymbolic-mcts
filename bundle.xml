<repository_context>
<metadata>
  <total_tokens>50020</total_tokens>
  <max_tokens>90000</max_tokens>
  <files_included>57</files_included>
  <files_omitted>84</files_omitted>
  <generated_at>2026-01-05T14:48:04.706114090+00:00</generated_at>
</metadata>

  <build_status>
    <language>rust</language>
    <build>
      <success>true</success>
      <warnings>38</warnings>
      <errors>0</errors>
    </build>
    <tests>
      <passed>6</passed>
      <failed>1</failed>
      <skipped>0</skipped>
    </tests>
  </build_status>
  <package_dependencies package_manager="cargo">
    <production>
      <package name="chrono" required="0.4" installed="0.4.42"/>
      <package name="crossbeam-channel" required="0.5" installed="0.5.15"/>
      <package name="lazy_static" required="1.5.0" installed="1.5.0"/>
      <package name="rand" required="0.8.5" installed="0.9.2"/>
      <package name="rayon" required="1.7" installed="1.11.0"/>
      <package name="serde" required="1.0" installed="1.0.228"/>
      <package name="serde_json" required="1.0" installed="1.0.145"/>
      <package name="shakmaty" required="0.25" installed="0.25.0"/>
      <package name="shakmaty-syzygy" required="0.15.0" installed="0.15.0"/>
      <package name="tch" required="*" installed="0.22.0"/>
    </production>
    <development>
      <package name="criterion" required="0.5" installed="0.5.1"/>
      <package name="proptest" required="1.4" installed="1.9.0"/>
      <package name="tempfile" required="3.0" installed="3.8.0"/>
    </development>
  </package_dependencies>
<directory_structure>
  <directory>.cargo</directory>
  <directory>.github/workflows</directory>
  <directory>python</directory>
  <directory>results</directory>
  <directory>results/figures</directory>
  <directory>scripts</directory>
  <directory>src</directory>
  <directory>src/benchmarks</directory>
  <directory>src/bin</directory>
  <directory>src/experiments</directory>
  <directory>src/mcts</directory>
  <directory>src/mcts/unit_tests</directory>
  <directory>src/search</directory>
  <directory>src/training</directory>
  <directory>src/tuning</directory>
  <directory>tests</directory>
  <directory>tests/common</directory>
  <directory>tests/integration</directory>
  <directory>tests/property</directory>
  <directory>tests/regression</directory>
  <directory>tests/unit</directory>
</directory_structure>

<dependencies>
  <most_imported>
    <module path="tests/regression/mod.rs" score="0.0" />
    <module path="src/training/mod.rs" score="0.0" />
    <module path="tests/mate_portfolio_tests.rs" score="0.0" />
    <module path="results/figures/summary.md" score="0.0" />
    <module path="RESEARCH.md" score="0.0" />
    <module path="scripts/generate_figures.py" score="0.0" />
    <module path="src/mcts/nn_counter.rs" score="0.0" />
    <module path="python/test_architectures.py" score="0.0" />
    <module path="README.md" score="0.0" />
    <module path=".cargo/config.toml" score="0.0" />
  </most_imported>
  <import_relationships>
    <file path="src/neural_net.rs">
      <imports>use crate::board::Board;</imports>
      <imports>use crate::move_types::Move;</imports>
      <imports>use crate::piece_types::{PAWN, KNIGHT, BISHOP, ROOK, QUEEN, KING, WHITE, BLACK};</imports>
      <imports>use crate::tensor::move_to_index;</imports>
      <imports>use tch::{CModule, Tensor, Device, Kind};</imports>
      <imports>use std::path::Path;</imports>
      <imports>use crate::board::Board;</imports>
      <imports>use crate::move_types::Move;</imports>
      <imports>pub use self::real::NeuralNetPolicy;</imports>
      <imports>pub use self::stub::NeuralNetPolicy;</imports>
    </file>
    <file path="src/tuning/data_loader.rs">
      <imports>use super::*;</imports>
      <imports>use std::fs::File;</imports>
      <imports>use std::io::{BufRead, BufReader, Write};</imports>
      <imports>use std::path::Path;</imports>
      <imports>use super::*;</imports>
      <imports>use std::io::Write;</imports>
      <imports>use tempfile::NamedTempFile;</imports>
    </file>
    <file path="src/tuning/mod.rs">
      <imports>use crate::board::Board;</imports>
      <imports>use super::*;</imports>
    </file>
    <file path="src/tuning/texel.rs">
      <imports>use super::*;</imports>
      <imports>use crate::eval::{PestoEval, EvalWeights};</imports>
      <imports>use crate::move_generation::MoveGen;</imports>
      <imports>use std::f64;</imports>
      <imports>use super::*;</imports>
      <imports>use crate::move_generation::MoveGen;</imports>
    </file>
    <file path="src/benchmarks/strength_testing.rs">
      <imports>use crate::board::Board;</imports>
      <imports>use crate::eval::PestoEval;</imports>
      <imports>use crate::move_generation::MoveGen;</imports>
      <imports>use crate::move_types::Move;</imports>
      <imports>use crate::mcts::neural_mcts::neural_mcts_search;</imports>
      <imports>use crate::neural_net::NeuralNetPolicy;</imports>
      <imports>use std::collections::HashMap;</imports>
      <imports>use std::time::{Duration, Instant};</imports>
      <imports>use std::fmt;</imports>
    </file>
    <file path="src/benchmarks/elo_tournament.rs">
      <imports>use crate::board::Board;</imports>
      <imports>use crate::eval::PestoEval;</imports>
      <imports>use crate::move_generation::MoveGen;</imports>
      <imports>use crate::move_types::Move;</imports>
      <imports>use crate::mcts::tactical_mcts::{tactical_mcts_search, TacticalMctsConfig};</imports>
      <imports>use crate::search::iterative_deepening::iterative_deepening_ab_search;</imports>
      <imports>use crate::transposition::TranspositionTable;</imports>
      <imports>use crate::mcts::inference_server::InferenceServer;</imports>
      <imports>use crate::boardstack::BoardStack;</imports>
      <imports>use std::sync::Arc;</imports>
      <imports>use std::time::Duration;</imports>
      <imports>use std::collections::HashMap;</imports>
      <imports>use rand::prelude::*;</imports>
      <imports>use rand::rngs::StdRng;</imports>
    </file>
    <file path="src/benchmarks/mod.rs">
      <imports>use crate::boardstack::BoardStack;</imports>
      <imports>use crate::move_types::Move;</imports>
      <imports>use crate::move_generation::MoveGen;</imports>
      <imports>use crate::eval::PestoEval;</imports>
      <imports>use crate::agent::{Agent, SimpleAgent, HumanlikeAgent};</imports>
      <imports>use std::time::{Duration, Instant};</imports>
    </file>
    <file path="src/benchmarks/performance.rs">
      <imports>use super::*;</imports>
      <imports>use crate::benchmarks::tactical_suite::{run_tactical_benchmark, get_tactical_test_suite};</imports>
      <imports>use std::time::Duration;</imports>
      <imports>use super::*;</imports>
    </file>
    <file path="src/benchmarks/elo_estimation.rs">
      <imports>use std::collections::HashMap;</imports>
      <imports>use crate::benchmarks::strength_testing::{EngineVariant, PositionResult};</imports>
    </file>
    <file path="src/benchmarks/tactical_suite.rs">
      <imports>use super::*;</imports>
      <imports>use crate::move_types::Move;</imports>
      <imports>use super::*;</imports>
      <imports>use crate::board::Board;</imports>
    </file>
    <file path="src/board_utils.rs">
      <imports>use crate::piece_types::{BLACK, WHITE};</imports>
      <imports>use lazy_static::lazy_static;</imports>
    </file>
    <file path="src/bin/tactical_cache_demo.rs">
      <imports>use kingfisher::board::Board;</imports>
      <imports>use kingfisher::move_generation::MoveGen;</imports>
      <imports>use kingfisher::mcts::tactical::{identify_tactical_moves, get_tactical_cache_stats, clear_tactical_cache};</imports>
      <imports>use std::time::Instant;</imports>
    </file>
    <file path="src/bin/tactical_profiler.rs">
      <imports>use kingfisher::board::Board;</imports>
      <imports>use kingfisher::eval::PestoEval;</imports>
      <imports>use kingfisher::move_generation::MoveGen;</imports>
      <imports>use kingfisher::mcts::{tactical_mcts_search, TacticalMctsConfig};</imports>
      <imports>use std::time::{Duration, Instant};</imports>
    </file>
    <file path="src/bin/run_experiments.rs">
      <imports>use kingfisher::board::Board;</imports>
      <imports>use kingfisher::eval::PestoEval;</imports>
      <imports>use kingfisher::experiments::config::{
    ExperimentConfig,
    generate_ablation_configs,
    TestSuite,
};</imports>
      <imports>use kingfisher::experiments::metrics::{
    AggregatedMetrics,
    ExperimentResults,
    PositionResult,
    SafetyMetrics,
    SearchMetrics,
    TierUsed,
};</imports>
      <imports>use kingfisher::mcts::tactical_mcts::{tactical_mcts_search, TacticalMctsConfig};</imports>
      <imports>use kingfisher::move_generation::MoveGen;</imports>
      <imports>use std::fs;</imports>
      <imports>use std::io::Write;</imports>
      <imports>use std::time::{Duration, Instant};</imports>
    </file>
    <file path="src/bin/neural_integration_demo.rs">
      <imports>use kingfisher::board::Board;</imports>
      <imports>use kingfisher::eval::PestoEval;</imports>
      <imports>use kingfisher::move_generation::MoveGen;</imports>
      <imports>use kingfisher::mcts::{tactical_mcts_search, TacticalMctsConfig};</imports>
      <imports>use kingfisher::mcts::inference_server::InferenceServer;</imports>
      <imports>use kingfisher::neural_net::NeuralNetPolicy;</imports>
      <imports>use std::sync::Arc;</imports>
      <imports>use std::time::{Duration, Instant};</imports>
    </file>
    <file path="src/bin/generate_training_data.rs">
      <imports>use kingfisher::training::{TrainingDataGenerator, ParsedGame};</imports>
      <imports>use kingfisher::move_types::Move;</imports>
    </file>
    <file path="src/bin/benchmark.rs">
      <imports>use kingfisher::benchmarks::performance::{run_performance_comparison, mate_speed_benchmark};</imports>
      <imports>use kingfisher::benchmarks::tactical_suite::run_tactical_benchmark;</imports>
      <imports>use kingfisher::benchmarks::{create_simple_agent, create_humanlike_agent};</imports>
      <imports>use std::env;</imports>
      <imports>use std::time::Duration;</imports>
      <imports>use super::*;</imports>
      <imports>use kingfisher::benchmarks::tactical_suite::get_tactical_test_suite;</imports>
    </file>
    <file path="src/bin/mcts_inspector.rs">
      <imports>use std::env;</imports>
      <imports>use std::fs::File;</imports>
      <imports>use std::io::Write;</imports>
      <imports>use std::time::Duration;</imports>
      <imports>use std::sync::Arc;</imports>
      <imports>use kingfisher::board::Board;</imports>
      <imports>use kingfisher::eval::PestoEval;</imports>
      <imports>use kingfisher::mcts::tactical_mcts::{tactical_mcts_search, TacticalMctsConfig};</imports>
      <imports>use kingfisher::mcts::inference_server::InferenceServer;</imports>
      <imports>use kingfisher::move_generation::MoveGen;</imports>
    </file>
    <file path="src/bin/quick_test.rs">
      <imports>use kingfisher::benchmarks::tactical_suite::get_tactical_test_suite;</imports>
      <imports>use kingfisher::benchmarks::create_simple_agent;</imports>
      <imports>use kingfisher::boardstack::BoardStack;</imports>
      <imports>use kingfisher::agent::Agent;</imports>
      <imports>use std::time::Instant;</imports>
    </file>
    <file path="src/bin/verbose_search.rs">
      <imports>use std::env;</imports>
      <imports>use std::sync::Arc;</imports>
      <imports>use std::time::Duration;</imports>
      <imports>use kingfisher::board::Board;</imports>
      <imports>use kingfisher::eval::PestoEval;</imports>
      <imports>use kingfisher::mcts::tactical_mcts::{tactical_mcts_search, TacticalMctsConfig};</imports>
      <imports>use kingfisher::mcts::inference_server::InferenceServer;</imports>
      <imports>use kingfisher::mcts::search_logger::{SearchLogger, Verbosity};</imports>
      <imports>use kingfisher::move_generation::MoveGen;</imports>
    </file>
    <file path="src/bin/verify_features.rs">
      <imports>use kingfisher::board::Board;</imports>
      <imports>use kingfisher::neural_net::NeuralNetPolicy;</imports>
      <imports>use kingfisher::piece_types::{PAWN, KNIGHT, BISHOP, ROOK, QUEEN, KING};</imports>
    </file>
    <file path="src/bin/texel_tune.rs">
      <imports>use kingfisher::tuning::texel::{TexelTuner, create_test_dataset};</imports>
      <imports>use kingfisher::tuning::data_loader::DataLoader;</imports>
      <imports>use kingfisher::eval_constants::EvalWeights;</imports>
      <imports>use kingfisher::move_generation::MoveGen;</imports>
    </file>
    <file path="src/bin/elo_tournament.rs">
      <imports>use kingfisher::benchmarks::elo_tournament::{
    EloTournament,
    TournamentConfig,
    TournamentEngine,
};</imports>
      <imports>use std::env;</imports>
      <imports>use std::fs::File;</imports>
      <imports>use std::io::Write;</imports>
    </file>
    <file path="src/bin/see_integration_demo.rs">
      <imports>use kingfisher::board::Board;</imports>
      <imports>use kingfisher::move_generation::MoveGen;</imports>
      <imports>use kingfisher::mcts::tactical::identify_tactical_moves;</imports>
      <imports>use kingfisher::search::see;</imports>
      <imports>use kingfisher::move_types::Move;</imports>
    </file>
    <file path="src/bin/self_play.rs">
      <imports>use kingfisher::board::Board;</imports>
      <imports>use kingfisher::eval::PestoEval;</imports>
      <imports>use kingfisher::move_generation::MoveGen;</imports>
      <imports>use kingfisher::mcts::{tactical_mcts_search_for_training, TacticalMctsConfig};</imports>
      <imports>use kingfisher::neural_net::NeuralNetPolicy;</imports>
      <imports>use kingfisher::piece_types::{PAWN, KNIGHT, BISHOP, ROOK, QUEEN, KING, WHITE, BLACK};</imports>
      <imports>use kingfisher::tensor::move_to_index;</imports>
      <imports>use std::fs::File;</imports>
      <imports>use std::io::Write;</imports>
      <imports>use std::sync::Mutex;</imports>
      <imports>use std::time::{Duration, SystemTime, UNIX_EPOCH};</imports>
      <imports>use rayon::prelude::*;</imports>
    </file>
    <file path="src/bin/mate_search_tt_demo.rs">
      <imports>use kingfisher::board::Board;</imports>
      <imports>use kingfisher::eval::PestoEval;</imports>
      <imports>use kingfisher::move_generation::MoveGen;</imports>
      <imports>use kingfisher::mcts::{tactical_mcts_search_with_tt, TacticalMctsConfig};</imports>
      <imports>use kingfisher::transposition::TranspositionTable;</imports>
      <imports>use std::time::{Duration, Instant};</imports>
    </file>
    <file path="src/bin/strength_test.rs">
      <imports>use kingfisher::benchmarks::strength_testing::{StrengthTester, StrengthTestConfig};</imports>
      <imports>use std::env;</imports>
    </file>
    <file path="src/bin/verify_tactical_graft.rs">
      <imports>use kingfisher::board::Board;</imports>
      <imports>use kingfisher::move_generation::MoveGen;</imports>
      <imports>use kingfisher::eval::PestoEval;</imports>
      <imports>use kingfisher::mcts::TacticalMctsConfig;</imports>
      <imports>use kingfisher::mcts::tactical_mcts::tactical_mcts_search;</imports>
      <imports>use std::time::Duration;</imports>
    </file>
    <file path="src/bin/benchmark_gates.rs">
      <imports>use kingfisher::board::Board;</imports>
      <imports>use kingfisher::move_generation::MoveGen;</imports>
      <imports>use kingfisher::eval::PestoEval;</imports>
      <imports>use kingfisher::search::koth_center_in_3;</imports>
      <imports>use kingfisher::mcts::tactical_mcts::{tactical_mcts_search, TacticalMctsConfig};</imports>
      <imports>use kingfisher::search::mate_search;</imports>
      <imports>use kingfisher::boardstack::BoardStack;</imports>
      <imports>use std::time::Instant;</imports>
    </file>
    <file path="src/bin/tactical_benchmark.rs">
      <imports>use kingfisher::benchmarks::tactical_suite::{get_tactical_test_suite, TacticalPosition};</imports>
      <imports>use kingfisher::board::Board;</imports>
      <imports>use kingfisher::eval::PestoEval;</imports>
      <imports>use kingfisher::move_generation::MoveGen;</imports>
      <imports>use kingfisher::mcts::{tactical_mcts_search, TacticalMctsConfig, mcts_pesto_search};</imports>
      <imports>use std::time::{Duration, Instant};</imports>
    </file>
    <file path="src/tensor.rs">
      <imports>use crate::move_types::Move;</imports>
      <imports>use crate::piece_types::{KNIGHT, BISHOP, ROOK, QUEEN};</imports>
      <imports>use super::*;</imports>
      <imports>use crate::piece_types::{QUEEN, ROOK, KNIGHT};</imports>
    </file>
    <file path="src/egtb.rs">
      <imports>use crate::board::Board;</imports>
      <imports>use crate::move_types::Move;</imports>
      <imports>use shakmaty::Board as ShakmatyBoard;</imports>
      <imports>use shakmaty_syzygy::{Wdl, Dtz};</imports>
      <imports>use super::*;</imports>
      <imports>use crate::board::Board;</imports>
      <imports>use shakmaty::Chess;</imports>
    </file>
    <file path="src/make_move.rs">
      <imports>use crate::board::Board;</imports>
      <imports>use crate::board_utils::sq_ind_to_bit;</imports>
      <imports>use crate::move_types::Move;</imports>
      <imports>use crate::piece_types::{BLACK, KING, PAWN, ROOK, WHITE};</imports>
    </file>
    <file path="src/training/mod.rs">
      <imports>use crate::board::Board;</imports>
      <imports>use crate::eval::PestoEval;</imports>
      <imports>use crate::move_generation::MoveGen;</imports>
      <imports>use crate::move_types::Move;</imports>
      <imports>use std::collections::HashMap;</imports>
      <imports>use std::fs::File;</imports>
      <imports>use std::io::{Write, BufRead, BufReader};</imports>
      <imports>use std::path::Path;</imports>
      <imports>use super::*;</imports>
    </file>
    <file path="src/hash.rs">
      <imports>use crate::bits::bits;</imports>
      <imports>use crate::board::Board;</imports>
      <imports>use crate::boardstack::BoardStack;</imports>
      <imports>use crate::piece_types::{BISHOP, BLACK, KING, KNIGHT, PAWN, QUEEN, ROOK, WHITE};</imports>
      <imports>use lazy_static::lazy_static;</imports>
      <imports>use rand::Rng;</imports>
    </file>
    <file path="src/mcts/search_logger.rs">
      <imports>use crate::board::Board;</imports>
      <imports>use crate::move_types::Move;</imports>
      <imports>use crate::mcts::node::{MctsNode, NodeOrigin};</imports>
      <imports>use crate::mcts::tactical::TacticalMove;</imports>
      <imports>use std::cell::RefCell;</imports>
      <imports>use std::fmt::Write as FmtWrite;</imports>
      <imports>use std::fs::File;</imports>
      <imports>use std::io::{self, Write};</imports>
      <imports>use std::rc::Rc;</imports>
      <imports>use std::sync::atomic::{AtomicBool, AtomicUsize, AtomicU32, Ordering};</imports>
      <imports>use std::sync::Mutex;</imports>
      <imports>use std::time::Instant;</imports>
    </file>
    <file path="src/mcts/nn_counter.rs">
      <imports>use crate::neural_net::NeuralNetPolicy;</imports>
      <imports>use crate::board::Board;</imports>
      <imports>use std::cell::RefCell;</imports>
      <imports>use std::rc::Rc;</imports>
      <imports>use super::*;</imports>
      <imports>use crate::board::Board;</imports>
    </file>
    <file path="src/mcts/neural_mcts.rs">
      <imports>use crate::board::Board;</imports>
      <imports>use crate::eval::PestoEval;</imports>
      <imports>use crate::move_generation::MoveGen;</imports>
      <imports>use crate::move_types::Move;</imports>
      <imports>use crate::neural_net::NeuralNetPolicy;</imports>
      <imports>use crate::mcts::tactical_mcts::{tactical_mcts_search, TacticalMctsConfig};</imports>
      <imports>use std::time::Duration;</imports>
    </file>
    <file path="src/mcts/policy.rs">
      <imports>use crate::board::Board;</imports>
      <imports>use crate::move_types::Move;</imports>
      <imports>use std::collections::HashMap;</imports>
    </file>
    <file path="src/mcts/tactical.rs">
      <imports>use crate::board::Board;</imports>
      <imports>use crate::move_generation::MoveGen;</imports>
      <imports>use crate::move_types::Move;</imports>
      <imports>use crate::piece_types::{PAWN, KNIGHT, BISHOP, ROOK, QUEEN, KING};</imports>
      <imports>use crate::search::see;</imports>
      <imports>use std::collections::{HashMap, HashSet};</imports>
      <imports>use std::cell::RefCell;</imports>
      <imports>use super::*;</imports>
      <imports>use crate::board::Board;</imports>
    </file>
    <file path="src/mcts/tactical_mcts.rs">
      <imports>use crate::board::Board;</imports>
      <imports>use crate::boardstack::BoardStack;</imports>
      <imports>use crate::eval::{PestoEval, extrapolate_value};</imports>
      <imports>use crate::mcts::node::{MctsNode, NodeOrigin};</imports>
      <imports>use crate::mcts::selection::select_child_with_tactical_priority;</imports>
      <imports>use crate::mcts::inference_server::InferenceServer;</imports>
      <imports>use crate::mcts::search_logger::{SearchLogger, GateReason};</imports>
      <imports>use crate::move_generation::MoveGen;</imports>
      <imports>use crate::move_types::Move;</imports>
      <imports>use crate::neural_net::NeuralNetPolicy;</imports>
      <imports>use crate::search::mate_search;</imports>
      <imports>use crate::search::koth_center_in_3;</imports>
      <imports>use crate::search::quiescence_search_tactical;</imports>
      <imports>use crate::transposition::TranspositionTable;</imports>
      <imports>use std::cell::RefCell;</imports>
      <imports>use std::rc::Rc;</imports>
      <imports>use std::sync::Arc;</imports>
      <imports>use std::time::{Duration, Instant};</imports>
    </file>
    <file path="src/mcts/mod.rs">
      <imports>use crate::board::Board;</imports>
      <imports>use crate::eval::PestoEval;</imports>
      <imports>use crate::move_generation::MoveGen;</imports>
      <imports>use crate::move_types::Move;</imports>
      <imports>use std::time::Duration;</imports>
      <imports>pub use self::node::{MctsNode, MoveCategory, NodeOrigin, select_leaf_for_expansion};</imports>
      <imports>pub use self::tactical_mcts::{
    tactical_mcts_search, tactical_mcts_search_for_training, tactical_mcts_search_with_tt,
    TacticalMctsConfig, TacticalMctsStats,
};</imports>
      <imports>pub use self::neural_mcts::neural_mcts_search;</imports>
      <imports>pub use self::inference_server::InferenceServer;</imports>
      <imports>pub use self::search_logger::{SearchLogger, Verbosity, GateReason, SelectionReason};</imports>
    </file>
    <file path="src/mcts/inference_server.rs">
      <imports>use crate::board::Board;</imports>
      <imports>use crate::neural_net::NeuralNetPolicy;</imports>
      <imports>use crossbeam_channel::{unbounded, Receiver, Sender};</imports>
      <imports>use std::thread;</imports>
      <imports>use std::time::Duration;</imports>
      <imports>use rand::Rng;</imports>
    </file>
    <file path="src/mcts/node.rs">
      <imports>use crate::board::Board;</imports>
      <imports>use crate::move_generation::MoveGen;</imports>
      <imports>use crate::move_types::Move;</imports>
      <imports>use crate::mcts::tactical::TacticalMove;</imports>
      <imports>use std::cell::RefCell;</imports>
      <imports>use std::collections::{HashMap, HashSet};</imports>
      <imports>use std::f64;</imports>
      <imports>use std::rc::{Rc, Weak};</imports>
    </file>
    <file path="src/mcts/selection.rs">
      <imports>use crate::move_generation::MoveGen;</imports>
      <imports>use crate::move_types::Move;</imports>
      <imports>use crate::mcts::node::MctsNode;</imports>
      <imports>use crate::mcts::tactical::identify_tactical_moves;</imports>
      <imports>use crate::mcts::tactical_mcts::{TacticalMctsStats, TacticalMctsConfig};</imports>
      <imports>use crate::mcts::search_logger::{SearchLogger, SelectionReason};</imports>
      <imports>use crate::neural_net::NeuralNetPolicy;</imports>
      <imports>use std::cell::RefCell;</imports>
      <imports>use std::rc::Rc;</imports>
      <imports>use std::sync::Arc;</imports>
      <imports>use super::*;</imports>
      <imports>use crate::board::Board;</imports>
    </file>
    <file path="src/mcts/simulation.rs">
      <imports>use crate::board::Board;</imports>
      <imports>use crate::move_generation::MoveGen;</imports>
      <imports>use rand::seq::SliceRandom;</imports>
    </file>
    <file path="src/mcts/unit_tests/tactical_tests.rs">
      <imports>use crate::board::Board;</imports>
      <imports>use crate::move_generation::MoveGen;</imports>
      <imports>use crate::move_types::Move;</imports>
      <imports>use crate::mcts::tactical::{identify_tactical_moves, TacticalMove, calculate_mvv_lva};</imports>
      <imports>use super::*;</imports>
    </file>
    <file path="src/mcts/unit_tests/mcts_integration_tests.rs">
      <imports>use crate::board::Board;</imports>
      <imports>use crate::eval::PestoEval;</imports>
      <imports>use crate::move_generation::MoveGen;</imports>
      <imports>use crate::move_types::Move;</imports>
      <imports>use crate::mcts::{tactical_mcts_search, TacticalMctsConfig};</imports>
      <imports>use std::time::Duration;</imports>
      <imports>use super::*;</imports>
    </file>
    <file path="src/mcts/unit_tests/selection_tests.rs">
      <imports>use crate::board::Board;</imports>
      <imports>use crate::move_generation::MoveGen;</imports>
      <imports>use crate::move_types::Move;</imports>
      <imports>use crate::mcts::node::MctsNode;</imports>
      <imports>use crate::mcts::selection::{select_child_with_tactical_priority, get_tactical_statistics};</imports>
      <imports>use crate::mcts::tactical_mcts::{TacticalMctsStats, TacticalMctsConfig};</imports>
      <imports>use std::cell::RefCell;</imports>
      <imports>use std::rc::Rc;</imports>
      <imports>use std::time::Duration;</imports>
      <imports>use super::*;</imports>
    </file>
    <file path="src/move_types.rs">
      <imports>use crate::board_utils::sq_ind_to_algebraic;</imports>
      <imports>use crate::piece_types::{BISHOP, KNIGHT, QUEEN, ROOK};</imports>
      <imports>use std::fmt;</imports>
      <imports>use std::hash::{Hash, Hasher};</imports>
      <imports>use super::*;</imports>
    </file>
    <file path="src/arena.rs">
      <imports>use crate::agent;</imports>
      <imports>use crate::boardstack::BoardStack;</imports>
    </file>
    <file path="src/boardstack.rs">
      <imports>use crate::board::Board;</imports>
      <imports>use crate::move_types::Move;</imports>
      <imports>use std::collections::{HashMap, VecDeque};</imports>
    </file>
    <file path="src/transposition.rs">
      <imports>use crate::board::Board;</imports>
      <imports>use crate::move_types::Move;</imports>
      <imports>use std::collections::HashMap;</imports>
    </file>
    <file path="src/board.rs">
      <imports>use crate::board_utils::{algebraic_to_sq_ind, bit_to_sq_ind, coords_to_sq_ind, sq_ind_to_bit};</imports>
      <imports>use crate::move_generation::MoveGen;</imports>
      <imports>use crate::move_types::CastlingRights;</imports>
      <imports>use crate::piece_types::{BISHOP, BLACK, KING, KNIGHT, PAWN, QUEEN, ROOK, WHITE};</imports>
      <imports>use crate::bits::popcnt;</imports>
    </file>
    <file path="src/move_generation.rs">
      <imports>use crate::bits::bits;</imports>
      <imports>use crate::board::Board;</imports>
      <imports>use crate::board_utils::sq_ind_to_bit;</imports>
      <imports>use crate::magic_bitboard::{
    append_promotions, init_bishop_moves, init_king_moves, init_knight_moves,
    init_pawn_captures_promotions, init_pawn_moves, init_rook_moves,
};</imports>
      <imports>use crate::magic_constants::{B_BITS, B_MAGICS, B_MASKS, R_BITS, R_MAGICS, R_MASKS};</imports>
      <imports>use crate::move_types::Move;</imports>
      <imports>use crate::eval::PestoEval;</imports>
      <imports>use crate::piece_types::{BISHOP, BLACK, KING, KNIGHT, PAWN, QUEEN, ROOK, WHITE};</imports>
      <imports>use crate::search::HistoryTable;</imports>
    </file>
    <file path="src/experiments/metrics.rs">
      <imports>use serde::{Deserialize, Serialize};</imports>
      <imports>use std::time::Duration;</imports>
    </file>
    <file path="src/experiments/position_classifier.rs">
      <imports>use crate::board::Board;</imports>
      <imports>use crate::move_generation::MoveGen;</imports>
      <imports>use crate::eval::PestoEval;</imports>
    </file>
    <file path="src/experiments/config.rs">
      <imports>use serde::{Deserialize, Serialize};</imports>
    </file>
    <file path="src/uci.rs">
      <imports>use crate::agent::{Agent, HumanlikeAgent, SimpleAgent};</imports>
      <imports>use crate::boardstack::BoardStack;</imports>
      <imports>use crate::egtb::EgtbProber;</imports>
      <imports>use crate::eval::PestoEval;</imports>
      <imports>use crate::move_generation::MoveGen;</imports>
      <imports>use lazy_static::lazy_static;</imports>
      <imports>use crate::move_types::Move;</imports>
      <imports>use std::io::{self, BufRead, Write};</imports>
      <imports>use std::time::{Duration, Instant};</imports>
      <imports>use super::*;</imports>
      <imports>use crate::board::Board;</imports>
    </file>
    <file path="src/eval.rs">
      <imports>use crate::bits::{bits, popcnt};</imports>
      <imports>use crate::board::Board;</imports>
      <imports>use crate::board_utils::flip_sq_ind_vertically;</imports>
      <imports>use crate::board_utils::{
    get_adjacent_files_mask, get_file_mask, get_front_span_mask, get_king_attack_zone_mask,
    get_king_shield_zone_mask, get_passed_pawn_mask, get_rank_mask, sq_ind_to_bit, sq_to_file,
    sq_to_rank,
};</imports>
      <imports>pub use crate::eval_constants::EvalWeights;</imports>
      <imports>use crate::eval_constants::{
    EG_PESTO_TABLE, EG_VALUE, GAMEPHASE_INC, MG_PESTO_TABLE, MG_VALUE,
};</imports>
      <imports>use crate::move_generation::MoveGen;</imports>
      <imports>use crate::piece_types::{BISHOP, BLACK, KING, KNIGHT, PAWN, QUEEN, ROOK, WHITE};</imports>
      <imports>use std::cmp::min;</imports>
    </file>
    <file path="src/search/mate_search.rs">
      <imports>use crate::boardstack::BoardStack;</imports>
      <imports>use crate::move_generation::MoveGen;</imports>
      <imports>use crate::move_types::Move;</imports>
      <imports>use std::sync::atomic::{AtomicBool, AtomicUsize, Ordering};</imports>
      <imports>use std::sync::{Arc, Mutex};</imports>
    </file>
    <file path="src/search/see.rs">
      <imports>use crate::board::Board;</imports>
      <imports>use crate::move_generation::MoveGen;</imports>
      <imports>use crate::piece_types::{KING, PAWN};</imports>
      <imports>use std::cmp::max;</imports>
    </file>
    <file path="src/search/quiescence.rs">
      <imports>use super::see::see;</imports>
      <imports>use crate::boardstack::BoardStack;</imports>
      <imports>use crate::eval::PestoEval;</imports>
      <imports>use crate::move_generation::MoveGen;</imports>
      <imports>use crate::move_types::Move;</imports>
      <imports>use std::time::{Duration, Instant};</imports>
    </file>
    <file path="src/search/koth.rs">
      <imports>use crate::board::{Board, KOTH_CENTER};</imports>
      <imports>use crate::move_generation::MoveGen;</imports>
      <imports>use crate::piece_types::{KING, WHITE, BLACK};</imports>
    </file>
    <file path="src/search/iterative_deepening.rs">
      <imports>use super::alpha_beta::alpha_beta_search;</imports>
      <imports>use super::history::HistoryTable;</imports>
      <imports>use super::history::MAX_PLY;</imports>
      <imports>use crate::boardstack::BoardStack;</imports>
      <imports>use crate::eval::PestoEval;</imports>
      <imports>use crate::move_generation::MoveGen;</imports>
      <imports>use crate::move_types::{Move, NULL_MOVE};</imports>
      <imports>use crate::transposition::TranspositionTable;</imports>
      <imports>use crate::utils::print_move;</imports>
      <imports>use std::time::{Duration, Instant};</imports>
    </file>
    <file path="src/search/mod.rs">
      <imports>pub use history::{HistoryTable, MAX_PLY};</imports>
      <imports>pub use mate_search::mate_search;</imports>
      <imports>pub use quiescence::{quiescence_search, quiescence_search_tactical};</imports>
      <imports>pub use iterative_deepening::{iterative_deepening_ab_search, aspiration_window_ab_search};</imports>
      <imports>pub use koth::koth_center_in_3;</imports>
      <imports>pub use see::see;</imports>
    </file>
    <file path="src/search/alpha_beta.rs">
      <imports>use super::history::HistoryTable;</imports>
      <imports>use super::history::MAX_PLY;</imports>
      <imports>use super::quiescence::quiescence_search;</imports>
      <imports>use crate::board::Board;</imports>
      <imports>use crate::boardstack::BoardStack;</imports>
      <imports>use crate::eval::PestoEval;</imports>
      <imports>use crate::move_generation::MoveGen;</imports>
      <imports>use crate::move_types::{Move, NULL_MOVE};</imports>
      <imports>use crate::transposition::TranspositionTable;</imports>
      <imports>use std::time::{Duration, Instant};</imports>
    </file>
    <file path="src/search/history.rs">
      <imports>use crate::move_types::Move;</imports>
    </file>
    <file path="src/utils.rs">
      <imports>use crate::board_utils::{coords_to_sq_ind, sq_ind_to_algebraic, sq_ind_to_bit};</imports>
      <imports>use crate::move_types::Move;</imports>
      <imports>use crate::piece_types::{BISHOP, KNIGHT, QUEEN, ROOK};</imports>
    </file>
    <file path="src/main.rs">
      <imports>use kingfisher::agent::SimpleAgent;</imports>
      <imports>use kingfisher::arena::Match;</imports>
      <imports>use kingfisher::eval::PestoEval;</imports>
      <imports>use kingfisher::move_generation::MoveGen;</imports>
      <imports>use kingfisher::uci::UCIEngine;</imports>
    </file>
    <file path="src/agent.rs">
      <imports>use crate::boardstack::BoardStack;</imports>
      <imports>use crate::eval::PestoEval;</imports>
      <imports>use crate::move_generation::MoveGen;</imports>
      <imports>use crate::move_types::Move;</imports>
      <imports>use crate::mcts::tactical_mcts::{tactical_mcts_search, TacticalMctsConfig};</imports>
      <imports>use crate::mcts::node::MctsNode;</imports>
      <imports>use crate::search::mate_search;</imports>
      <imports>use crate::egtb::EgtbProber;</imports>
      <imports>use std::cell::RefCell;</imports>
      <imports>use std::rc::Rc;</imports>
      <imports>use std::time::Duration;</imports>
    </file>
    <file path="src/magic_bitboard.rs">
      <imports>use crate::bits::bits;</imports>
      <imports>use crate::board_utils::sq_ind_to_bit;</imports>
      <imports>use crate::magic_constants::{B_BITS, B_MASKS, R_BITS, R_MASKS};</imports>
      <imports>use crate::move_types::Move;</imports>
      <imports>use crate::piece_types::{BISHOP, KNIGHT, QUEEN, ROOK};</imports>
    </file>
    <file path="scripts/analyze_results.py">
      <imports>import json</imports>
      <imports>import sys</imports>
      <imports>from pathlib import Path</imports>
      <imports>import matplotlib.pyplot as plt</imports>
      <imports>import numpy as np</imports>
    </file>
    <file path="scripts/generate_figures.py">
      <imports>import pandas as pd</imports>
      <imports>import matplotlib.pyplot as plt</imports>
      <imports>import seaborn as sns</imports>
      <imports>import sys</imports>
      <imports>import os</imports>
    </file>
    <file path="test_tactical_mcts.rs">
      <imports>use kingfisher::board::Board;</imports>
      <imports>use kingfisher::eval::PestoEval;</imports>
      <imports>use kingfisher::move_generation::MoveGen;</imports>
      <imports>use kingfisher::mcts::{tactical_mcts_search, TacticalMctsConfig, print_search_stats};</imports>
      <imports>use kingfisher::neural_net::NeuralNetPolicy;</imports>
      <imports>use std::time::Duration;</imports>
    </file>
    <file path="tests/property/invariant_tests.rs">
      <imports>use kingfisher::board::Board;</imports>
      <imports>use kingfisher::move_generation::MoveGen;</imports>
      <imports>use kingfisher::mcts::node::MctsNode;</imports>
      <imports>use kingfisher::piece_types::{WHITE, BLACK, KING};</imports>
      <imports>use proptest::prelude::*;</imports>
      <imports>use crate::common::positions;</imports>
      <imports>use super::*;</imports>
      <imports>use kingfisher::neural_net::NeuralNetPolicy;</imports>
      <imports>use tch::Tensor;</imports>
    </file>
    <file path="tests/eval_piece_bonus_tests.rs">
      <imports>use kingfisher::board::Board;</imports>
      <imports>use kingfisher::board_utils;</imports>
      <imports>use kingfisher::eval::PestoEval;</imports>
      <imports>use kingfisher::eval_constants::{KING_SAFETY_PAWN_SHIELD_BONUS, TWO_BISHOPS_BONUS};</imports>
      <imports>use kingfisher::piece_types::{BISHOP, BLACK, KNIGHT, PAWN, WHITE};</imports>
      <imports>use kingfisher::move_generation::MoveGen;</imports>
    </file>
    <file path="tests/bitboard_tests.rs">
      <imports>use kingfisher::board::Board;</imports>
      <imports>use kingfisher::boardstack::BoardStack;</imports>
      <imports>use kingfisher::move_generation::MoveGen;</imports>
      <imports>use kingfisher::move_types::Move;</imports>
      <imports>use kingfisher::piece_types::{BLACK, KING, KNIGHT, PAWN, ROOK, WHITE};</imports>
    </file>
    <file path="tests/common/mod.rs">
      <imports>use kingfisher::board::Board;</imports>
      <imports>use kingfisher::move_generation::MoveGen;</imports>
      <imports>use kingfisher::move_types::Move;</imports>
      <imports>use std::collections::HashSet;</imports>
    </file>
    <file path="tests/unit/graphviz_tests.rs">
      <imports>use kingfisher::board::Board;</imports>
      <imports>use kingfisher::eval::PestoEval;</imports>
      <imports>use kingfisher::mcts::node::{MctsNode, NodeOrigin};</imports>
      <imports>use kingfisher::mcts::tactical_mcts::{tactical_mcts_search, TacticalMctsConfig};</imports>
      <imports>use kingfisher::mcts::inference_server::InferenceServer;</imports>
      <imports>use kingfisher::move_generation::MoveGen;</imports>
      <imports>use std::sync::Arc;</imports>
      <imports>use std::time::Duration;</imports>
      <imports>use super::common::positions;</imports>
    </file>
    <file path="tests/unit/node_tests.rs">
      <imports>use kingfisher::mcts::node::MctsNode;</imports>
      <imports>use kingfisher::board::Board;</imports>
      <imports>use kingfisher::move_generation::MoveGen;</imports>
      <imports>use crate::common::{board_from_fen, assert_in_tanh_domain, positions};</imports>
    </file>
    <file path="tests/unit/move_generation_tests.rs">
      <imports>use kingfisher::board::Board;</imports>
      <imports>use kingfisher::move_generation::MoveGen;</imports>
      <imports>use kingfisher::move_types::Move;</imports>
      <imports>use crate::common::{board_from_fen, legal_moves_set, positions, generate_legal_moves};</imports>
    </file>
    <file path="tests/unit/tensor_tests.rs">
      <imports>use kingfisher::neural_net::NeuralNetPolicy;</imports>
      <imports>use kingfisher::board::Board;</imports>
      <imports>use kingfisher::piece_types::{WHITE, BLACK, KING};</imports>
      <imports>use crate::common::{board_from_fen, positions};</imports>
      <imports>use tch::Tensor;</imports>
    </file>
    <file path="tests/unit/search_logger_tests.rs">
      <imports>use kingfisher::mcts::search_logger::{
    SearchLogger, Verbosity, GateReason, SelectionReason, LogSink,
};</imports>
      <imports>use kingfisher::move_types::Move;</imports>
    </file>
    <file path="tests/unit/board_tests.rs">
      <imports>use kingfisher::board::{Board, KOTH_CENTER};</imports>
      <imports>use kingfisher::move_generation::MoveGen;</imports>
      <imports>use kingfisher::piece_types::{WHITE, BLACK, PAWN, KING};</imports>
      <imports>use crate::common::{board_from_fen, positions};</imports>
    </file>
    <file path="tests/unit/selection_tests.rs">
      <imports>use kingfisher::mcts::selection::calculate_ucb_value;</imports>
      <imports>use kingfisher::mcts::node::MctsNode;</imports>
      <imports>use kingfisher::board::Board;</imports>
      <imports>use kingfisher::move_generation::MoveGen;</imports>
      <imports>use crate::common::assert_approx_eq;</imports>
    </file>
    <file path="tests/move_generation_tests.rs">
      <imports>use kingfisher::board::Board;</imports>
      <imports>use kingfisher::boardstack::BoardStack;</imports>
      <imports>use kingfisher::eval::PestoEval;</imports>
      <imports>use kingfisher::move_generation::MoveGen;</imports>
      <imports>use kingfisher::move_types::Move;</imports>
      <imports>use kingfisher::piece_types::QUEEN;</imports>
    </file>
    <file path="tests/neural_integration_tests.rs">
      <imports>use kingfisher::board::Board;</imports>
      <imports>use kingfisher::eval::PestoEval;</imports>
      <imports>use kingfisher::mcts::neural_mcts_search;</imports>
      <imports>use kingfisher::move_generation::MoveGen;</imports>
      <imports>use kingfisher::neural_net::NeuralNetPolicy;</imports>
      <imports>use std::time::Duration;</imports>
    </file>
    <file path="tests/perft_tests.rs">
      <imports>use kingfisher::board::Board;</imports>
      <imports>use kingfisher::move_generation::MoveGen;</imports>
      <imports>use kingfisher::utils::print_move;</imports>
    </file>
    <file path="tests/regression/recent_fixes_tests.rs">
      <imports>use kingfisher::board::Board;</imports>
      <imports>use kingfisher::move_generation::MoveGen;</imports>
      <imports>use kingfisher::mcts::node::MctsNode;</imports>
      <imports>use kingfisher::mcts::inference_server::InferenceServer;</imports>
      <imports>use kingfisher::mcts::tactical_mcts::{tactical_mcts_search, TacticalMctsConfig, TacticalMctsStats};</imports>
      <imports>use kingfisher::mcts::selection::select_child_with_tactical_priority;</imports>
      <imports>use kingfisher::move_types::Move;</imports>
      <imports>use kingfisher::eval::PestoEval;</imports>
      <imports>use kingfisher::neural_net::NeuralNetPolicy;</imports>
      <imports>use crate::common::{board_from_fen, positions};</imports>
      <imports>use std::time::Duration;</imports>
      <imports>use std::rc::Rc;</imports>
      <imports>use std::cell::RefCell;</imports>
      <imports>use std::sync::Arc;</imports>
      <imports>use super::*;</imports>
      <imports>use super::*;</imports>
      <imports>use super::*;</imports>
      <imports>use super::*;</imports>
      <imports>use tch::Tensor;</imports>
    </file>
    <file path="tests/make_move_tests.rs">
      <imports>use kingfisher::board::Board;</imports>
      <imports>use kingfisher::board_utils;</imports>
      <imports>use kingfisher::move_generation::MoveGen;</imports>
      <imports>use kingfisher::move_types::Move;</imports>
      <imports>use kingfisher::piece_types::*;</imports>
    </file>
    <file path="tests/mate_portfolio_tests.rs">
      <imports>use kingfisher::board::Board;</imports>
      <imports>use kingfisher::boardstack::BoardStack;</imports>
      <imports>use kingfisher::move_generation::MoveGen;</imports>
      <imports>use kingfisher::search::mate_search;</imports>
      <imports>use std::time::Instant;</imports>
    </file>
    <file path="tests/repetition_tests.rs">
      <imports>use kingfisher::boardstack::BoardStack;</imports>
      <imports>use kingfisher::move_types::Move;</imports>
    </file>
    <file path="tests/integration/mcts_integration_tests.rs">
      <imports>use kingfisher::mcts::tactical_mcts::{tactical_mcts_search, TacticalMctsConfig};</imports>
      <imports>use kingfisher::mcts::inference_server::InferenceServer;</imports>
      <imports>use kingfisher::board::Board;</imports>
      <imports>use kingfisher::move_generation::MoveGen;</imports>
      <imports>use kingfisher::eval::PestoEval;</imports>
      <imports>use kingfisher::move_types::Move;</imports>
      <imports>use crate::common::{board_from_fen, positions};</imports>
      <imports>use std::time::Duration;</imports>
      <imports>use std::sync::Arc;</imports>
    </file>
    <file path="tests/mcts_tests.rs">
      <imports>use std::cell::RefCell;</imports>
      <imports>use std::collections::HashMap;</imports>
      <imports>use std::hash::{Hash, Hasher};</imports>
      <imports>use std::rc::Rc;</imports>
      <imports>use std::time::{Duration, Instant};</imports>
      <imports>use kingfisher::board::Board;</imports>
      <imports>use kingfisher::eval::PestoEval;</imports>
      <imports>use kingfisher::move_generation::MoveGen;</imports>
      <imports>use kingfisher::mcts::{
        mcts_pesto_search, select_leaf_for_expansion, MctsNode, MoveCategory,
    };</imports>
      <imports>use kingfisher::mcts::simulation::simulate_random_playout;</imports>
      <imports>use kingfisher::move_types::{Move, NULL_MOVE};</imports>
      <imports>use kingfisher::board_utils;</imports>
      <imports>use kingfisher::search::mate_search;</imports>
      <imports>use kingfisher::boardstack::BoardStack;</imports>
    </file>
    <file path="tests/eval_pawn_structure_tests.rs">
      <imports>use kingfisher::board::Board;</imports>
      <imports>use kingfisher::board_utils;</imports>
      <imports>use kingfisher::eval::PestoEval;</imports>
      <imports>use kingfisher::eval_constants::{
        ISOLATED_PAWN_PENALTY, MOBILE_PAWN_DUO_BONUS_EG, MOBILE_PAWN_DUO_BONUS_MG,
        PASSED_PAWN_BONUS_EG, PASSED_PAWN_BONUS_MG, PAWN_CHAIN_BONUS, PAWN_DUO_BONUS,
        KING_SAFETY_PAWN_SHIELD_BONUS,
    };</imports>
      <imports>use kingfisher::piece_types::{BLACK, PAWN, WHITE};</imports>
      <imports>use kingfisher::move_generation::MoveGen;</imports>
    </file>
    <file path="python/export_model.py">
      <imports>import torch</imports>
      <imports>from model_architectures import MinimalViableNet</imports>
      <imports>import os</imports>
    </file>
    <file path="python/train.py">
      <imports>import torch</imports>
      <imports>import torch.nn as nn</imports>
      <imports>import torch.optim as optim</imports>
      <imports>import torch.nn.functional as F</imports>
      <imports>from torch.utils.data import Dataset, DataLoader</imports>
      <imports>import numpy as np</imports>
      <imports>import os</imports>
      <imports>import struct</imports>
      <imports>import glob</imports>
      <imports>import sys</imports>
      <imports>from model import LogosNet</imports>
    </file>
    <file path="python/orchestrate.py">
      <imports>import os</imports>
      <imports>import subprocess</imports>
      <imports>import torch</imports>
      <imports>import shutil</imports>
      <imports>from model import LogosNet</imports>
    </file>
    <file path="python/model.py">
      <imports>import torch</imports>
      <imports>import torch.nn as nn</imports>
      <imports>import torch.nn.functional as F</imports>
      <imports>import math</imports>
    </file>
    <file path="python/training_pipeline.py">
      <imports>import torch</imports>
      <imports>import torch.nn as nn</imports>
      <imports>import torch.nn.functional as F</imports>
      <imports>import torch.optim as optim</imports>
      <imports>from torch.utils.data import Dataset, DataLoader</imports>
      <imports>import numpy as np</imports>
      <imports>import chess</imports>
      <imports>import chess.pgn</imports>
      <imports>import chess.engine</imports>
      <imports>import os</imports>
      <imports>import json</imports>
      <imports>import random</imports>
      <imports>from typing import List, Tuple, Dict, Optional</imports>
      <imports>from pathlib import Path</imports>
      <imports>import argparse</imports>
      <imports>from tqdm import tqdm</imports>
      <imports>import logging</imports>
      <imports>from chess_net import ChessNet, ChessNetInterface</imports>
    </file>
    <file path="python/train_chess_ai.py">
      <imports>import argparse</imports>
      <imports>import os</imports>
      <imports>import sys</imports>
      <imports>import subprocess</imports>
      <imports>from pathlib import Path</imports>
      <imports>import logging</imports>
    </file>
    <file path="python/test_architectures.py">
      <imports>import torch</imports>
      <imports>import torch.optim as optim</imports>
      <imports>import torch.nn.functional as F</imports>
      <imports>from model import LogosNet</imports>
    </file>
    <file path="python/data_collection.py">
      <imports>import requests</imports>
      <imports>import gzip</imports>
      <imports>import os</imports>
      <imports>import chess.pgn</imports>
      <imports>from pathlib import Path</imports>
      <imports>import argparse</imports>
      <imports>import logging</imports>
      <imports>from typing import List, Optional</imports>
      <imports>from tqdm import tqdm</imports>
    </file>
  </import_relationships>
</dependencies>

<ml_architecture>
  <framework>PyTorch</framework>
  <models>
    <model>SEBlock</model>
    <model>ResBlock</model>
    <model>LogosNet</model>
  </models>
</ml_architecture>

<git_history>
  <current_branch>main</current_branch>
  <recent_commits>
    <commit hash="d5bb014">
      <message>Implement Paper-Ready experimental framework for ablation studies and fix search legality invariants</message>
      <author>Adam A Holmes</author>
      <timestamp>2026-01-05T00:52:45+00:00</timestamp>
      <files_changed>
        <file change="Added">.github/workflows/experiments.yml</file>
        <file change="Modified">.gitignore</file>
        <file change="Modified">Cargo.lock</file>
        <file change="Modified">Cargo.toml</file>
        <file change="Added">Dockerfile</file>
      </files_changed>
    </commit>
    <commit hash="1495e74">
      <message>Add documentation for stream of consciousness logger</message>
      <author>Adam Holmes</author>
      <timestamp>2025-12-29T02:27:24+00:00</timestamp>
      <files_changed>
        <file change="Modified">ARCHITECTURE.md</file>
        <file change="Modified">BENCHMARKING.md</file>
        <file change="Modified">README.md</file>
        <file change="Modified">src/uci.rs</file>
      </files_changed>
    </commit>
    <commit hash="13d47fa">
      <message>Implement Stream of Consciousness logger for MCTS search narration</message>
      <author>Adam Holmes</author>
      <timestamp>2025-12-29T02:24:30+00:00</timestamp>
      <files_changed>
        <file change="Modified">Cargo.toml</file>
        <file change="Modified">src/bin/mate_search_tt_demo.rs</file>
        <file change="Modified">src/bin/mcts_inspector.rs</file>
        <file change="Modified">src/bin/neural_integration_demo.rs</file>
        <file change="Modified">src/bin/self_play.rs</file>
      </files_changed>
    </commit>
    <commit hash="fe1dc7c">
      <message>Add documentation for MCTS Inspector and tree visualization</message>
      <author>Adam Holmes</author>
      <timestamp>2025-12-28T21:51:49+00:00</timestamp>
      <files_changed>
        <file change="Modified">README.md</file>
      </files_changed>
    </commit>
    <commit hash="cea317e">
      <message>Implement MCTS inspector and enhanced Graphviz tree visualization</message>
      <author>Adam Holmes</author>
      <timestamp>2025-12-28T21:41:23+00:00</timestamp>
      <files_changed>
        <file change="Modified">Cargo.toml</file>
        <file change="Modified">bundle_repo.py</file>
        <file change="Modified">src/bin/benchmark_gates.rs</file>
        <file change="Added">src/bin/mcts_inspector.rs</file>
        <file change="Modified">src/mcts/mod.rs</file>
      </files_changed>
    </commit>
    <commit hash="cf04658">
      <message>Add testing documentation and update README</message>
      <author>Adam Holmes</author>
      <timestamp>2025-12-28T19:52:08+00:00</timestamp>
      <files_changed>
        <file change="Modified">README.md</file>
        <file change="Added">TESTING.md</file>
      </files_changed>
    </commit>
    <commit hash="2bbd91d">
      <message>Implement comprehensive test suite and fix BoardStack history overflow</message>
      <author>Adam Holmes</author>
      <timestamp>2025-12-28T19:43:38+00:00</timestamp>
      <files_changed>
        <file change="Modified">Cargo.lock</file>
        <file change="Modified">Cargo.toml</file>
        <file change="Added">scripts/test.sh</file>
        <file change="Modified">src/boardstack.rs</file>
        <file change="Modified">src/magic_bitboard.rs</file>
      </files_changed>
    </commit>
    <commit hash="ba6a107">
      <message>Fix perspective bug in MctsNode constructors for terminal values</message>
      <author>Adam Holmes</author>
      <timestamp>2025-12-28T10:39:43+00:00</timestamp>
      <files_changed>
        <file change="Modified">src/mcts/node.rs</file>
        <file change="Modified">tests/mcts_tests.rs</file>
      </files_changed>
    </commit>
    <commit hash="3359b45">
      <message>Use tactical values for Q-initialization instead of policy priors</message>
      <author>Adam Holmes</author>
      <timestamp>2025-12-28T10:34:45+00:00</timestamp>
      <files_changed>
        <file change="Modified">src/mcts/mod.rs</file>
        <file change="Modified">src/mcts/node.rs</file>
        <file change="Modified">src/mcts/selection.rs</file>
        <file change="Modified">src/mcts/tactical_mcts.rs</file>
      </files_changed>
    </commit>
    <commit hash="a83a2f0">
      <message>Sync training data generators with perspective-relative inference convention</message>
      <author>Adam Holmes</author>
      <timestamp>2025-12-28T10:16:47+00:00</timestamp>
      <files_changed>
        <file change="Modified">python/test_architectures.py</file>
        <file change="Modified">python/train.py</file>
        <file change="Modified">python/train_chess_ai.py</file>
        <file change="Modified">python/training_pipeline.py</file>
        <file change="Modified">src/bin/self_play.rs</file>
      </files_changed>
    </commit>
  </recent_commits>
  <uncommitted_changes>
    <file>bundle.xml</file>
    <file>IMPLEMENTATION_GUIDE.md</file>
    <file>MCTS_INSPECTOR_IMPLEMENTATION_GUIDE.md</file>
    <file>PAPER_READY_IMPLEMENTATION_GUIDE.md</file>
    <file>STREAM_OF_CONSCIOUSNESS_IMPLEMENTATION_GUIDE.md</file>
  </uncommitted_changes>
</git_history>

<action_items>
  <total_count>77</total_count>
  <critical>
    <item type="SAFETY" line="40" priority="high">
      <file>./DESIGN_DOC.md</file>
      <context><![CDATA[        * Pawn Structure (passed, isolated, backward pawns, pawn chains and duos)
        * King Safety heuristics
        * Mobility bonus]]></context>
      <message>heuristics</message>
    </item>
    <item type="SAFETY" line="5" priority="high">
      <file>./IMPLEMENTATION_GUIDE.md</file>
      <context><![CDATA[
**Thesis**: Caissawary demonstrates that **structured inductive biases from classical game theory can dramatically improve sample efficiency and safety in reinforcement learning**, reducing reliance on expensive neural network inference while guaranteeing correct behavior in tractable subproblems.
]]></context>
      <message>in reinforcement learning**, reducing reliance on expensive neural network inference while guaranteeing correct behavior in tractable subproblems.</message>
    </item>
    <item type="SAFETY" line="55" priority="high">
      <file>./IMPLEMENTATION_GUIDE.md</file>
      <context><![CDATA[pub struct AblationConfig {
    /// Enable Tier 1: Safety gates (mate search + KOTH)
    pub enable_tier1_gate: bool,]]></context>
      <message>gates (mate search + KOTH)</message>
    </item>
    <item type="SAFETY" line="86" priority="high">
      <file>./IMPLEMENTATION_GUIDE.md</file>
      <context><![CDATA[
    /// Tier 1 only (safety gates)
    pub fn tier1_only() -> Self {]]></context>
      <message>gates)</message>
    </item>
    <item type="SAFETY" line="224" priority="high">
      <file>./IMPLEMENTATION_GUIDE.md</file>
      <context><![CDATA[//! - Sample efficiency (NN calls saved)
//! - Safety (tactical errors avoided)
//! - Playing strength (Elo estimation)]]></context>
      <message>(tactical errors avoided)</message>
    </item>
    <item type="SAFETY" line="384" priority="high">
      <file>./IMPLEMENTATION_GUIDE.md</file>
      <context><![CDATA[
/// Safety metrics - tracking tactical blunders
#[derive(Debug, Clone, Default, Serialize, Deserialize)]]]></context>
      <message>metrics - tracking tactical blunders</message>
    </item>
    <item type="SAFETY" line="640" priority="high">
      <file>./IMPLEMENTATION_GUIDE.md</file>
      <context><![CDATA[        
        // Update safety metrics
        safety.positions_analyzed += 1;]]></context>
      <message>metrics</message>
    </item>
    <item type="SAFETY" line="726" priority="high">
      <file>./IMPLEMENTATION_GUIDE.md</file>
      <context><![CDATA[                
                // Safety test - don't blunder
                ("Don't Hang Queen".to_string(),]]></context>
      <message>test - don't blunder</message>
    </item>
    <item type="SAFETY" line="1024" priority="high">
      <file>./IMPLEMENTATION_GUIDE.md</file>
      <context><![CDATA[    
    p1 = ax.bar(x, tier1, width, label='Tier 1 (Safety Gates)', color='#e74c3c')
    p2 = ax.bar(x, tier2, width, bottom=tier1, label='Tier 2 (Tactical Grafts)', color='#f39c12')]]></context>
      <message>Gates)', color='#e74c3c')</message>
    </item>
    <item type="SAFETY" line="1044" priority="high">
      <file>./IMPLEMENTATION_GUIDE.md</file>
      <context><![CDATA[def plot_safety_metrics(results: list, output_dir: Path):
    """Plot safety metrics - tactical accuracy."""
    configs = [r['config_name'] for r in results]]]></context>
      <message>metrics - tactical accuracy."""</message>
    </item>
    <item type="SAFETY" line="1186" priority="high">
      <file>./IMPLEMENTATION_GUIDE.md</file>
      <context><![CDATA[
**RQ2**: Do safety gates prevent tactical blunders during exploration?
- *Hypothesis*: Tier 1 achieves 100% accuracy on positions with forced mates]]></context>
      <message>gates prevent tactical blunders during exploration?</message>
    </item>
    <item type="SAFETY" line="510" priority="high">
      <file>./PAPER_READY_IMPLEMENTATION_GUIDE.md</file>
      <context><![CDATA[    // Ablation flags for paper experiments
    /// Enable Tier 1 (Safety Gates: Mate Search + KOTH)
    pub enable_tier1_gate: bool,]]></context>
      <message>Gates: Mate Search + KOTH)</message>
    </item>
    <item type="SAFETY" line="50" priority="high">
      <file>./README.md</file>
      <context><![CDATA[
#### 1. Safety Gates (Tier 1):
Before any expansion, the engine runs ultra-fast "Safety Gates" to detect immediate win/loss conditions:]]></context>
      <message>Gates (Tier 1):</message>
    </item>
    <item type="SAFETY" line="23" priority="high">
      <file>./RESEARCH.md</file>
      <context><![CDATA[
**RQ2**: Do safety gates prevent tactical blunders during exploration?
- *Hypothesis*: Tier 1 achieves 100% accuracy on positions with forced mates]]></context>
      <message>gates prevent tactical blunders during exploration?</message>
    </item>
    <item type="SAFETY" line="84" priority="high">
      <file>./scripts/analyze_results.py</file>
      <scope>def plot_tier_breakdown</scope>
      <context><![CDATA[    
    p1 = ax.bar(x, tier1, width, label='Tier 1 (Safety Gates)', color='#e74c3c')
    p2 = ax.bar(x, tier2, width, bottom=tier1, label='Tier 2 (Tactical Grafts)', color='#f39c12')]]></context>
      <message>Gates)', color='#e74c3c')</message>
    </item>
    <item type="SAFETY" line="103" priority="high">
      <file>./scripts/analyze_results.py</file>
      <scope>def plot_safety_metrics</scope>
      <context><![CDATA[def plot_safety_metrics(results: list, output_dir: Path):
    """Plot safety metrics - tactical accuracy."""
    configs = [r['config_name'] for r in results]]]></context>
      <message>metrics - tactical accuracy."""</message>
    </item>
    <item type="SAFETY" line="182" priority="high">
      <file>./src/bin/run_experiments.rs</file>
      <scope>fn run_experiment</scope>
      <context><![CDATA[        
        // Update safety metrics
        safety.positions_analyzed += 1;]]></context>
      <message>metrics</message>
    </item>
    <item type="SAFETY" line="268" priority="high">
      <file>./src/bin/run_experiments.rs</file>
      <scope>fn load_test_suite</scope>
      <context><![CDATA[                
                // Safety test - don't blunder
                ("Don't Hang Queen".to_string(),]]></context>
      <message>test - don't blunder</message>
    </item>
    <item type="SAFETY" line="380" priority="high">
      <file>./src/board_utils.rs</file>
      <scope>fn get_front_span_mask</scope>
      <context><![CDATA[/// Get a bitboard containing the king's attack zone (squares around the king).
/// Used for king safety evaluations and detecting attacks against the king.
pub fn get_king_attack_zone_mask(_color: usize, king_sq: usize) -> u64 {]]></context>
      <message>evaluations and detecting attacks against the king.</message>
    </item>
    <item type="SAFETY" line="209" priority="high">
      <file>./src/eval_constants.rs</file>
      <context><![CDATA[
// King Safety Bonus per Pawn in Shield Zone (MG/EG)
// Zone typically includes squares directly and diagonally one step in front of the king.]]></context>
      <message>Bonus per Pawn in Shield Zone (MG/EG)</message>
    </item>
    <item type="SAFETY" line="284" priority="high">
      <file>./src/eval_constants.rs</file>
      <context><![CDATA[const DEFAULT_MOBILITY_WEIGHTS_EG: [i32; 4] = [4, 4, 3, 2]; // N, B, R, Q
// --- Redundant King Safety Constants Removed ---
// (Using KING_ATTACK_WEIGHTS array defined above instead)]]></context>
      <message>Constants Removed ---</message>
    </item>
    <item type="SAFETY" line="33" priority="high">
      <file>./src/experiments/config.rs</file>
      <scope>struct AblationConfig</scope>
      <context><![CDATA[pub struct AblationConfig {
    /// Enable Tier 1: Safety gates (mate search + KOTH)
    pub enable_tier1_gate: bool,]]></context>
      <message>gates (mate search + KOTH)</message>
    </item>
    <item type="SAFETY" line="64" priority="high">
      <file>./src/experiments/config.rs</file>
      <scope>fn baseline_mcts</scope>
      <context><![CDATA[
    /// Tier 1 only (safety gates)
    pub fn tier1_only() -> Self {]]></context>
      <message>gates)</message>
    </item>
    <item type="SAFETY" line="6" priority="high">
      <file>./src/experiments/metrics.rs</file>
      <context><![CDATA[//! - Sample efficiency (NN calls saved)
//! - Safety (tactical errors avoided)
//! - Playing strength (Elo estimation)]]></context>
      <message>(tactical errors avoided)</message>
    </item>
    <item type="SAFETY" line="165" priority="high">
      <file>./src/experiments/metrics.rs</file>
      <scope>fn to_latex_row</scope>
      <context><![CDATA[
/// Safety metrics - tracking tactical blunders
#[derive(Debug, Clone, Default, Serialize, Deserialize)]]]></context>
      <message>metrics - tracking tactical blunders</message>
    </item>
    <item type="SAFETY" line="518" priority="high">
      <file>./src/mcts/node.rs</file>
      <scope>fn recursive_dot</scope>
      <context><![CDATA[
            // Safety check for move legality
            if let Some(mv) = child_ref.action {]]></context>
      <message>check for move legality</message>
    </item>
    <item type="SAFETY" line="225" priority="high">
      <file>./src/mcts/selection.rs</file>
      <scope>fn select_ucb_with_policy</scope>
      <context><![CDATA[    
    // Final safety check
    if let Some(ref child) = best_child {]]></context>
      <message>check</message>
    </item>
    <item type="SAFETY" line="41" priority="high">
      <file>./src/mcts/tactical_mcts.rs</file>
      <scope>struct TacticalMctsConfig</scope>
      <context><![CDATA[    // Ablation flags for paper experiments
    /// Enable Tier 1 (Safety Gates: Mate Search + KOTH)
    pub enable_tier1_gate: bool,]]></context>
      <message>Gates: Mate Search + KOTH)</message>
    </item>
    <item type="SAFETY" line="11" priority="high">
      <file>./src/search/koth.rs</file>
      <context><![CDATA[/// assuming the opponent cannot block them or reach the center themselves first.
/// This is a "safety gate" to detect rapid KOTH wins.
pub fn koth_center_in_3(board: &Board, move_gen: &MoveGen) -> bool {]]></context>
      <message>gate" to detect rapid KOTH wins.</message>
    </item>
    <item type="SAFETY" line="160" priority="high">
      <file>./src/tuning/texel.rs</file>
      <scope>fn optimize_positional_bonuses</scope>
      <context><![CDATA[        
        // King safety pawn shield bonus
        let original = weights.king_safety_pawn_shield_bonus;]]></context>
      <message>pawn shield bonus</message>
    </item>
    <item type="SAFETY" line="36" priority="high">
      <file>./tests/integration/mcts_integration_tests.rs</file>
      <scope>fn test_mcts_finds_mate_in_1</scope>
      <context><![CDATA[    
    // Should find Re8# instantly via Safety Gate
    assert_eq!(best_move.unwrap().to, 60, "Should find Re8#"); // e8 = square 60]]></context>
      <message>Gate</message>
    </item>
    <item type="SAFETY" line="38" priority="high">
      <file>./tests/integration/mcts_integration_tests.rs</file>
      <scope>fn test_mcts_finds_mate_in_1</scope>
      <context><![CDATA[    assert_eq!(best_move.unwrap().to, 60, "Should find Re8#"); // e8 = square 60
    // search_time depends on machine, but safety gate is fast.
    // However, stats.search_time might be small.]]></context>
      <message>gate is fast.</message>
    </item>
  </critical>
  <tasks>
    <item type="OPTIMIZE" line="181" priority="medium">
      <file>./DESIGN_DOC.md</file>
      <context><![CDATA[    *   **Neural Network Evaluation:** Replacing the interpretable `E_classical` evaluation function with a neural network (e.g., NNUE or a deep value network) for significantly stronger positional understanding.
    *   **Self-Play Reinforcement Learning:** Training the policy and value networks via self-play (potentially after pre-training on human or engine games) allows the engine to surpass human knowledge and optimize for pure performance, similar to engines like AlphaZero or Leela Chess Zero.
    *   **Advanced Hybrid Evaluation:** An innovative but complex approach could involve using a deep network for primary strategic evaluation (`E_{classical}(deep NN)`) and adding a tactical correction derived from a separate, fast NNUE-powered quiescence search (`Correction = V_{enhanced}(NNUE) - E_{classical}(NNUE)`), feeding `V_final = E_{classical}(deep NN) + Correction` into the MCTS. This aims to combine deep strategic insight with robust tactical verification.]]></context>
      <message>for pure performance, similar to engines like AlphaZero or Leela Chess Zero.</message>
    </item>
    <item type="TODO" line="608" priority="medium">
      <file>./IMPLEMENTATION_GUIDE.md</file>
      <context><![CDATA[            mates_found_by_gate: stats.mates_found,
            koth_wins_detected: 0, // TODO: track separately
            nn_calls_saved_tier1: stats.nn_saved_by_tier1,]]></context>
      <message>track separately</message>
    </item>
    <item type="TODO" line="329" priority="medium">
      <file>./PAPER_READY_IMPLEMENTATION_GUIDE.md</file>
      <context><![CDATA[            TournamentEngine::MctsTier1Only { iterations, mate_depth } => {
                // TODO: Need config flag to disable Tier 2
                let config = TacticalMctsConfig {]]></context>
      <message>Need config flag to disable Tier 2</message>
    </item>
    <item type="OPTIMIZE" line="60" priority="medium">
      <file>./TRAINING_GUIDE.md</file>
      <context><![CDATA[    *   Train on new data:
        *   **Policy Loss:** Optimize network's policy head to match `MCTS Policy Target` (visit counts).
        *   **Value Loss:** Optimize network's value head to match `Game Outcome Value Target`.]]></context>
      <message>network's policy head to match `MCTS Policy Target` (visit counts).</message>
    </item>
    <item type="OPTIMIZE" line="61" priority="medium">
      <file>./TRAINING_GUIDE.md</file>
      <context><![CDATA[        *   **Policy Loss:** Optimize network's policy head to match `MCTS Policy Target` (visit counts).
        *   **Value Loss:** Optimize network's value head to match `Game Outcome Value Target`.
    *   Export new `model_new.pt`.]]></context>
      <message>network's value head to match `Game Outcome Value Target`.</message>
    </item>
    <item type="TODO" line="129" priority="medium">
      <file>./src/benchmarks/tactical_suite.rs</file>
      <scope>fn benchmark_position</scope>
      <context><![CDATA[        time_taken,
        nodes_searched: 0, // TODO: Add node counting to agents
        best_move: Some(found_move),]]></context>
      <message>Add node counting to agents</message>
    </item>
    <item type="TODO" line="150" priority="medium">
      <file>./src/bin/run_experiments.rs</file>
      <scope>fn run_experiment</scope>
      <context><![CDATA[            mates_found_by_gate: stats.mates_found,
            koth_wins_detected: 0, // TODO: track separately
            nn_calls_saved_tier1: stats.nn_saved_by_tier1,]]></context>
      <message>track separately</message>
    </item>
    <item type="TODO" line="401" priority="medium">
      <file>./src/board_utils.rs</file>
      <scope>fn get_king_attack_zone_mask</scope>
      <context><![CDATA[
// TODO: Add functions to calculate attacks to a square if not using MoveGen directly in eval.
// e.g., pub fn knight_attacks(sq: usize) -> u64 { ... }]]></context>
      <message>Add functions to calculate attacks to a square if not using MoveGen directly in eval.</message>
    </item>
    <item type="TODO" line="67" priority="medium">
      <file>./src/egtb.rs</file>
      <scope>fn probe</scope>
      <context><![CDATA[        // Temporarily disabled to focus on MCTS functionality
        // TODO: Implement proper EGTB integration after MCTS is working
        Ok(None)]]></context>
      <message>Implement proper EGTB integration after MCTS is working</message>
    </item>
    <item type="TODO" line="75" priority="medium">
      <file>./src/egtb.rs</file>
      <scope>fn convert_board</scope>
      <context><![CDATA[        // Temporarily disabled to focus on MCTS functionality
        // TODO: Implement proper board conversion after MCTS is working
        Err(EgtbError::ConversionError("EGTB temporarily disabled".to_string()))]]></context>
      <message>Implement proper board conversion after MCTS is working</message>
    </item>
    <item type="TODO" line="110" priority="medium">
      <file>./src/mcts/policy.rs</file>
      <scope>fn new</scope>
      <context><![CDATA[    pub fn new(_model_path: &str) -> Self {
        // TODO: Implement model loading logic here
        OnnxPolicyNetwork {]]></context>
      <message>Implement model loading logic here</message>
    </item>
    <item type="TODO" line="120" priority="medium">
      <file>./src/mcts/policy.rs</file>
      <scope>fn evaluate</scope>
      <context><![CDATA[    fn evaluate(&self, _board: &Board, _legal_moves: &[Move]) -> (HashMap<Move, f64>, f64) {
        // TODO: Implement actual model inference here
        // 1. Convert board state to model input tensor]]></context>
      <message>Implement actual model inference here</message>
    </item>
    <item type="OPTIMIZE" line="15" priority="medium">
      <file>./src/search/alpha_beta.rs</file>
      <context><![CDATA[/// This function performs an exhaustive search to the given depth, using alpha-beta pruning
/// to optimize the search process. Includes NMP, Killers, History Heuristic, LMR.
///]]></context>
      <message>the search process. Includes NMP, Killers, History Heuristic, LMR.</message>
    </item>
    <item type="OPTIMIZE" line="67" priority="medium">
      <file>./src/tuning/texel.rs</file>
      <scope>fn optimize_iteration</scope>
      <context><![CDATA[        
        // Optimize material values
        self.optimize_material_values(&mut improved_weights, &mut best_iteration_error, move_gen);]]></context>
      <message>material values</message>
    </item>
    <item type="OPTIMIZE" line="70" priority="medium">
      <file>./src/tuning/texel.rs</file>
      <scope>fn optimize_iteration</scope>
      <context><![CDATA[        
        // Optimize piece-square table values
        self.optimize_pst_values(&mut improved_weights, &mut best_iteration_error, move_gen);]]></context>
      <message>piece-square table values</message>
    </item>
    <item type="OPTIMIZE" line="73" priority="medium">
      <file>./src/tuning/texel.rs</file>
      <scope>fn optimize_iteration</scope>
      <context><![CDATA[        
        // Optimize positional bonuses
        self.optimize_positional_bonuses(&mut improved_weights, &mut best_iteration_error, move_gen);]]></context>
      <message>positional bonuses</message>
    </item>
    <item type="OPTIMIZE" line="96" priority="medium">
      <file>./src/tuning/texel.rs</file>
      <scope>fn optimize_material_values</scope>
      <context><![CDATA[        
        // Optimize mobility weights for each piece type
        let deltas = [1, 1, 1, 1]; // Small adjustments for mobility]]></context>
      <message>mobility weights for each piece type</message>
    </item>
    <item type="OPTIMIZE" line="138" priority="medium">
      <file>./src/tuning/texel.rs</file>
      <scope>fn optimize_pst_values</scope>
      <context><![CDATA[        // This function is kept for interface compatibility
        // Future implementations could optimize king attack zone weighting or similar
    }]]></context>
      <message>king attack zone weighting or similar</message>
    </item>
    <item type="OPTIMIZE" line="142" priority="medium">
      <file>./src/tuning/texel.rs</file>
      <scope>fn optimize_positional_bonuses</scope>
      <context><![CDATA[    fn optimize_positional_bonuses(&self, weights: &mut EvalWeights, best_error: &mut f64, move_gen: &MoveGen) {
        // Optimize key positional evaluation weights
        ]]></context>
      <message>key positional evaluation weights</message>
    </item>
    <item type="TODO" line="54" priority="medium">
      <file>./src/uci.rs</file>
      <scope>fn new</scope>
      <context><![CDATA[        // Initialize EGTB prober - requires path, set to None for now
        // TODO: Add UCI option for EGTB path
        let egtb_prober: Option<EgtbProber> = None;]]></context>
      <message>Add UCI option for EGTB path</message>
    </item>
  </tasks>
</action_items>

<file_signatures>
<file path="README.md" included="true">
</file>
<file path="results/ablation_results.json" included="true">
  <signatures>
  </signatures>
</file>
<file path="Cargo.toml" included="true">
  <signatures>
  </signatures>
</file>
<file path="Dockerfile" included="true">
  <signatures>
  </signatures>
</file>
<file path=".cargo/config.toml" included="true">
  <signatures>
  </signatures>
</file>
<file path="src/neural_net.rs" included="true">
  <signatures>
    <struct name="NeuralNetPolicy">
    </struct>
    <struct name="NeuralNetPolicy">
    </struct>
  </signatures>
</file>
<file path="src/tuning/data_loader.rs" included="true">
  <signatures>
    <function visibility="Private">fn test_synthetic_data_generation()</function>
    <function visibility="Private">fn test_csv_loading() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt;</function>
    <struct name="DataLoader">
    </struct>
  </signatures>
</file>
<file path="src/tuning/mod.rs" included="true">
  <signatures>
    <function visibility="Private">fn calculate_game_phase(board: &amp;Board) -&gt; f64</function>
    <function visibility="Private">fn test_texel_position_creation()</function>
    <function visibility="Private">fn test_game_phase_calculation()</function>
    <function visibility="Private">fn test_pgn_result_parsing()</function>
    <struct name="TexelPosition">
    </struct>
  </signatures>
</file>
<file path="src/tuning/texel.rs" included="true">
  <signatures>
    <function visibility="Private">fn sigmoid(eval_cp: f64, k: f64) -&gt; f64</function>
    <function visibility="Public">pub fn create_test_dataset() -&gt; Vec&lt;TexelPosition&gt;</function>
    <function visibility="Private">fn test_sigmoid_function()</function>
    <function visibility="Private">fn test_texel_tuner_creation()</function>
    <function visibility="Private">fn test_error_calculation()</function>
    <struct name="TexelTuner">
    </struct>
  </signatures>
</file>
<file path="src/benchmarks/strength_testing.rs" included="true">
  <signatures>
    <struct name="StrengthTestConfig">
    </struct>
    <struct name="PositionResult">
    </struct>
    <struct name="StrengthTestResults">
    </struct>
    <struct name="EngineSummary">
    </struct>
    <struct name="OverallComparison">
    </struct>
    <struct name="StrengthTester">
      <doc>/// Main strength testing orchestrator</doc>
    </struct>
    <struct name="TestPosition">
    </struct>
  </signatures>
</file>
<file path="src/benchmarks/elo_tournament.rs" included="true">
  <signatures>
    <struct name="MatchResult">
    </struct>
    <struct name="TournamentConfig">
    </struct>
    <struct name="EloTournament">
      <doc>/// Main tournament runner</doc>
    </struct>
    <struct name="TournamentResults">
    </struct>
  </signatures>
</file>
<file path="src/benchmarks/mod.rs" included="true">
  <signatures>
    <function visibility="Public">pub fn create_simple_agent() -&gt; SimpleAgent&lt;'static&gt;</function>
    <function visibility="Public">pub fn create_humanlike_agent() -&gt; HumanlikeAgent&lt;'static&gt;</function>
    <struct name="BenchmarkResult">
    </struct>
    <struct name="BenchmarkSummary">
    </struct>
  </signatures>
</file>
<file path="src/benchmarks/performance.rs" included="true">
  <signatures>
    <function visibility="Public">pub fn run_performance_comparison(time_limit_per_position: Duration) -&gt; PerformanceComparison</function>
    <function visibility="Public">pub fn mate_speed_benchmark()</function>
    <function visibility="Private">fn test_performance_comparison_structure()</function>
    <struct name="PerformanceComparison">
      <doc>/// Compare performance between different engine configurations</doc>
    </struct>
  </signatures>
</file>
<file path="src/benchmarks/elo_estimation.rs" included="true">
  <signatures>
    <struct name="EloCalculator">
      <doc>/// Elo calculation utilities</doc>
    </struct>
    <struct name="EloEstimate">
    </struct>
    <struct name="RatingComponents">
    </struct>
    <struct name="EngineComparison">
    </struct>
    <struct name="EloReport">
    </struct>
  </signatures>
</file>
<file path="src/benchmarks/tactical_suite.rs" included="true">
  <signatures>
    <function visibility="Public">pub fn get_tactical_test_suite() -&gt; Vec&lt;TacticalPosition&gt;</function>
    <function visibility="Public">pub fn benchmark_position&lt;T: Agent&gt;(
    position: &amp;TacticalPosition, 
    agent: &amp;mut T,
    time_limit: Duration
) -&gt; BenchmarkResult</function>
    <function visibility="Public">pub fn run_tactical_benchmark&lt;T: Agent&gt;(
    agent: &amp;mut T, 
    engine_name: &amp;str, 
    time_limit_per_position: Duration
) -&gt; Vec&lt;BenchmarkResult&gt;</function>
    <function visibility="Private">fn test_tactical_positions_load()</function>
    <function visibility="Private">fn test_best_move_parsing()</function>
    <struct name="TacticalPosition">
    </struct>
  </signatures>
</file>
<file path="src/magic_constants.rs" included="true">
  <signatures>
  </signatures>
</file>
<file path="src/board_utils.rs" included="true">
  <signatures>
    <function visibility="Public">pub fn coords_to_sq_ind(file: usize, rank: usize) -&gt; usize</function>
    <function visibility="Public">pub fn sq_ind_to_coords(sq_ind: usize) -&gt; (usize, usize)</function>
    <function visibility="Public">pub fn sq_ind_to_bit(sq_ind: usize) -&gt; u64</function>
    <function visibility="Public">pub fn bit_to_sq_ind(bit: u64) -&gt; usize</function>
    <function visibility="Public">pub fn sq_ind_to_algebraic(sq_ind: usize) -&gt; String</function>
    <function visibility="Public">pub fn algebraic_to_sq_ind(algebraic: &amp;str) -&gt; usize</function>
    <function visibility="Public">pub fn algebraic_to_bit(algebraic: &amp;str) -&gt; u64</function>
    <function visibility="Public">pub fn bit_to_algebraic(bit: u64) -&gt; String</function>
    <function visibility="Public">pub fn flip_sq_ind_vertically(sq_ind: usize) -&gt; usize</function>
    <function visibility="Public">pub fn flip_vertically(bit: u64) -&gt; u64</function>
    <function visibility="Public">pub fn sq_to_rank(sq_ind: usize) -&gt; usize</function>
    <function visibility="Public">pub fn sq_to_file(sq_ind: usize) -&gt; usize</function>
    <function visibility="Public">pub fn get_passed_pawn_mask(color: usize, sq_ind: usize) -&gt; u64</function>
    <function visibility="Public">pub fn get_king_shield_zone_mask(color: usize, king_sq_ind: usize) -&gt; u64</function>
    <function visibility="Public">pub fn get_file_mask(file: usize) -&gt; u64</function>
    <function visibility="Public">pub fn get_adjacent_files_mask(sq_ind: usize) -&gt; u64</function>
    <function visibility="Public">pub fn get_pawn_front_square_mask(color: usize, sq_ind: usize) -&gt; u64</function>
    <function visibility="Public">pub fn get_rank_mask(rank: usize) -&gt; u64</function>
    <function visibility="Public">pub fn get_front_span_mask(color: usize, sq: usize) -&gt; u64</function>
    <function visibility="Public">pub fn get_king_attack_zone_mask(_color: usize, king_sq: usize) -&gt; u64</function>
  </signatures>
</file>
<file path="src/bin/tactical_cache_demo.rs" included="true">
  <signatures>
    <function visibility="Private">fn main()</function>
    <function visibility="Private">fn benchmark_cache_performance(positions: &amp;[(&amp;str, &amp;str)], move_gen: &amp;MoveGen)</function>
    <function visibility="Private">fn benchmark_repeated_positions(positions: &amp;[(&amp;str, &amp;str)], move_gen: &amp;MoveGen)</function>
    <function visibility="Private">fn display_final_statistics()</function>
  </signatures>
</file>
<file path="src/bin/tactical_profiler.rs" included="true">
  <signatures>
    <function visibility="Private">fn profile_position(
    board: Board,
    move_gen: &amp;MoveGen,
    pesto_eval: &amp;PestoEval,
    config: TacticalMctsConfig,
) -&gt; ProfileResult</function>
    <function visibility="Private">fn run_profiling_suite()</function>
    <function visibility="Private">fn print_profile_result(result: &amp;ProfileResult)</function>
    <function visibility="Private">fn print_scaling_result(result: &amp;ProfileResult, target_iterations: u32)</function>
    <function visibility="Private">fn analyze_memory_usage()</function>
    <function visibility="Private">fn identify_bottlenecks()</function>
    <function visibility="Private">fn main()</function>
    <struct name="ProfileResult">
    </struct>
  </signatures>
</file>
<file path="src/bin/run_experiments.rs" included="true">
  <signatures>
    <function visibility="Private">fn main()</function>
    <function visibility="Private">fn run_ablation_study()</function>
    <function visibility="Private">fn run_single_config(name: &amp;str)</function>
    <function visibility="Private">fn run_experiment(
    config: &amp;ExperimentConfig,
    test_positions: &amp;[(String, Board, Option&lt;String&gt;, String)],
) -&gt; ExperimentResults</function>
    <function visibility="Private">fn load_test_suite(suite: &amp;TestSuite) -&gt; Vec&lt;(String, Board, Option&lt;String&gt;, String)&gt;</function>
    <function visibility="Private">fn print_summary(results: &amp;ExperimentResults)</function>
    <function visibility="Private">fn generate_latex_table(results: &amp;[ExperimentResults])</function>
    <function visibility="Private">fn save_results_json(results: &amp;[ExperimentResults])</function>
  </signatures>
</file>
<file path="src/bin/neural_integration_demo.rs" included="true">
  <signatures>
    <function visibility="Private">fn main()</function>
  </signatures>
</file>
<file path="src/bin/generate_training_data.rs" included="true">
  <signatures>
    <function visibility="Private">fn main()</function>
    <function visibility="Private">fn create_sample_games() -&gt; Vec&lt;ParsedGame&gt;</function>
  </signatures>
</file>
<file path="src/bin/benchmark.rs" included="true">
  <signatures>
    <function visibility="Private">fn print_banner()</function>
    <function visibility="Private">fn print_usage()</function>
    <function visibility="Private">fn run_tactical_benchmark_cmd()</function>
    <function visibility="Private">fn run_comparison_cmd()</function>
    <function visibility="Private">fn run_speed_cmd()</function>
    <function visibility="Private">fn run_all_benchmarks()</function>
    <function visibility="Private">fn main()</function>
    <function visibility="Private">fn test_benchmark_suite_loads()</function>
    <function visibility="Private">fn test_agents_create()</function>
  </signatures>
</file>
<file path="src/bin/mcts_inspector.rs" included="true">
  <signatures>
    <function visibility="Private">fn main()</function>
    <function visibility="Private">fn parse_arg(args: &amp;[String], flag: &amp;str) -&gt; Option&lt;u32&gt;</function>
    <function visibility="Private">fn parse_string_arg(args: &amp;[String], flag: &amp;str) -&gt; Option&lt;String&gt;</function>
    <function visibility="Private">fn print_usage()</function>
  </signatures>
</file>
<file path="src/bin/quick_test.rs" included="true">
  <signatures>
    <function visibility="Private">fn main()</function>
  </signatures>
</file>
<file path="src/bin/verbose_search.rs" included="true">
  <signatures>
    <function visibility="Private">fn main()</function>
    <function visibility="Private">fn parse_arg(args: &amp;[String], flag: &amp;str) -&gt; Option&lt;u32&gt;</function>
    <function visibility="Private">fn parse_verbosity(args: &amp;[String]) -&gt; Option&lt;Verbosity&gt;</function>
    <function visibility="Private">fn print_usage()</function>
  </signatures>
</file>
<file path="src/bin/verify_features.rs" included="true">
  <signatures>
    <function visibility="Private">fn main()</function>
  </signatures>
</file>
<file path="src/bin/texel_tune.rs" included="true">
  <signatures>
    <function visibility="Private">fn main()</function>
  </signatures>
</file>
<file path="src/bin/elo_tournament.rs" included="true">
  <signatures>
    <function visibility="Private">fn main()</function>
    <function visibility="Private">fn parse_arg(args: &amp;[String], flag: &amp;str) -&gt; Option&lt;u32&gt;</function>
    <function visibility="Private">fn parse_string_arg(args: &amp;[String], flag: &amp;str) -&gt; Option&lt;String&gt;</function>
  </signatures>
</file>
<file path="src/bin/see_integration_demo.rs" included="true">
  <signatures>
    <function visibility="Private">fn main()</function>
    <function visibility="Private">fn analyze_see_impact(positions: &amp;[(&amp;str, &amp;str, &amp;str)], move_gen: &amp;MoveGen)</function>
    <function visibility="Private">fn compare_tactical_quality(positions: &amp;[(&amp;str, &amp;str, &amp;str)], move_gen: &amp;MoveGen)</function>
    <function visibility="Private">fn demonstrate_exchange_evaluations(move_gen: &amp;MoveGen)</function>
  </signatures>
</file>
<file path="src/bin/self_play.rs" included="true">
  <signatures>
    <function visibility="Private">fn main()</function>
    <function visibility="Private">fn play_game(_game_num: usize, simulations: u32, model_path: Option&lt;String&gt;) -&gt; Vec&lt;TrainingSample&gt;</function>
    <function visibility="Private">fn save_binary_data(filename: &amp;str, samples: &amp;[TrainingSample]) -&gt; std::io::Result&lt;()&gt;</function>
    <struct name="TrainingSample">
    </struct>
  </signatures>
</file>
<file path="src/bin/mate_search_tt_demo.rs" included="true">
  <signatures>
    <function visibility="Private">fn main()</function>
    <function visibility="Private">fn show_tt_speedup(
    positions: &amp;[(&amp;str, &amp;str)],
    move_gen: &amp;MoveGen,
    pesto_eval: &amp;PestoEval,
)</function>
    <function visibility="Private">fn analyze_mate_cache_efficiency(
    positions: &amp;[(&amp;str, &amp;str)],
    move_gen: &amp;MoveGen,
    pesto_eval: &amp;PestoEval,
)</function>
    <function visibility="Private">fn benchmark_repeated_searches(
    positions: &amp;[(&amp;str, &amp;str)],
    move_gen: &amp;MoveGen,
    pesto_eval: &amp;PestoEval,
)</function>
  </signatures>
</file>
<file path="src/bin/strength_test.rs" included="true">
  <signatures>
    <function visibility="Private">fn main()</function>
    <function visibility="Private">fn parse_args(args: &amp;[String]) -&gt; StrengthTestConfig</function>
    <function visibility="Private">fn print_help()</function>
  </signatures>
</file>
<file path="src/bin/verify_tactical_graft.rs" included="true">
  <signatures>
    <function visibility="Private">fn main()</function>
  </signatures>
</file>
<file path="src/bin/benchmark_gates.rs" included="true">
  <signatures>
    <function visibility="Private">fn main()</function>
  </signatures>
</file>
<file path="src/bin/tactical_benchmark.rs" included="true">
  <signatures>
    <function visibility="Public">pub fn run_comprehensive_benchmark(config: BenchmarkConfig) -&gt; BenchmarkResults</function>
    <function visibility="Private">fn benchmark_tactical_mcts(
    board: &amp;Board,
    move_gen: &amp;MoveGen,
    pesto_eval: &amp;PestoEval,
    config: &amp;BenchmarkConfig,
) -&gt; SearchResult</function>
    <function visibility="Private">fn benchmark_classical_mcts(
    board: &amp;Board,
    move_gen: &amp;MoveGen,
    pesto_eval: &amp;PestoEval,
    config: &amp;BenchmarkConfig,
) -&gt; SearchResult</function>
    <function visibility="Private">fn benchmark_alpha_beta(
    board: &amp;Board,
    move_gen: &amp;MoveGen,
    pesto_eval: &amp;PestoEval,
    config: &amp;BenchmarkConfig,
) -&gt; SearchResult</function>
    <function visibility="Private">fn main()</function>
    <struct name="BenchmarkConfig">
    </struct>
    <struct name="SearchResult">
    </struct>
    <struct name="BenchmarkResults">
    </struct>
  </signatures>
</file>
<file path="src/lib.rs" included="true">
  <signatures>
  </signatures>
</file>
<file path="src/tensor.rs" included="true">
  <signatures>
    <function visibility="Public">pub fn move_to_index(mv: Move) -&gt; usize</function>
    <function visibility="Private">fn test_queen_slide()</function>
    <function visibility="Private">fn test_knight_move()</function>
    <function visibility="Private">fn test_underpromotion()</function>
  </signatures>
</file>
<file path="src/egtb.rs" included="true">
  <signatures>
    <function visibility="Private">fn test_new_invalid_path()</function>
    <function visibility="Private">fn test_probe_piece_count_within_limit()</function>
    <function visibility="Private">fn test_probe_piece_count_exceeds_limit()</function>
    <struct name="EgtbInfo">
    </struct>
    <struct name="EgtbProber">
    </struct>
    <struct name="PieceCountCheckProber">
    </struct>
  </signatures>
</file>
<file path="src/make_move.rs" included="true">
  <signatures>
  </signatures>
</file>
<file path="src/training/mod.rs" included="true">
  <signatures>
    <function visibility="Private">fn test_training_position_csv()</function>
    <function visibility="Private">fn test_tactical_positions()</function>
    <function visibility="Private">fn test_piece_counting()</function>
    <struct name="TrainingPosition">
    </struct>
    <struct name="TrainingDataGenerator">
      <doc>/// Training data generator</doc>
    </struct>
    <struct name="ParsedGame">
    </struct>
  </signatures>
</file>
<file path="results/figures/summary.md" included="true">
  <signatures>
  </signatures>
</file>
<file path="STREAM_OF_CONSCIOUSNESS_IMPLEMENTATION_GUIDE.md" included="true">
  <signatures>
  </signatures>
</file>
<file path="BENCHMARKING.md" included="true">
  <signatures>
  </signatures>
</file>
<file path="HUMANLIKE_AGENT.md" included="true">
  <signatures>
  </signatures>
</file>
<file path="RESEARCH.md" included="true">
  <signatures>
  </signatures>
</file>
<file path="TESTING.md" included="true">
  <signatures>
  </signatures>
</file>
<file path="STREAM_OF_CONSCIOUSNESS_LOGGER.md" included="true">
  <signatures>
  </signatures>
</file>
<file path="IMPLEMENTATION_GUIDE.md" included="true">
  <signatures>
  </signatures>
</file>
<file path="requirements.txt" included="true">
  <signatures>
  </signatures>
</file>
<file path="PAPER_READY_IMPLEMENTATION_GUIDE.md" included="true">
  <signatures>
  </signatures>
</file>
<file path="DESIGN_DOC.md" included="true">
  <signatures>
  </signatures>
</file>
<file path="MCTS_TACTICAL_PRIORITY.md" included="true">
  <signatures>
  </signatures>
</file>
<file path="ARCHITECTURE.md" included="true">
  <signatures>
  </signatures>
</file>
<file path="TRAINING_GUIDE.md" included="true">
  <signatures>
  </signatures>
</file>
<file path="MCTS_INSPECTOR_IMPLEMENTATION_GUIDE.md" included="true">
  <signatures>
  </signatures>
</file>
<file path="python/README.md" included="true">
  <signatures>
  </signatures>
</file>
<file path="src/hash.rs" included="false" relevance="1.9">
  <signatures>
  </signatures>
</file>
<file path="src/alpha_beta.rs" included="false" relevance="1.9">
  <signatures>
    <function>is_capture</function>
  </signatures>
</file>
<file path="src/mcts/search_logger.rs" included="false" relevance="1.8">
  <signatures>
    <function>set_global_logger</function>
    <function>with_global_logger</function>
    <function>with_global_logger_mut</function>
  </signatures>
</file>
<file path="src/mcts/nn_counter.rs" included="false" relevance="1.8">
  <signatures>
    <function>test_counting_neural_net_policy</function>
    <function>test_efficiency_comparison</function>
  </signatures>
</file>
<file path="src/mcts/neural_mcts.rs" included="false" relevance="1.8">
  <signatures>
    <function>neural_mcts_search</function>
  </signatures>
</file>
<file path="src/mcts/policy.rs" included="false" relevance="1.8">
  <signatures>
  </signatures>
</file>
<file path="src/mcts/tactical.rs" included="false" relevance="1.8">
  <signatures>
    <function>identify_tactical_moves</function>
    <function>get_tactical_cache_stats</function>
    <function>clear_tactical_cache</function>
    <function>identify_tactical_moves_internal</function>
    <function>calculate_mvv_lva</function>
  </signatures>
</file>
<file path="src/mcts/tactical_mcts.rs" included="false" relevance="1.8">
  <signatures>
    <function>tactical_mcts_search</function>
    <function>tactical_mcts_search_with_tt</function>
    <function>select_leaf_node</function>
    <function>evaluate_leaf_node</function>
    <function>evaluate_and_expand_node</function>
  </signatures>
</file>
<file path="src/mcts/mod.rs" included="false" relevance="1.7">
  <signatures>
    <function>mcts_pesto_search</function>
  </signatures>
</file>
<file path="src/mcts/inference_server.rs" included="false" relevance="1.7">
  <signatures>
  </signatures>
</file>
<file path="src/mcts/node.rs" included="false" relevance="1.7">
  <signatures>
    <function>should_expand_not_select</function>
    <function>select_leaf_for_expansion</function>
  </signatures>
</file>
<file path="src/mcts/selection.rs" included="false" relevance="1.7">
  <signatures>
    <function>select_child_with_tactical_priority</function>
    <function>ensure_node_expanded</function>
    <function>select_unexplored_tactical_move</function>
    <function>select_ucb_with_policy</function>
    <function>calculate_ucb_value</function>
  </signatures>
</file>
<file path="src/mcts/simulation.rs" included="false" relevance="1.7">
  <signatures>
    <function>simulate_random_playout</function>
    <function>simple_material_eval</function>
  </signatures>
</file>
<file path="src/mcts/unit_tests/tactical_tests.rs" included="false" relevance="1.7">
  <signatures>
    <function>setup_test_env</function>
    <function>test_mvv_lva_basic_scoring</function>
    <function>test_tactical_move_identification</function>
    <function>test_no_tactical_moves_in_quiet_position</function>
    <function>test_tactical_move_scoring</function>
  </signatures>
</file>
<file path="src/mcts/unit_tests/mcts_integration_tests.rs" included="false" relevance="1.7">
  <signatures>
    <function>setup_test_env</function>
    <function>get_test_config</function>
    <function>test_basic_search_functionality</function>
    <function>test_tactical_position_search</function>
    <function>test_mate_detection_integration</function>
  </signatures>
</file>
<file path="src/mcts/unit_tests/selection_tests.rs" included="false" relevance="1.6">
  <signatures>
    <function>setup_test_env</function>
    <function>test_node_expansion_from_start</function>
    <function>test_tactical_move_prioritization</function>
    <function>test_statistics_tracking</function>
    <function>test_ucb_selection_with_policy</function>
  </signatures>
</file>
<file path="src/piece_types.rs" included="false" relevance="1.6">
  <signatures>
  </signatures>
</file>
<file path="src/move_types.rs" included="false" relevance="1.6">
  <signatures>
    <function>test_move_from_uci</function>
    <function>test_move_special_methods</function>
  </signatures>
</file>
<file path="src/arena.rs" included="false" relevance="1.6">
  <signatures>
  </signatures>
</file>
<file path="src/boardstack.rs" included="false" relevance="1.6">
  <signatures>
  </signatures>
</file>
<file path="src/transposition.rs" included="false" relevance="1.6">
  <signatures>
  </signatures>
</file>
<file path="src/bits.rs" included="false" relevance="1.6">
  <signatures>
    <function>bits</function>
    <function>ibset</function>
    <function>ibclr</function>
    <function>btest</function>
    <function>popcnt</function>
  </signatures>
</file>
<file path="src/board.rs" included="false" relevance="1.6">
  <signatures>
  </signatures>
</file>
<file path="src/move_generation.rs" included="false" relevance="1.5">
  <signatures>
    <function>generate_file_masks</function>
    <function>generate_rank_masks</function>
    <function>generate_diag_masks</function>
    <function>generate_anti_diag_masks</function>
  </signatures>
</file>
<file path="src/experiments/metrics.rs" included="false" relevance="1.5">
  <signatures>
  </signatures>
</file>
<file path="src/experiments/mod.rs" included="false" relevance="1.5">
  <signatures>
  </signatures>
</file>
<file path="src/experiments/position_classifier.rs" included="false" relevance="1.5">
  <signatures>
  </signatures>
</file>
<file path="src/experiments/config.rs" included="false" relevance="1.5">
  <signatures>
    <function>generate_ablation_configs</function>
  </signatures>
</file>
<file path="src/eval_constants.rs" included="false" relevance="1.5">
  <signatures>
  </signatures>
</file>
<file path="src/uci.rs" included="false" relevance="1.5">
  <signatures>
    <function>test_handle_position_startpos</function>
    <function>test_handle_position_startpos_moves</function>
    <function>test_handle_position_fen</function>
    <function>test_handle_position_fen_moves</function>
    <function>test_parse_go_movetime</function>
  </signatures>
</file>
<file path="src/eval.rs" included="false" relevance="1.5">
  <signatures>
    <function>extrapolate_value</function>
  </signatures>
</file>
<file path="src/search/mate_search.rs" included="false" relevance="1.4">
  <signatures>
    <function>mate_search</function>
    <function>iterative_deepening_wrapper</function>
    <function>mate_search_recursive</function>
  </signatures>
</file>
<file path="src/search/see.rs" included="false" relevance="1.4">
  <signatures>
    <function>see</function>
    <function>find_least_valuable_attacker_sq</function>
    <function>get_piece_type_on_sq</function>
    <function>clear_square</function>
    <function>set_square</function>
  </signatures>
</file>
<file path="src/search/quiescence.rs" included="false" relevance="1.4">
  <signatures>
    <function>quiescence_search</function>
    <function>quiescence_search_tactical</function>
  </signatures>
</file>
<file path="src/search/koth.rs" included="false" relevance="1.4">
  <signatures>
    <function>koth_center_in_3</function>
    <function>solve_koth_in_3</function>
  </signatures>
</file>
<file path="src/search/iterative_deepening.rs" included="false" relevance="1.4">
  <signatures>
    <function>iterative_deepening_ab_search</function>
    <function>aspiration_window_ab_search</function>
  </signatures>
</file>
<file path="src/search/mod.rs" included="false" relevance="1.4">
  <signatures>
  </signatures>
</file>
<file path="src/search/alpha_beta.rs" included="false" relevance="1.4">
  <signatures>
    <function>alpha_beta_search</function>
    <function>alpha_beta_recursive</function>
    <function>is_capture</function>
  </signatures>
</file>
<file path="src/search/history.rs" included="false" relevance="1.4">
  <signatures>
  </signatures>
</file>
<file path="src/utils.rs" included="false" relevance="1.4">
  <signatures>
    <function>print_bits</function>
    <function>print_move</function>
  </signatures>
</file>
<file path="src/main.rs" included="false" relevance="1.4">
  <signatures>
    <function>run_simple_game</function>
    <function>main</function>
  </signatures>
</file>
<file path="src/agent.rs" included="false" relevance="1.4">
  <signatures>
  </signatures>
</file>
<file path="src/magic_bitboard.rs" included="false" relevance="1.3">
  <signatures>
    <function>find_magic_numbers</function>
    <function>init_king_moves</function>
    <function>init_knight_moves</function>
    <function>init_pawn_captures_promotions</function>
    <function>init_pawn_moves</function>
  </signatures>
</file>
<file path="scripts/analyze_results.py" included="false" relevance="1.3">
  <signatures>
    <function>load_results</function>
    <function>plot_nn_reduction</function>
    <function>plot_tier_breakdown</function>
    <function>plot_safety_metrics</function>
    <function>plot_efficiency_vs_accuracy</function>
  </signatures>
</file>
<file path="scripts/run_paper_experiments.sh" included="false" relevance="1.3">
  <signatures>
  </signatures>
</file>
<file path="scripts/generate_figures.py" included="false" relevance="1.3">
  <signatures>
    <function>generate_figures</function>
  </signatures>
</file>
<file path="scripts/test.sh" included="false" relevance="1.3">
  <signatures>
  </signatures>
</file>
<file path="test_tactical_mcts.rs" included="false" relevance="1.3">
  <signatures>
    <function>main</function>
  </signatures>
</file>
<file path=".github/workflows/experiments.yml" included="false" relevance="1.2">
  <signatures>
  </signatures>
</file>
<file path=".github/workflows/rust.yml" included="false" relevance="1.2">
  <signatures>
  </signatures>
</file>
<file path="tests/property/mod.rs" included="false" relevance="1.2">
  <signatures>
  </signatures>
</file>
<file path="tests/property/invariant_tests.rs" included="false" relevance="1.2">
  <signatures>
    <function>random_position</function>
    <function>extract_plane</function>
  </signatures>
</file>
<file path="tests/eval_piece_bonus_tests.rs" included="false" relevance="1.2">
  <signatures>
    <function>get_raw_scores</function>
    <function>test_two_bishops_bonus</function>
    <function>test_king_safety_pawn_shield</function>
  </signatures>
</file>
<file path="tests/bitboard_tests.rs" included="false" relevance="1.2">
  <signatures>
    <function>test_initial_position</function>
    <function>test_get_piece_bitboard</function>
    <function>test_make_move</function>
    <function>test_is_legal</function>
    <function>test_is_illegal</function>
  </signatures>
</file>
<file path="tests/common/mod.rs" included="false" relevance="1.2">
  <signatures>
    <function>board_from_fen</function>
    <function>legal_moves_set</function>
    <function>generate_legal_moves</function>
    <function>assert_approx_eq</function>
    <function>assert_in_tanh_domain</function>
  </signatures>
</file>
<file path="tests/unit/graphviz_tests.rs" included="false" relevance="1.2">
  <signatures>
    <function>test_export_dot_basic_structure</function>
    <function>test_export_dot_mate_position_shows_gate_color</function>
    <function>test_export_dot_tactical_position_shows_graft_color</function>
    <function>test_node_origin_enum_colors</function>
    <function>test_node_origin_labels</function>
  </signatures>
</file>
<file path="tests/unit/node_tests.rs" included="false" relevance="1.2">
  <signatures>
    <function>test_terminal_value_checkmate</function>
    <function>test_terminal_value_stalemate</function>
    <function>test_values_in_tanh_domain</function>
  </signatures>
</file>
<file path="tests/unit/move_generation_tests.rs" included="false" relevance="1.2">
  <signatures>
    <function>test_en_passant_generation</function>
    <function>test_castling_generation</function>
    <function>test_castling_blocked_by_check</function>
    <function>test_promotion_moves</function>
  </signatures>
</file>
<file path="tests/unit/mod.rs" included="false" relevance="1.2">
  <signatures>
  </signatures>
</file>
<file path="tests/unit/tensor_tests.rs" included="false" relevance="1.2">
  <signatures>
    <function>test_tensor_stm_symmetry</function>
    <function>test_tensor_dimensions</function>
    <function>test_castling_planes</function>
    <function>test_en_passant_plane</function>
    <function>extract_plane</function>
  </signatures>
</file>
<file path="tests/unit/search_logger_tests.rs" included="false" relevance="1.1">
  <signatures>
    <function>test_logger_silent_produces_no_output</function>
    <function>test_logger_buffered_captures_output</function>
    <function>test_logger_respects_verbosity_levels</function>
    <function>test_gate_reason_descriptions</function>
    <function>test_selection_reason_formatting</function>
  </signatures>
</file>
<file path="tests/unit/board_tests.rs" included="false" relevance="1.1">
  <signatures>
    <function>test_starting_position_parsing</function>
    <function>test_fen_roundtrip</function>
    <function>test_en_passant_square_parsing</function>
    <function>test_checkmate_detection</function>
    <function>test_stalemate_detection</function>
  </signatures>
</file>
<file path="tests/unit/selection_tests.rs" included="false" relevance="1.1">
  <signatures>
    <function>test_ucb_unvisited_uses_q_init</function>
    <function>test_ucb_visited_ignores_q_init</function>
    <function>test_ucb_exploration_term</function>
    <function>calculate_ucb_value_for_test</function>
  </signatures>
</file>
<file path="tests/move_generation_tests.rs" included="false" relevance="1.1">
  <signatures>
    <function>test_initial_move_count</function>
    <function>test_knight_moves</function>
    <function>test_pawn_promotion</function>
    <function>test_capture_ordering</function>
    <function>test_non_capture_ordering_white</function>
  </signatures>
</file>
<file path="tests/neural_integration_tests.rs" included="false" relevance="1.1">
  <signatures>
    <function>test_neural_network_integration</function>
    <function>test_neural_network_stub_behavior</function>
  </signatures>
</file>
<file path="tests/perft_tests.rs" included="false" relevance="1.1">
  <signatures>
    <function>perft</function>
    <function>test_start_pos_perft1</function>
    <function>test_start_pos_perft2</function>
    <function>test_start_pos_perft3</function>
    <function>test_start_pos_perft4</function>
  </signatures>
</file>
<file path="tests/regression/mod.rs" included="false" relevance="1.1">
  <signatures>
  </signatures>
</file>
<file path="tests/regression/recent_fixes_tests.rs" included="false" relevance="1.1">
  <signatures>
    <function>test_no_probability_domain_values</function>
    <function>test_symmetric_position_symmetric_eval</function>
    <function>test_checkmate_value_is_loss_for_stm</function>
    <function>test_tactical_values_influence_selection</function>
    <function>extract_plane</function>
  </signatures>
</file>
<file path="tests/make_move_tests.rs" included="false" relevance="1.1">
  <signatures>
    <function>create_move</function>
    <function>create_promo_move</function>
    <function>test_apply_pawn_push</function>
    <function>test_apply_capture</function>
    <function>test_apply_en_passant</function>
  </signatures>
</file>
<file path="tests/mate_portfolio_tests.rs" included="false" relevance="1.1">
  <signatures>
    <function>test_mate_search_portfolio</function>
    <function>run_portfolio_test_case</function>
  </signatures>
</file>
<file path="tests/repetition_tests.rs" included="false" relevance="1.1">
  <signatures>
    <function>test_threefold_repetition</function>
    <function>test_repetition_with_different_castling_rights</function>
    <function>test_repetition_with_different_en_passant</function>
  </signatures>
</file>
<file path="tests/integration/mod.rs" included="false" relevance="1.1">
  <signatures>
  </signatures>
</file>
<file path="tests/integration/mcts_integration_tests.rs" included="false" relevance="1.1">
  <signatures>
    <function>test_mcts_finds_mate_in_1</function>
    <function>test_mcts_finds_mate_for_black</function>
    <function>test_mcts_finds_koth_win</function>
    <function>test_mcts_prefers_winning_capture</function>
    <function>test_backpropagation_sign_consistency</function>
  </signatures>
</file>
<file path="tests/mcts_tests.rs" included="false" relevance="1.1">
  <signatures>
    <function>setup</function>
    <function>setup_test_env</function>
    <function>parse_uci_move</function>
    <function>create_move</function>
    <function>test_node_new_root</function>
  </signatures>
</file>
<file path="tests/eval_pawn_structure_tests.rs" included="false" relevance="1.1">
  <signatures>
    <function>get_raw_scores</function>
    <function>test_passed_pawn_bonus</function>
    <function>test_isolated_pawn_penalty</function>
    <function>test_pawn_chain_bonus</function>
    <function>test_pawn_duo_bonus</function>
  </signatures>
</file>
<file path="python/export_model.py" included="false" relevance="1.0">
  <signatures>
    <function>export_model</function>
  </signatures>
</file>
<file path="python/train.py" included="false" relevance="1.0">
  <signatures>
    <function>train</function>
  </signatures>
</file>
<file path="python/orchestrate.py" included="false" relevance="1.0">
  <signatures>
    <function>export_model_for_rust</function>
    <function>initialize_generation_0</function>
    <function>orchestrate</function>
  </signatures>
</file>
<file path="python/model.py" included="false" relevance="1.0">
  <signatures>
  </signatures>
</file>
<file path="python/training_pipeline.py" included="false" relevance="1.0">
  <signatures>
    <function>move_to_index</function>
    <function>main</function>
  </signatures>
</file>
<file path="python/train_chess_ai.py" included="false" relevance="1.0">
  <signatures>
    <function>main</function>
  </signatures>
</file>
<file path="python/test_architectures.py" included="false" relevance="1.0">
  <signatures>
    <function>count_parameters</function>
    <function>index_to_uci</function>
    <function>test_model_shapes</function>
    <function>test_overfitting</function>
    <function>get_starting_position_tensor</function>
  </signatures>
</file>
<file path="python/data_collection.py" included="false" relevance="1.0">
  <signatures>
    <function>main</function>
  </signatures>
</file>
<file path="run_validation_experiments.sh" included="false" relevance="1.0">
  <signatures>
  </signatures>
</file>
</file_signatures>

<file_contents>
<file path="README.md" tokens="3011" focus="true" inclusion="full" relevance="100.0" reason="Primary README - always included">
<content>
<![CDATA[
# Caissawary Chess Engine (formerly Kingfisher)
## A Tactics-Enhanced Hybrid MCTS Engine with State-Dependent Search Logic

Caissawary is a chess engine that combines the strategic guidance of a modern Monte Carlo Tree Search (MCTS) with the ruthless tactical precision of classical search. Its unique, state-dependent search algorithm prioritizes forcing moves and minimizes expensive neural network computations to create a brutally efficient and tactically sharp engine.

![Caissawary Logo](Caissawary.png)

[![Rust](https://img.shields.io/badge/rust-1.70+-orange)](https://rustup.rs/)
[![License](https://img.shields.io/badge/license-MIT-blue)](LICENSE)

## The Name: Caissawary
Like the engine itself, the name Caissawary is also a hybrid:

- **Cassa**: The mythical goddess of chess, representing the engine's strategic intelligence and artistry.
- **Cassowary**: A large, formidable, and famously aggressive bird, representing the engine's raw tactical power and speed.

##  Research: Safe & Sample-Efficient RL

Caissawary is designed as a research platform exploring **how structured inductive biases improve reinforcement learning**. Our key insight: many RL domains contain tractable subproblems where exact analysis outperforms learned approximations.

### The Three-Tier Hypothesis

| Tier | Mechanism | Property |
|------|-----------|
| **Tier 1** | Safety Gates | Provably correct in forced situations |
| **Tier 2** | Tactical Grafting | Classical expertise without NN overhead |
| **Tier 3** | Neural Networks | Handles genuinely uncertain positions |

### Running Experiments

```bash
# Full ablation study
cargo run --release --bin run_experiments -- --config ablation

# Generate publication figures
python scripts/analyze_results.py results/ablation_results.json

# View results
# (Output will be in results/figures/)
```

See [RESEARCH.md](RESEARCH.md) for full methodology and analysis.

##  Architecture
Caissawary's intelligence stems from how it handles each node during an MCTS traversal. Instead of a single, uniform approach, its behavior adapts based on the node's state, ensuring that cheap, powerful analysis is always performed before expensive strategic evaluation.

### The MCTS Node Handling Flow
When the MCTS search selects a node, its state determines the next action:

#### 1. Safety Gates (Tier 1):
Before any expansion, the engine runs ultra-fast "Safety Gates" to detect immediate win/loss conditions:
- **Checks-Only Mate Search:** A depth-limited DFS that only considers checking moves. It instantly spots forced mate sequences (like Mate-in-2) that standard MCTS might miss due to low visit counts.
- **KOTH Geometric Gate:** A geometric pruning algorithm that detects if a King can reach the center (King of the Hill win) within 3 moves faster than the opponent.

#### 2. Tactical Integration (Tier 2):
If the node is not a terminal state, the engine performs a "Tactical Graft":
- **Quiescence Search (QS):** An integer-based tactical search runs on the CPU to resolve captures and checks using hard-coded piece values (1, 3, 3, 5, 9).
- **Grafting:** The best tactical move found by QS is "grafted" into the MCTS tree immediately.
- **Dynamic Value Extrapolation:** The engine uses the **Symbolic Residual Formula** to price the material won by the CPU:
  $$V_{final} = \tanh\left(\text{arctanh}(V_{parent}) + k \cdot \Delta M\right)$$
  Where $k$ is a **position-specific confidence scalar** predicted by the neural network. This allows the engine to determine if a material advantage is decisive or irrelevant in the current strategic context.

#### 3. Strategic Evaluation (Tier 3):
If no tactical resolution is sufficient, the engine engages the **LogosNet** (if enabled):
- **Dual Value Heads:** The network predicts both a deep strategic logit ($V_{net}$) and a material confidence logit ($K_{net}$).
- **Lazy Evaluation:** The network is queried only when necessary, and its predictions guide the selection of "Quiet" moves via PUCT.

## Tier 2: Tactical Grafting
Instead of treating all new nodes as equal, Caissawary injects tactical knowledge directly into the tree structure. This "Neurosymbolic" approach separates **Logical Truth** from **Contextual Interpretation**.

- **The CPU (Logical Truth):** Runs minimax on captures using raw integers. It is blazing fast and ignores strategic "noise."
- **The Neural Net (Contextual Interpretation):** Predicts $k$, the "price" of material.
- **Symbolic Recombination:** By combining these, the engine "grafts" tactical sequences into the MCTS tree with highly accurate initial values, solving the "cold start" problem for sharp positions.

## Tier 3: LogosNet Architecture (Optional)
The engine supports a **Neurosymbolic** mode using the LogosNet architecture.

- **Architecture:** A 10-block ResNet backbone with a standard Policy head and a **Symbolic Residual Value Head**.
- **Dynamic K:** The network learns how much to trust material imbalance. At initialization ($K_{net} = 0$), $k$ is exactly $0.5$. During training, the network adjusts $k$ to prioritize material or strategic compensation.
- **Inference:** Uses **tch-rs** (LibTorch) for high-performance inference. The forward pass accepts both the board features and the raw material scalar.

### Final Layer Details
The value head splits into two paths to predict the final evaluation:

1.  **Deep Value Logit ($V_{net}$):** Represents the network's intuition about the position's value in logit space.
2.  **Confidence Logit ($K_{net}$):** Represents the network's confidence in the material imbalance.

These are combined using the **Dynamic Symbolic Residual Formula**:

$$k = \frac{\text{Softplus}(K_{net})}{2 \ln 2}$$

$$V_{final} = \tanh(V_{net} + k \cdot \Delta M)$$

Where $\Delta M$ is the material imbalance. This architecture allows the network to learn a residual correction to the material advantage, effectively "pricing" the material in the current strategic context.

> **Note:** Neural network support is optional. Compile with `cargo build --features neural` to enable it. You must have a compatible LibTorch installed or let `tch-rs` download one.

## Training Philosophy
Caissawary is designed for high learning efficiency, making it feasible to train without nation-state-level resources.

- **Supervised Pre-training**: The recommended approach is to begin with supervised learning. The ResNet policy and the fast evaluation function should be pre-trained on a large corpus of high-quality human games. This bootstraps the engine with a strong foundation of strategic and positional knowledge.

- **Efficient Reinforcement Learning**: During subsequent self-play (RL), the engine's learning is accelerated. The built-in tactical search (Tiers 1 and 2) acts as a powerful "inductive bias," preventing the engine from making simple tactical blunders. This provides a cleaner, more focused training signal to the neural networks, allowing them to learn high-level strategy far more effectively than a "blank slate" MCTS architecture.

## Configuration
The node budgets for the tactical searches and other key parameters are designed to be configurable.

```rust
pub struct CaissawaryConfig {
    pub max_iterations: u32,
    pub time_limit: Duration,
    pub exploration_constant: f64,
    
    // Node budget for the parallel mate search at each node
    pub mate_search_nodes: u32,
    
    // Node budget for the quiescence search at each leaf
    pub quiescence_nodes: u32,
}
```

## Technical Stack
- **Core Logic**: Rust, for its performance, memory safety, and concurrency.
- **Parallelism**: **Rayon** for data parallelism in the mate search portfolio.
- **Neural Networks**: **PyTorch** (in Python) for training; **tch-rs** (LibTorch) for Rust inference.
- **Board Representation**: Bitboards, for highly efficient move generation and position manipulation.

## Building and Running

### Prerequisites
First, ensure you have the Rust toolchain installed.

```bash
# Install Rust and Cargo
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
```

For the neural network components (optional), you will also need Python and PyTorch.

```bash
# Install Python dependencies
pip install torch numpy python-chess
```

### Build
Clone the repository and build the optimized release binary:

```bash
git clone https://github.com/aaholmes/caissawary.git
cd caissawary

# Standard Build (Tactical MCTS only)
cargo build --release

# Hybrid Build (With Neural Network support)
# Requires LibTorch. Automatic download may happen.
cargo build --release --features neural
```

### Usage
The primary binary is a UCI-compliant engine, suitable for use in any standard chess GUI like Arena, Cute Chess, or BanksiaGUI.

```bash
# Run the engine in UCI mode
./target/release/kingfisher
```
(Type `uci` to verify connection)

### Self-Play Data Generation
To generate training data for the neural network, use the `self_play` binary. This runs parallel games where the engine plays against itself.

```bash
# Generate 100 games with 800 simulations per move, saving to 'data/'
cargo run --release --bin self_play -- 100 800 data
```

## Testing and Benchmarking
The project includes a comprehensive suite of tests and benchmarks to validate functionality and performance. For detailed documentation, see [TESTING.md](TESTING.md).

```bash
# Run the full test suite (Unit, Integration, Property, Regression)
./scripts/test.sh

# Run standard cargo tests
cargo test

# Run perft tests (Move Generation Correctness)
cargo test --test perft_tests
```

## Visualization & Debugging
Caissawary includes a powerful **MCTS Inspector** tool to visualize the search tree and debug its state-dependent logic. This tool generates Graphviz DOT files that color-code nodes based on their origin (Tier 1, 2, or 3).

### Using the MCTS Inspector
Run the inspector on any FEN position to generate a search tree visualization:

```bash
# Analyze a position (defaults to depth 4, 500 iterations)
cargo run --release --bin mcts_inspector -- "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1"

# Customize depth and iteration count
cargo run --release --bin mcts_inspector -- "6k1/5ppp/8/8/8/8/8/4R1K1 w - - 0 1" --depth 6 --iterations 1000 --output mate_search.dot
```

### Rendering the Output
The tool produces a `.dot` file. You can render this to an image using Graphviz:

```bash
# Render to PNG
dot -Tpng mcts_tree.dot -o tree.png

# Render to interactive SVG
dot -Tsvg mcts_tree.dot -o tree.svg
```

### Interpreting the Tree
Nodes are color-coded to reveal how the engine solved or evaluated them:
- ** Red (Tier 1 Gate):** Solved immediately by "Safety Gates" (Mate Search or KOTH logic) without expansion.
- ** Gold (Tier 2 Graft):** A tactical move found by Quiescence Search and "grafted" into the tree.
- ** Blue (Tier 3 Neural):** A standard node evaluated by the neural network (or Pesto in classical mode).
- ** Grey (Shadow Prior):** A tactical move that was considered but refuted/pruned by the engine.

### Stream of Consciousness Logger
For real-time insight into the engine's "thought process," use the **Stream of Consciousness Logger**. This tool narrates the search as it happens, explaining why specific moves are being prioritized.

#### Using the Verbose Search
Run the `verbose_search` binary on any position:

```bash
# Narrate the search for a specific position with verbose output
cargo run --release --bin verbose_search -- "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1" --verbosity verbose
```

For more details on verbosity levels and configuration, see [STREAM_OF_CONSCIOUSNESS_LOGGER.md](STREAM_OF_CONSCIOUSNESS_LOGGER.md).

## Binary Targets
The crate is organized to produce several distinct binaries for different tasks:

- **caissawary**: The main UCI chess engine.
- **benchmark**: A suite for performance testing, measuring nodes-per-second and puzzle-solving speed.
- **mcts_inspector**: A tool for visualizing and debugging the MCTS search tree.
- **verbose_search**: A real-time search narration tool with customizable verbosity.
- **self_play**: A high-throughput data generation tool that plays games against itself to create training datasets for the neural network.

## References
The architecture of Caissawary is inspired by decades of research in computer chess and artificial intelligence. Key influences include:

- Silver, D. et al. (2017). "Mastering Chess and Shogi by Self-Play with a General Reinforcement Learning Algorithm"
- Campbell, M. et al. (2002). "Deep Blue"
- The Stockfish Engine and the NNUE architecture.

## License
This project is licensed under the terms of the MIT License. Please see the LICENSE file for details.
]]>
</content>
</file>

<file path="results/ablation_results.json" tokens="460" focus="false" inclusion="skeleton" relevance="3.3" reason="Medium relevance (3.28), skeletonized">
<content>
<![CDATA[
[
  {
    "config_name": "baseline_mcts",
    "timestamp": "2026-01-05T00:50:40.556189439+00:00",
    "search_metrics": [
      {
        "total_iterations": 800,
        "nodes_expanded": 146,
        "search_time": {
          "secs": 0,
          "nanos": 477414
        },
        "tier1_activations": 0,
        "mates_found_by_gate": 0,
        "koth_wins_detected": 0,
        "nn_calls_saved_tier1": 784,
        "tier2_grafts": 0,
        "positions_with_tactical_moves": 0,
        "avg_graft_depth": 0.0,
        "nn_calls_saved_tier2": 0,
        "nn_evaluations": 0,
        "nn_policy_queries": 0,
        "avg_nn_inference_time_us": 0.0,
        "best_move_visits": 0,
        "second_best_visits": 0,
        "root_value": 0.0,
        "value_confidence": 0.0
      },
      {
        "total_iterations": 800,
        "nodes_expanded": 9061,
        "search_time": {
          "secs": 0,
          "nanos": 6933027
        },
        "tier1_activations": 0,
        "mates_found_by_gate": 0,
        "koth_wins_detected": 0,
        "nn_calls_saved_tier1": 0,
        "tier2_grafts": 0,
        "positions_with_tactical_moves": 0,
        "avg_graft_depth": 0.0,
        "nn_calls_saved_tier2": 0,
        "nn_evaluations": 0,
        "nn_policy_queries": 0,
        "avg_nn_inference_time_us": 0.0,
        "best_move_visits": 0,
        "second_best_visits": 0,
        "root_value": 0.0,
        "value_confidence": 0.0]]>
</content>
</file>

<file path="Cargo.toml" tokens="328" focus="false" inclusion="skeleton" relevance="3.2" reason="Medium relevance (3.17), skeletonized">
<content>
<![CDATA[
[package]
name = "kingfisher"
version = "0.1.0"
edition = "2021"

[lib]
name = "kingfisher"
path = "src/lib.rs"

[[bin]]
name = "kingfisher"
path = "src/main.rs"

[[bin]]
name = "benchmark"
path = "src/bin/benchmark.rs"

[[bin]]
name = "quick_test"
path = "src/bin/quick_test.rs"

[[bin]]
name = "texel_tune"
path = "src/bin/texel_tune.rs"

[[bin]]
name = "generate_training_data"
path = "src/bin/generate_training_data.rs"

[[bin]]
name = "strength_test"
path = "src/bin/strength_test.rs"

[[bin]]
name = "self_play"
path = "src/bin/self_play.rs"

[dependencies]
rand = "0.8.5" # Added for MCTS random playouts
lazy_static = "1.5.0"
shakmaty = "0.25" # Dependency for shakmaty-syzygy
shakmaty-syzygy = "0.15.0"
rayon = "1.7"
crossbeam-channel = "0.5"
tch = { git = "https://github.com/LaurentMazare/tch-rs", branch = "main", optional = true }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
chrono = "0.4"

[features]]]>
</content>
</file>

<file path="Dockerfile" tokens="156" focus="false" inclusion="skeleton" relevance="3.0" reason="Medium relevance (3.03), skeletonized">
<content>
<![CDATA[
FROM rust:1.75-bookworm

# Install Python for training
RUN apt-get update && apt-get install -y \
    python3 python3-pip python3-venv \
    graphviz \
    && rm -rf /var/lib/apt/lists/*

# Create virtual environment
RUN python3 -m venv /opt/venv
ENV PATH="/opt/venv/bin:$PATH"

# Install Python dependencies
COPY requirements.txt /app/
RUN pip install --no-cache-dir -r /app/requirements.txt

# Copy Rust project
WORKDIR /app
COPY . .

# Build Rust project
RUN cargo build --release

# Default command: run tournament
CMD ["./target/release/elo_tournament", "--games", "100"]]]>
</content>
</file>

<file path=".cargo/config.toml" tokens="17" focus="false" inclusion="skeleton" relevance="2.9" reason="Medium relevance (2.94), skeletonized">
<content>
<![CDATA[
[build]
rustflags = ["-C", "target-cpu=native"]]]>
</content>
</file>

<file path="src/neural_net.rs" tokens="379" focus="false" inclusion="skeleton" relevance="2.8" reason="Medium relevance (2.82), skeletonized">
<content>
<![CDATA[
//! Neural Network Policy Implementation
//!
//! This module handles loading models and performing inference to guide the MCTS search.
//!
//! It provides two implementations:
//! - Real implementation using `tch-rs` (enabled via "neural" feature)
//! - Stub implementation (default) to allow compilation without LibTorch

// ==========================================
// 1. Real Implementation (LibTorch)
// ==========================================
#[cfg(feature = "neural")]
mod real {
    use crate::board::Board;
    use crate::move_types::Move;
    use crate::piece_types::{PAWN, KNIGHT, BISHOP, ROOK, QUEEN, KING, WHITE, BLACK};
    use crate::tensor::move_to_index;
    use tch::{CModule, Tensor, Device, Kind};
    use std::path::Path;

    pub struct NeuralNetPolicy {
        model: Option<CModule>,
        device: Device,
    }

    impl NeuralNetPolicy {
        pub fn new() -> Self {
            NeuralNetPolicy {
                model: None,
                device: if tch::Cuda::is_available() { Device::Cuda(0) } else { Device::Cpu },
            }
        }

        pub fn load(&mut self, path: &str) -> Result<(), String> {
            if !Path::new(path).exists() {
                return Err(format!("Model file not found: {}", path));
            }

            match CModule::load_on_device(path, self.device) {
                Ok(m) => {
                    self.model = Some(m);
                    println!(" Neural network loaded successfully on {:?}", self.device);
                    Ok(())
                }
                Err(e) => Err(format!("Failed to load model: {}", e)),
            }
        }

        pub fn new_demo_enabled() -> Self {
            let mut nn = Self::new();]]>
</content>
</file>

<file path="src/tuning/data_loader.rs" tokens="437" focus="false" inclusion="skeleton" relevance="2.8" reason="Medium relevance (2.78), skeletonized">
<content>
<![CDATA[
//! Data loading utilities for Texel tuning

use super::*;
use std::fs::File;
use std::io::{BufRead, BufReader, Write};
use std::path::Path;

pub struct DataLoader;

impl DataLoader {
    /// Load positions from a simple format: FEN,result,description
    pub fn load_from_csv<P: AsRef<Path>>(path: P) -> Result<Vec<TexelPosition>, Box<dyn std::error::Error>> {
        let file = File::open(path)?;
        let reader = BufReader::new(file);
        let mut positions = Vec::new();
        
        for (line_num, line) in reader.lines().enumerate() {
            let line = line?;
            if line.trim().is_empty() || line.starts_with('#') {
                continue; // Skip empty lines and comments
            }
            
            let parts: Vec<&str> = line.split(',').collect();
            if parts.len() >= 2 {
                let fen = parts[0].trim();
                let result_str = parts[1].trim();
                let description = if parts.len() > 2 {
                    parts[2].trim().to_string()
                } else {
                    format!("Position {}", line_num + 1)
                };
                
                // Parse result (can be numeric 0.0/0.5/1.0 or PGN format 1-0/1/2-1/2/0-1)
                let result = if let Ok(numeric_result) = result_str.parse::<f64>() {
                    numeric_result
                } else {
                    match result_str {
                        "1-0" => 1.0,
                        "0-1" => 0.0,
                        "1/2-1/2" => 0.5,
                        _ => {
                            eprintln!("Warning: Unknown result format '{}' on line {}", result_str, line_num + 1);
                            continue;
                        }
                    }
                };
                
                if let Some(position) = TexelPosition::new(fen, result, description) {
                    positions.push(position);
                } else {]]>
</content>
</file>

<file path="src/tuning/mod.rs" tokens="428" focus="false" inclusion="skeleton" relevance="2.7" reason="Medium relevance (2.74), skeletonized">
<content>
<![CDATA[
use crate::board::Board;

pub mod texel;
pub mod data_loader;

#[derive(Debug, Clone)]
pub struct TexelPosition {
    pub board: Board,
    pub game_result: f64, // 0.0 = loss, 0.5 = draw, 1.0 = win (from White's perspective)
    pub game_phase: f64,  // 0.0 = endgame, 1.0 = opening
    pub description: String,
}

impl TexelPosition {
    pub fn new(fen: &str, result: f64, description: String) -> Option<Self> {
        let board = Board::new_from_fen(fen);
        
        // Calculate game phase based on material
        let game_phase = calculate_game_phase(&board);
        
        Some(TexelPosition {
            board,
            game_result: result,
            game_phase,
            description,
        })
    }
    
    pub fn from_pgn_result(fen: &str, pgn_result: &str, description: String) -> Option<Self> {
        let result = match pgn_result {
            "1-0" => 1.0,   // White wins
            "0-1" => 0.0,   // Black wins  
            "1/2-1/2" => 0.5, // Draw
            _ => return None, // Unknown result
        };
        
        Self::new(fen, result, description)
    }
}

/// Calculate game phase based on piece values (0.0 = endgame, 1.0 = opening)
fn calculate_game_phase(board: &Board) -> f64 {
    use crate::piece_types::*;
    
    let mut total_material = 0;
    
    // Count material for both sides
    for color in [WHITE, BLACK] {
        total_material += board.get_piece_bitboard(color, QUEEN).count_ones() * 9;
        total_material += board.get_piece_bitboard(color, ROOK).count_ones() * 5;]]>
</content>
</file>

<file path="src/tuning/texel.rs" tokens="377" focus="false" inclusion="skeleton" relevance="2.7" reason="Medium relevance (2.70), skeletonized">
<content>
<![CDATA[
//! Texel tuning implementation for optimizing evaluation parameters

use super::*;
use crate::eval::{PestoEval, EvalWeights};
use crate::move_generation::MoveGen;
use std::f64;

pub struct TexelTuner {
    positions: Vec<TexelPosition>,
    current_weights: EvalWeights,
    best_weights: EvalWeights,
    learning_rate: f64,
    k_factor: f64, // Scaling factor for sigmoid function
    best_error: f64,
}

impl TexelTuner {
    pub fn new(positions: Vec<TexelPosition>, initial_weights: EvalWeights) -> Self {
        let best_error = f64::INFINITY;
        
        TexelTuner {
            positions,
            current_weights: initial_weights.clone(),
            best_weights: initial_weights,
            learning_rate: 0.1,
            k_factor: 400.0, // Standard chess evaluation scaling
            best_error,
        }
    }
    
    pub fn set_learning_rate(&mut self, lr: f64) {
        self.learning_rate = lr;
    }
    
    pub fn set_k_factor(&mut self, k: f64) {
        self.k_factor = k;
    }
    
    /// Calculate evaluation error using mean squared error
    pub fn calculate_error(&self, weights: &EvalWeights, move_gen: &MoveGen) -> f64 {
        let mut total_error = 0.0;
        let evaluator = PestoEval::with_weights(weights.clone());
        
        for position in &self.positions {
            // Get evaluation in centipawns
            let eval_cp = evaluator.eval(&position.board, move_gen);
            
            // Convert to win probability using sigmoid: 1 / (1 + exp(-eval/k))
            let eval_prob = sigmoid(eval_cp as f64, self.k_factor);
            ]]>
</content>
</file>

<file path="src/benchmarks/strength_testing.rs" tokens="392" focus="false" inclusion="skeleton" relevance="2.7" reason="Medium relevance (2.67), skeletonized">
<content>
<![CDATA[
//! Comprehensive Strength Testing and Comparisons
//!
//! This module provides extensive benchmarking to test the strength improvements
//! from our mate-search-first MCTS approach and neural network policy guidance.

use crate::board::Board;
use crate::eval::PestoEval;
use crate::move_generation::MoveGen;
use crate::move_types::Move;
// use crate::search::alpha_beta::AlphaBeta;
// use crate::mcts::mcts_search;
use crate::mcts::neural_mcts::neural_mcts_search;
use crate::neural_net::NeuralNetPolicy;
use std::collections::HashMap;
use std::time::{Duration, Instant};
use std::fmt;

/// Test suite configuration
#[derive(Debug, Clone)]
pub struct StrengthTestConfig {
    /// Time limit per position (milliseconds)
    pub time_limit_ms: u64,
    /// MCTS iterations limit
    pub mcts_iterations: u32,
    /// Alpha-beta search depth
    pub ab_depth: i32,
    /// Mate search depth for MCTS
    pub mate_search_depth: i32,
    /// Path to neural network model (optional)
    pub neural_model_path: Option<String>,
}

impl Default for StrengthTestConfig {
    fn default() -> Self {
        StrengthTestConfig {
            time_limit_ms: 1000,  // 1 second per position
            mcts_iterations: 500,
            ab_depth: 6,
            mate_search_depth: 3,
            neural_model_path: Some("python/models/chess_model.pth".to_string()),
        }
    }
}

/// Engine variant for testing
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum EngineVariant {
    AlphaBeta,           // Pure alpha-beta search
    MctsClassical,       // MCTS with classical evaluation
    MctsMatePriority,    // MCTS with mate-search-first]]>
</content>
</file>

<file path="src/benchmarks/elo_tournament.rs" tokens="480" focus="false" inclusion="skeleton" relevance="2.6" reason="Medium relevance (2.63), skeletonized">
<content>
<![CDATA[
//! Elo Tournament Framework for Statistical Validation
//! 
//! Runs statistically significant head-to-head matches between engine variants
//! to produce confidence intervals on Elo differences.

use crate::board::Board;
use crate::eval::PestoEval;
use crate::move_generation::MoveGen;
use crate::move_types::Move;
use crate::mcts::tactical_mcts::{tactical_mcts_search, TacticalMctsConfig};
use crate::search::iterative_deepening::iterative_deepening_ab_search;
use crate::transposition::TranspositionTable;
use crate::mcts::inference_server::InferenceServer;
use crate::boardstack::BoardStack;
use std::sync::Arc;
use std::time::Duration;
use std::collections::HashMap;
use rand::prelude::*;
use rand::rngs::StdRng;

/// Engine variant for tournament play
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum TournamentEngine {
    /// Pure alpha-beta search (baseline)
    AlphaBeta { depth: i32 },
    /// MCTS without mate search or tactical priority (ablation)
    PureMcts { iterations: u32 },
    /// MCTS with only Tier 1 (mate search gate)
    MctsTier1Only { iterations: u32, mate_depth: i32 },
    /// MCTS with Tier 1 + Tier 2 (tactical grafting)
    MctsTier1And2 { iterations: u32, mate_depth: i32 },
    /// Full Tactical-First MCTS (all 3 tiers)
    TacticalMctsFull { iterations: u32, mate_depth: i32 },
}

impl TournamentEngine {
    pub fn name(&self) -> &'static str {
        match self {
            TournamentEngine::AlphaBeta { .. } => "AlphaBeta",
            TournamentEngine::PureMcts { .. } => "PureMCTS",
            TournamentEngine::MctsTier1Only { .. } => "MCTS+T1",
            TournamentEngine::MctsTier1And2 { .. } => "MCTS+T1+T2",
            TournamentEngine::TacticalMctsFull { .. } => "TacticalMCTS",
        }
    }
}

/// Result of a single game
#[derive(Debug, Clone, Copy)]
pub enum GameResult {]]>
</content>
</file>

<file path="src/benchmarks/mod.rs" tokens="377" focus="false" inclusion="skeleton" relevance="2.6" reason="Medium relevance (2.60), skeletonized">
<content>
<![CDATA[
use crate::boardstack::BoardStack;
use crate::move_types::Move;
use crate::move_generation::MoveGen;
use crate::eval::PestoEval;
use crate::agent::{Agent, SimpleAgent, HumanlikeAgent};
use std::time::{Duration, Instant};

pub mod tactical_suite;
pub mod performance;
pub mod strength_testing;
pub mod elo_estimation;
pub mod elo_tournament;

#[derive(Debug, Clone)]
pub struct BenchmarkResult {
    pub position_name: String,
    pub engine_name: String,
    pub time_taken: Duration,
    pub nodes_searched: u64,
    pub best_move: Option<Move>,
    pub found_mate: bool,
    pub mate_depth: Option<u8>,
}

#[derive(Debug)]
pub struct BenchmarkSummary {
    pub total_positions: usize,
    pub positions_solved: usize,
    pub average_time: Duration,
    pub total_nodes: u64,
    pub mate_accuracy: f64, // Percentage of mates found
}

impl BenchmarkSummary {
    pub fn from_results(results: &[BenchmarkResult]) -> Self {
        let total_positions = results.len();
        let positions_solved = results.iter().filter(|r| r.found_mate).count();
        let total_time: Duration = results.iter().map(|r| r.time_taken).sum();
        let average_time = if total_positions > 0 {
            total_time / total_positions as u32
        } else {
            Duration::from_millis(0)
        };
        let total_nodes: u64 = results.iter().map(|r| r.nodes_searched).sum();
        let mate_accuracy = if total_positions > 0 {
            (positions_solved as f64 / total_positions as f64) * 100.0
        } else {
            0.0
        };
]]>
</content>
</file>

<file path="src/benchmarks/performance.rs" tokens="404" focus="false" inclusion="skeleton" relevance="2.6" reason="Medium relevance (2.56), skeletonized">
<content>
<![CDATA[
//! Performance comparison framework for demonstrating mate-search-first advantage

use super::*;
use crate::benchmarks::tactical_suite::{run_tactical_benchmark, get_tactical_test_suite};
use std::time::Duration;

/// Compare performance between different engine configurations
pub struct PerformanceComparison {
    pub results: Vec<(String, BenchmarkSummary)>,
}

impl PerformanceComparison {
    pub fn new() -> Self {
        PerformanceComparison {
            results: Vec::new(),
        }
    }
    
    pub fn add_benchmark(&mut self, engine_name: String, summary: BenchmarkSummary) {
        self.results.push((engine_name, summary));
    }
    
    pub fn print_comparison(&self) {
        println!("\n PERFORMANCE COMPARISON RESULTS");
        println!("=====================================");
        
        // Print header
        println!("{:<20} | {:>8} | {:>8} | {:>10} | {:>12} | {:>10}", 
                "Engine", "Solved", "Accuracy", "Avg Time", "Total Nodes", "Speed");
        println!("{}", "-".repeat(80));
        
        // Print results
        for (engine_name, summary) in &self.results {
            let speed_metric = if summary.average_time.as_millis() > 0 {
                format!("{:.0} n/s", summary.total_nodes as f64 / summary.average_time.as_secs_f64() / summary.total_positions as f64)
            } else {
                "N/A".to_string()
            };
            
            println!("{:<20} | {:>8} | {:>7.1}% | {:>9.1}ms | {:>12} | {:>10}", 
                    engine_name,
                    summary.positions_solved,
                    summary.mate_accuracy,
                    summary.average_time.as_millis(),
                    summary.total_nodes,
                    speed_metric);
        }
        
        println!("\n KEY INSIGHTS:");
        self.analyze_results();]]>
</content>
</file>

<file path="src/benchmarks/elo_estimation.rs" tokens="387" focus="false" inclusion="skeleton" relevance="2.5" reason="Medium relevance (2.53), skeletonized">
<content>
<![CDATA[
//! Elo Rating Estimation
//!
//! Provides utilities to estimate Elo rating differences between engine variants
//! based on head-to-head match results and position analysis performance.

use std::collections::HashMap;
use crate::benchmarks::strength_testing::{EngineVariant, PositionResult};

/// Elo calculation utilities
pub struct EloCalculator {
    /// K-factor for Elo calculations
    k_factor: f64,
}

impl Default for EloCalculator {
    fn default() -> Self {
        EloCalculator {
            k_factor: 32.0, // Standard K-factor for rapid improvement detection
        }
    }
}

impl EloCalculator {
    pub fn new(k_factor: f64) -> Self {
        EloCalculator { k_factor }
    }
    
    /// Calculate expected score based on rating difference
    pub fn expected_score(rating_a: f64, rating_b: f64) -> f64 {
        1.0 / (1.0 + 10.0_f64.powf((rating_b - rating_a) / 400.0))
    }
    
    /// Estimate Elo difference from win rate
    pub fn elo_from_win_rate(win_rate: f64) -> f64 {
        if win_rate <= 0.0 {
            return -800.0; // Cap at -800 Elo
        }
        if win_rate >= 1.0 {
            return 800.0; // Cap at +800 Elo
        }
        
        -400.0 * (1.0 / win_rate - 1.0).log10()
    }
    
    /// Calculate performance-based Elo estimates
    pub fn estimate_performance_ratings(&self, results: &[PositionResult]) -> HashMap<EngineVariant, EloEstimate> {
        let mut engine_results: HashMap<EngineVariant, Vec<&PositionResult>> = HashMap::new();
        
        // Group results by engine
        for result in results {]]>
</content>
</file>

<file path="src/benchmarks/tactical_suite.rs" tokens="491" focus="false" inclusion="skeleton" relevance="2.5" reason="Medium relevance (2.50), skeletonized">
<content>
<![CDATA[
//! Tactical test suite for demonstrating mate-search-first superiority

use super::*;
use crate::move_types::Move;

#[derive(Debug, Clone)]
pub struct TacticalPosition {
    pub name: String,
    pub fen: String,
    pub mate_in: u8,
    pub best_move_uci: String,
    pub description: String,
}

impl TacticalPosition {
    pub fn get_best_move(&self) -> Option<Move> {
        Move::from_uci(&self.best_move_uci)
    }
}

/// Famous tactical positions for benchmarking
pub fn get_tactical_test_suite() -> Vec<TacticalPosition> {
    vec![
        // Mate in 1 positions
        TacticalPosition {
            name: "Back Rank Mate 1".to_string(),
            fen: "6k1/5ppp/8/8/8/8/8/4R2K w - - 0 1".to_string(),
            mate_in: 1,
            best_move_uci: "e1e8".to_string(),
            description: "Simple back rank mate".to_string(),
        },
        TacticalPosition {
            name: "Queen Mate 1".to_string(),
            fen: "k7/8/1K6/8/8/8/8/Q7 w - - 0 1".to_string(),
            mate_in: 1,
            best_move_uci: "a1a8".to_string(),
            description: "Queen delivers mate".to_string(),
        },
        TacticalPosition {
            name: "Smothered Mate Setup".to_string(),
            fen: "6k1/5ppp/8/8/8/8/8/6QK w - - 0 1".to_string(),
            mate_in: 1,
            best_move_uci: "g1g8".to_string(),
            description: "Queen mate on back rank".to_string(),
        },
        
        // Mate in 2 positions
        TacticalPosition {
            name: "Lgal's Mate Pattern".to_string(),
            fen: "r1bqk2r/pppp1ppp/2n2n2/2b5/2B1P3/3P1N2/PPP2PPP/RNBQK2R w KQkq - 0 1".to_string(),]]>
</content>
</file>

<file path="src/magic_constants.rs" tokens="736" focus="false" inclusion="skeleton" relevance="2.5" reason="Medium relevance (2.47), skeletonized">
<content>
<![CDATA[
//! Magic bitboard constants for efficient move generation.
//!
//! This module contains pre-computed constants used for magic bitboard move generation,
//! a technique that allows for fast sliding piece move generation in chess engines.
//!
//! Magic numbers found so that every blocker configuration can be mapped to a unique index.
//! Of course, since only the first blocker in each direction actually blocks, we don't need our
//! magic numbers to distinguish between every possible blocker configuration, but only the first
//! one in each direction. We can also use this fact to allow edges to also contain blockers,
//! but we save these optimizations for a later version.

/// Number of bits used in the magic bitboard hash for rooks on each square.
///
/// This array specifies how many bits of the magic hash are relevant for each square
/// when generating rook moves.
pub const R_BITS: [i32; 64] = [
  12, 11, 11, 11, 11, 11, 11, 12,
  11, 10, 10, 10, 10, 10, 10, 11,
  11, 10, 10, 10, 10, 10, 10, 11,
  11, 10, 10, 10, 10, 10, 10, 11,
  11, 10, 10, 10, 10, 10, 10, 11,
  11, 10, 10, 10, 10, 10, 10, 11,
  11, 10, 10, 10, 10, 10, 10, 11,
  12, 11, 11, 11, 11, 11, 11, 12
];

/// Number of bits used in the magic bitboard hash for bishops on each square.
///
/// This array specifies how many bits of the magic hash are relevant for each square
/// when generating bishop moves.
pub const B_BITS: [i32; 64] = [
  6, 5, 5, 5, 5, 5, 5, 6,
  5, 5, 5, 5, 5, 5, 5, 5,
  5, 5, 7, 7, 7, 7, 5, 5,
  5, 5, 7, 9, 9, 7, 5, 5,
  5, 5, 7, 9, 9, 7, 5, 5,
  5, 5, 7, 7, 7, 7, 5, 5,
  5, 5, 5, 5, 5, 5, 5, 5,
  6, 5, 5, 5, 5, 5, 5, 6
];

/// Blocker masks for rook move generation.
///
/// These masks represent the squares that can potentially block a rook's movement
/// from each square on the board, excluding edge squares.
pub const R_MASKS: [u64; 64] = [
  0x101010101017e,
  0x202020202027c,
  0x404040404047a,
  0x8080808080876,]]>
</content>
</file>

<file path="src/board_utils.rs" tokens="332" focus="false" inclusion="skeleton" relevance="2.4" reason="Medium relevance (2.44), skeletonized">
<content>
<![CDATA[
// Little Endian Rank Mapping
// Least Significant File
// ind = 8 * rank + file

/// Converts file and rank coordinates to a square index.
///
/// # Arguments
///
/// * `file` - The file (0-7, where 0 is the a-file)
/// * `rank` - The rank (0-7, where 0 is the first rank)
///
/// # Returns
///
/// The square index (0-63)
pub fn coords_to_sq_ind(file: usize, rank: usize) -> usize {
    8 * rank + file
}

/// Converts a square index to file and rank coordinates.
///
/// # Arguments
///
/// * `sq_ind` - The square index (0-63)
///
/// # Returns
///
/// A tuple (file, rank) where file and rank are 0-7
pub fn sq_ind_to_coords(sq_ind: usize) -> (usize, usize) {
    (sq_ind % 8, sq_ind / 8)
}

/// Converts a square index to a bitboard representation.
///
/// # Arguments
///
/// * `sq_ind` - The square index (0-63)
///
/// # Returns
///
/// A 64-bit integer with only the bit at the given square index set
pub fn sq_ind_to_bit(sq_ind: usize) -> u64 {
    1 << sq_ind
}

/// Converts a bitboard with a single bit set to the index of that bit.
///
/// # Arguments
///
/// * `bit` - A 64-bit integer with (hopefully) one bit set
///]]>
</content>
</file>

<file path="src/bin/tactical_cache_demo.rs" tokens="519" focus="false" inclusion="skeleton" relevance="2.4" reason="Medium relevance (2.41), skeletonized">
<content>
<![CDATA[
//! Tactical Move Cache Performance Demo
//!
//! This demo showcases the performance improvement achieved by implementing
//! position-based caching for tactical move detection in the Kingfisher Chess Engine.

use kingfisher::board::Board;
use kingfisher::move_generation::MoveGen;
use kingfisher::mcts::tactical::{identify_tactical_moves, get_tactical_cache_stats, clear_tactical_cache};
use std::time::Instant;

fn main() {
    println!(" Kingfisher Chess Engine - Tactical Move Cache Performance Demo");
    println!("=================================================================\n");

    // Test positions with varying tactical complexity
    let test_positions = vec![
        (
            "Starting Position",
            "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1"
        ),
        (
            "Complex Middlegame",
            "r1bqk2r/pppp1ppp/2n2n2/2b1p3/2B1P3/3P1N2/PPP2PPP/RNBQK2R w KQkq - 4 4"
        ),
        (
            "Tactical Position",
            "r1bqkb1r/pppp1ppp/2n2n2/1B2p3/4P3/5N2/PPPP1PPP/RNBQK2R w KQkq - 4 4"
        ),
        (
            "Sharp Sicilian",
            "rnbqkb1r/pp2pppp/3p1n2/8/3NP3/2N1B3/PPP2PPP/R2QKB1R b KQkq - 3 6"
        ),
        (
            "Endgame Position",
            "8/2k5/3p4/p2P1p2/P4P2/1K6/8/8 w - - 0 1"
        ),
    ];

    let move_gen = MoveGen::new();
    
    println!(" Phase 1: Cache Performance Analysis");
    println!("=====================================\n");
    
    benchmark_cache_performance(&test_positions, &move_gen);
    
    println!("\n Phase 2: Repeated Position Analysis");
    println!("=====================================\n");
    
    benchmark_repeated_positions(&test_positions, &move_gen);
    ]]>
</content>
</file>

<file path="src/bin/tactical_profiler.rs" tokens="378" focus="false" inclusion="skeleton" relevance="2.4" reason="Medium relevance (2.38), skeletonized">
<content>
<![CDATA[
//! Performance Profiler for Tactical-Enhanced MCTS
//!
//! This tool profiles the performance of the tactical MCTS implementation
//! to identify bottlenecks and optimization opportunities.

use kingfisher::board::Board;
use kingfisher::eval::PestoEval;
use kingfisher::move_generation::MoveGen;
use kingfisher::mcts::{tactical_mcts_search, TacticalMctsConfig};
use std::time::{Duration, Instant};

#[derive(Debug)]
pub struct ProfileResult {
    pub total_time: Duration,
    pub iterations: u32,
    pub nodes_expanded: u32,
    pub mate_searches: u32,
    pub tactical_moves_identified: u32,
    pub nn_evaluations: u32,
    pub avg_time_per_iteration: Duration,
    pub nodes_per_second: f64,
}

/// Profile the tactical MCTS on a specific position
fn profile_position(
    board: Board,
    move_gen: &MoveGen,
    pesto_eval: &PestoEval,
    config: TacticalMctsConfig,
) -> ProfileResult {
    let mut nn_policy = None;
    
    let start_time = Instant::now();
    let (_, stats, _) = tactical_mcts_search(
        board,
        move_gen,
        pesto_eval,
        &mut nn_policy,
        config,
    );
    let total_time = start_time.elapsed();
    
    let avg_time_per_iteration = if stats.iterations > 0 {
        Duration::from_nanos(total_time.as_nanos() as u64 / stats.iterations as u64)
    } else {
        Duration::from_nanos(0)
    };
    
    let nodes_per_second = if total_time.as_secs_f64() > 0.0 {
        stats.nodes_expanded as f64 / total_time.as_secs_f64()]]>
</content>
</file>

<file path="src/bin/run_experiments.rs" tokens="373" focus="false" inclusion="skeleton" relevance="2.4" reason="Medium relevance (2.35), skeletonized">
<content>
<![CDATA[
// src/bin/run_experiments.rs
//! Main experiment runner for ablation studies.
//!
//! Usage:
//!   cargo run --release --bin run_experiments -- --config ablation
//!   cargo run --release --bin run_experiments -- --config single --name full_system

use kingfisher::board::Board;
use kingfisher::eval::PestoEval;
use kingfisher::experiments::config::{
    ExperimentConfig,
    generate_ablation_configs,
    TestSuite,
};
use kingfisher::experiments::metrics::{
    AggregatedMetrics,
    ExperimentResults,
    PositionResult,
    SafetyMetrics,
    SearchMetrics,
    TierUsed,
};
use kingfisher::mcts::tactical_mcts::{tactical_mcts_search, TacticalMctsConfig};
use kingfisher::move_generation::MoveGen;
use std::fs;
use std::io::Write;
use std::time::{Duration, Instant};

fn main() {
    let args: Vec<String> = std::env::args().collect();
    
    let mode = args.iter()
        .position(|a| a == "--config")
        .and_then(|i| args.get(i + 1))
        .map(|s| s.as_str())
        .unwrap_or("ablation");
    
    match mode {
        "ablation" => run_ablation_study(),
        "single" => {
            let name = args.iter()
                .position(|a| a == "--name")
                .and_then(|i| args.get(i + 1))
                .map(|s| s.as_str())
                .unwrap_or("full_system");
            run_single_config(name);
        }
        _ => {
            println!("Usage: run_experiments --config [ablation|single] [--name config_name]");
        }]]>
</content>
</file>

<file path="src/bin/neural_integration_demo.rs" tokens="521" focus="false" inclusion="skeleton" relevance="2.3" reason="Medium relevance (2.33), skeletonized">
<content>
<![CDATA[
//! Neural Integration Demo
//! 
//! This binary demonstrates the integration of the neural network policy
//! into the tactical MCTS search. It compares:
//! 1. Pure MCTS (Baseline)
//! 2. Tactical-First MCTS (No NN)
//! 3. Neural-Enhanced MCTS (With NN)

use kingfisher::board::Board;
use kingfisher::eval::PestoEval;
use kingfisher::move_generation::MoveGen;
use kingfisher::mcts::{tactical_mcts_search, TacticalMctsConfig};
use kingfisher::mcts::inference_server::InferenceServer;
use kingfisher::neural_net::NeuralNetPolicy;
use std::sync::Arc;
use std::time::{Duration, Instant};

fn main() {
    println!(" Neural Integration Demo");
    println!("========================");
    
    // Paths
    let model_path = "models/latest.pt"; // Adjust as needed
    
    // Initialize components
    let move_gen = MoveGen::new();
    let pesto_eval = PestoEval::new();
    
    // Try to load the model
    let mut nn_policy = NeuralNetPolicy::new();
    let model_loaded = match nn_policy.load(model_path) {
        Ok(_) => {
            println!(" Model loaded successfully from {}", model_path);
            true
        },
        Err(e) => {
            println!(" Failed to load model: {}", e);
            println!("   Running in fallback mode (Tactical MCTS only)");
            false
        }
    };
    
    // Test positions
    let positions = vec![
        ("Starting Position", "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1"),
        ("Tactical Midgame", "r1bqkb1r/pppp1ppp/2n2n2/1B2p3/4P3/5N2/PPPP1PPP/RNBQK2R w KQkq - 4 4"),
        ("Sharp Position", "r3k2r/p1ppqpb1/bn2pnp1/3PN3/1p2P3/2N2Q1p/PPPBBPPP/R3K2R w KQkq - 0 1"),
    ];
    
    for (name, fen) in positions {]]>
</content>
</file>

<file path="src/bin/generate_training_data.rs" tokens="468" focus="false" inclusion="skeleton" relevance="2.3" reason="Medium relevance (2.30), skeletonized">
<content>
<![CDATA[
//! Training Data Generation Binary
//!
//! Generates training data for neural network policy by analyzing positions
//! and creating datasets suitable for PyTorch training.

use kingfisher::training::{TrainingDataGenerator, ParsedGame};
use kingfisher::move_types::Move;

fn main() {
    println!(" Kingfisher Training Data Generator");
    println!("=====================================");
    
    let mut generator = TrainingDataGenerator::new();
    generator.set_search_depth(6); // Reasonable depth for training data analysis
    
    // Generate tactical training positions
    println!("\n Generating tactical positions...");
    let tactical_positions = generator.generate_tactical_positions();
    println!(" Generated {} tactical positions", tactical_positions.len());
    
    // Create some sample games for demonstration
    println!("\n Generating sample game positions...");
    let sample_games = create_sample_games();
    let game_positions = generator.generate_from_games(&sample_games);
    println!(" Generated {} game positions", game_positions.len());
    
    // Combine all positions
    let mut all_positions = tactical_positions;
    all_positions.extend(game_positions);
    
    println!("\n Total training positions: {}", all_positions.len());
    
    // Save to CSV file for Python training pipeline
    let csv_path = "training_data.csv";
    match generator.save_to_csv(&all_positions, csv_path) {
        Ok(()) => println!(" Saved training data to: {}", csv_path),
        Err(e) => println!(" Failed to save CSV: {}", e),
    }
    
    // Test loading the data back
    println!("\n Testing data loading...");
    match TrainingDataGenerator::load_from_csv(csv_path) {
        Ok(loaded_positions) => {
            println!(" Successfully loaded {} positions", loaded_positions.len());
            
            // Show some statistics
            let white_wins = loaded_positions.iter().filter(|p| p.game_result > 0.7).count();
            let draws = loaded_positions.iter().filter(|p| (p.game_result - 0.5).abs() < 0.2).count();
            let black_wins = loaded_positions.iter().filter(|p| p.game_result < 0.3).count();
            ]]>
</content>
</file>

<file path="src/bin/benchmark.rs" tokens="460" focus="false" inclusion="skeleton" relevance="2.3" reason="Medium relevance (2.27), skeletonized">
<content>
<![CDATA[
//! Benchmark binary for demonstrating Kingfisher's mate-search-first advantage

use kingfisher::benchmarks::performance::{run_performance_comparison, mate_speed_benchmark};
use kingfisher::benchmarks::tactical_suite::run_tactical_benchmark;
use kingfisher::benchmarks::{create_simple_agent, create_humanlike_agent};
use std::env;
use std::time::Duration;

fn print_banner() {
    println!(" KINGFISHER CHESS ENGINE BENCHMARK SUITE");
    println!("===========================================");
    println!("Demonstrating Novel Mate-Search-First MCTS Approach\n");
}

fn print_usage() {
    println!("Usage: cargo run --bin benchmark [command]");
    println!("\nCommands:");
    println!("  tactical     - Run tactical position benchmark");
    println!("  comparison   - Run comprehensive engine comparison");
    println!("  speed        - Run mate-finding speed tests");
    println!("  all          - Run all benchmarks");
    println!("  help         - Show this help message");
    println!("\nExamples:");
    println!("  cargo run --release --bin benchmark tactical");
    println!("  cargo run --release --bin benchmark comparison");
    println!("  cargo run --release --bin benchmark all");
}

fn run_tactical_benchmark_cmd() {
    println!(" TACTICAL POSITION BENCHMARK");
    println!("==============================\n");
    
    let time_limit = Duration::from_millis(2000);
    
    // Run benchmarks
    let mut simple_agent = create_simple_agent();
    let mut humanlike_agent = create_humanlike_agent();

    let ab_results = run_tactical_benchmark(&mut simple_agent, "Traditional AlphaBeta", time_limit);
    let mcts_results = run_tactical_benchmark(&mut humanlike_agent, "MateSearchFirst MCTS", time_limit);
    
    // Print summaries
    use kingfisher::benchmarks::BenchmarkSummary;
    let ab_summary = BenchmarkSummary::from_results(&ab_results);
    let mcts_summary = BenchmarkSummary::from_results(&mcts_results);
    
    ab_summary.print_summary("Traditional AlphaBeta");
    mcts_summary.print_summary("MateSearchFirst MCTS");
    
    // Quick comparison]]>
</content>
</file>

<file path="src/bin/mcts_inspector.rs" tokens="451" focus="false" inclusion="skeleton" relevance="2.2" reason="Medium relevance (2.25), skeletonized">
<content>
<![CDATA[
//! MCTS Tree Inspector - Visualize search trees
//!
//! Usage: mcts_inspector <fen> [--depth <n>] [--min-visits <n>] [--output <file.dot>]

use std::env;
use std::fs::File;
use std::io::Write;
use std::time::Duration;
use std::sync::Arc;

use kingfisher::board::Board;
use kingfisher::eval::PestoEval;
use kingfisher::mcts::tactical_mcts::{tactical_mcts_search, TacticalMctsConfig};
use kingfisher::mcts::inference_server::InferenceServer;
use kingfisher::move_generation::MoveGen;

fn main() {
    let args: Vec<String> = env::args().collect();
    
    if args.len() < 2 {
        print_usage();
        return;
    }
    
    let fen = &args[1];
    let depth_limit = parse_arg(&args, "--depth").unwrap_or(4);
    let min_visits = parse_arg(&args, "--min-visits").unwrap_or(1);
    let output_file = parse_string_arg(&args, "--output")
        .unwrap_or_else(|| "mcts_tree.dot".to_string());
    let iterations = parse_arg(&args, "--iterations").unwrap_or(500);
    let mate_depth = parse_arg(&args, "--mate-depth").unwrap_or(3);
    
    println!(" MCTS Inspector");
    println!("==================");
    println!("FEN: {}", fen);
    println!("Depth limit: {}", depth_limit);
    println!("Min visits: {}", min_visits);
    println!("Iterations: {}", iterations);
    println!("Mate search depth: {}", mate_depth);
    println!();
    
    // Initialize components
    let board = Board::new_from_fen(fen);
    let move_gen = MoveGen::new();
    let pesto = PestoEval::new();
    
    let config = TacticalMctsConfig {
        max_iterations: iterations,
        time_limit: Duration::from_secs(60), // Generous limit for inspection
        mate_search_depth: mate_depth as i32,]]>
</content>
</file>

<file path="src/bin/quick_test.rs" tokens="414" focus="false" inclusion="skeleton" relevance="2.2" reason="Medium relevance (2.22), skeletonized">
<content>
<![CDATA[
//! Quick test to verify our tactical benchmark works

use kingfisher::benchmarks::tactical_suite::get_tactical_test_suite;
use kingfisher::benchmarks::create_simple_agent;
use kingfisher::boardstack::BoardStack;
use kingfisher::agent::Agent;
use std::time::Instant;

fn main() {
    println!(" Quick Tactical Benchmark Test");
    println!("================================");
    
    // Load test positions
    let positions = get_tactical_test_suite();
    println!(" Loaded {} tactical positions", positions.len());
    
    // Test first position only
    let first_position = &positions[0];
    println!("\n Testing position: {}", first_position.name);
    println!("   FEN: {}", first_position.fen);
    println!("   Expected: {} (mate in {})", first_position.best_move_uci, first_position.mate_in);
    
    // Create agent
    let mut agent = create_simple_agent();
    println!(" Created AlphaBeta agent");
    
    // Test position
    println!("\n Running quick test (500ms limit)...");
    let start = Instant::now();
    
    let mut board = BoardStack::new_from_fen(&first_position.fen);
    let move_found = agent.get_move(&mut board);
    
    let elapsed = start.elapsed();
    println!("  Completed in {:.1}ms", elapsed.as_millis());
    println!(" Move found: {:?}", move_found);
    
    // Check if correct
    let expected = first_position.get_best_move();
    println!(" Expected: {:?}", expected);
    
    if let Some(exp) = expected {
        if move_found == exp {
            println!(" CORRECT! Found the right move");
        } else {
            println!(" INCORRECT - but that's okay for this test");
        }
    }
    
    println!("\n Quick test completed successfully!");]]>
</content>
</file>

<file path="src/bin/verbose_search.rs" tokens="419" focus="false" inclusion="skeleton" relevance="2.2" reason="Medium relevance (2.20), skeletonized">
<content>
<![CDATA[
//! Verbose Search - MCTS with Stream of Consciousness output
//!
//! Usage: verbose_search <fen> [--verbosity <level>] [--iterations <n>]

use std::env;
use std::sync::Arc;
use std::time::Duration;

use kingfisher::board::Board;
use kingfisher::eval::PestoEval;
use kingfisher::mcts::tactical_mcts::{tactical_mcts_search, TacticalMctsConfig};
use kingfisher::mcts::inference_server::InferenceServer;
use kingfisher::mcts::search_logger::{SearchLogger, Verbosity};
use kingfisher::move_generation::MoveGen;

fn main() {
    let args: Vec<String> = env::args().collect();
    
    if args.len() < 2 {
        print_usage();
        return;
    }
    
    let fen = &args[1];
    let verbosity = parse_verbosity(&args).unwrap_or(Verbosity::Normal);
    let iterations = parse_arg(&args, "--iterations").unwrap_or(200);
    let no_emoji = args.iter().any(|a| a == "--no-emoji");
    
    println!(" Caissawary Verbose MCTS Search");
    println!("======================");
    println!("FEN: {}", fen);
    println!("Verbosity: {:?}", verbosity);
    println!("Iterations: {}", iterations);
    println!();
    
    // Create logger
    let logger = SearchLogger::new(verbosity)
        .with_emoji(!no_emoji);
    
    // Initialize components
    let board = Board::new_from_fen(fen);
    let move_gen = MoveGen::new();
    let pesto = PestoEval::new();
    let server = InferenceServer::new_mock();
    
    let config = TacticalMctsConfig {
        max_iterations: iterations,
        time_limit: Duration::from_secs(60),
        mate_search_depth: 5,
        exploration_constant: 1.414,]]>
</content>
</file>

<file path="src/bin/verify_features.rs" tokens="646" focus="false" inclusion="skeleton" relevance="2.2" reason="Medium relevance (2.17), skeletonized">
<content>
<![CDATA[
//! Verify Neural Network Input Feature Construction
//!
//! This utility helps debug the board-to-tensor conversion by visualizing
//! the active bits in each plane of the input tensor.

use kingfisher::board::Board;
use kingfisher::neural_net::NeuralNetPolicy;
use kingfisher::piece_types::{PAWN, KNIGHT, BISHOP, ROOK, QUEEN, KING};
// use tch::{Tensor, Device}; // NeuralNetPolicy handles tensor creation internals

fn main() {
    println!(" Neural Network Feature Visualizer");
    println!("===================================");

    // Setup a position with diverse features:
    // - White castling rights (K, Q)
    // - Black castling rights (k)
    // - En passant target
    // - Pieces of all types
    // FEN: r3k2r/p1ppqpb1/bn2pnp1/3PN3/1p2P3/2N2Q1p/PPPBBPPP/R3K2R w KQkq - 0 1 (KiwiPete)
    let fen = "r3k2r/p1ppqpb1/bn2pnp1/3PN3/1p2P3/2N2Q1p/PPPBBPPP/R3K2R w KQkq - 0 1";
    println!("Position: {}", fen);
    let board = Board::new_from_fen(fen);
    
    // We need to access the tensor conversion logic.
    // Since board_to_tensor is an internal helper of NeuralNetPolicy (or part of its impl),
    // and might use `tch`, we rely on NeuralNetPolicy to expose it or we test via a public method if available.
    // `NeuralNetPolicy` has `board_to_tensor` but it returns a `Tensor`.
    // We need to convert that `Tensor` back to CPU data to visualize.
    
    #[cfg(feature = "neural")]
    {
        use tch::{Device, Kind};
        let nn = NeuralNetPolicy::new(); // Don't need to load weights, just need structure
        let tensor = nn.board_to_tensor(&board);
        
        println!("Tensor Shape: {:?}", tensor.size());
        
        // Extract data
        // Shape: [17, 8, 8]
        let mut flat_data = vec![0.0f32; 17 * 8 * 8];
        tensor.view([-1]).to_device(Device::Cpu).copy_data(&mut flat_data, 17 * 8 * 8);
        
        let plane_names = [
            "Us Pawn", "Us Knight", "Us Bishop", "Us Rook", "Us Queen", "Us King",
            "Them Pawn", "Them Knight", "Them Bishop", "Them Rook", "Them Queen", "Them King",
            "En Passant", 
            "Us King-side Castle", "Us Queen-side Castle", 
            "Them King-side Castle", "Them Queen-side Castle"
        ];]]>
</content>
</file>

<file path="src/bin/texel_tune.rs" tokens="416" focus="false" inclusion="skeleton" relevance="2.2" reason="Medium relevance (2.15), skeletonized">
<content>
<![CDATA[
//! Texel tuning binary for optimizing evaluation parameters

use kingfisher::tuning::texel::{TexelTuner, create_test_dataset};
use kingfisher::tuning::data_loader::DataLoader;
use kingfisher::eval_constants::EvalWeights;
use kingfisher::move_generation::MoveGen;

fn main() {
    println!(" Kingfisher Texel Tuning");
    println!("=========================");
    
    // Initialize move generation
    let move_gen = MoveGen::new();
    
    // Load or generate training positions
    let positions = if std::env::args().len() > 1 {
        let data_file = std::env::args().nth(1).unwrap();
        println!(" Loading positions from: {}", data_file);
        
        if data_file.ends_with(".csv") {
            DataLoader::load_from_csv(&data_file)
                .unwrap_or_else(|e| {
                    eprintln!(" Error loading CSV: {}", e);
                    std::process::exit(1);
                })
        } else if data_file.ends_with(".epd") {
            DataLoader::load_from_epd(&data_file)
                .unwrap_or_else(|e| {
                    eprintln!(" Error loading EPD: {}", e);
                    std::process::exit(1);
                })
        } else {
            eprintln!(" Unsupported file format. Use .csv or .epd");
            std::process::exit(1);
        }
    } else {
        println!(" Generating synthetic test dataset...");
        create_test_dataset()
    };
    
    println!(" Loaded {} training positions", positions.len());
    
    // Initialize tuner with default weights
    let initial_weights = EvalWeights::default();
    let mut tuner = TexelTuner::new(positions, initial_weights);
    
    // Set tuning parameters
    tuner.set_learning_rate(0.1);
    tuner.set_k_factor(400.0); // Standard chess evaluation scaling
    ]]>
</content>
</file>

<file path="src/bin/elo_tournament.rs" tokens="399" focus="false" inclusion="skeleton" relevance="2.1" reason="Medium relevance (2.13), skeletonized">
<content>
<![CDATA[
//! Elo Tournament Runner for Paper Experiments
//!
//! Usage: elo_tournament [--games N] [--seed S] [--output FILE]

use kingfisher::benchmarks::elo_tournament::{
    EloTournament,
    TournamentConfig,
    TournamentEngine,
};
use std::env;
use std::fs::File;
use std::io::Write;

fn main() {
    println!(" Caissawary Elo Tournament");
    println!("============================");
    println!();
    
    let args: Vec<String> = env::args().collect();
    let games = parse_arg(&args, "--games").unwrap_or(100);
    let seed = parse_arg(&args, "--seed").unwrap_or(42) as u64;
    let output_csv = parse_string_arg(&args, "--output")
        .unwrap_or_else(|| "tournament_results.csv".to_string());
    let output_latex = output_csv.replace(".csv", ".tex");
    
    println!("Configuration:");
    println!("  Games per pair: {}", games);
    println!("  Random seed: {}", seed);
    println!("  Output: {}", output_csv);
    println!();
    
    let config = TournamentConfig {
        games_per_pair: games,
        seed,
        ..Default::default()
    };
    
    let mut tournament = EloTournament::new(config);
    
    // Define engine variants for ablation study
    let engines = vec![
        TournamentEngine::AlphaBeta { depth: 6 },
        TournamentEngine::PureMcts { iterations: 800 },
        TournamentEngine::MctsTier1Only { iterations: 800, mate_depth: 5 },
        TournamentEngine::MctsTier1And2 { iterations: 800, mate_depth: 5 },
        TournamentEngine::TacticalMctsFull { iterations: 800, mate_depth: 5 },
    ];
    
    let results = tournament.run_full_tournament(&engines);
    ]]>
</content>
</file>

<file path="src/bin/see_integration_demo.rs" tokens="547" focus="false" inclusion="skeleton" relevance="2.1" reason="Medium relevance (2.11), skeletonized">
<content>
<![CDATA[
//! SEE Integration Demo
//!
//! This demo showcases the impact of proper Static Exchange Evaluation (SEE) integration
//! on tactical move filtering in the Kingfisher Chess Engine.

use kingfisher::board::Board;
use kingfisher::move_generation::MoveGen;
use kingfisher::mcts::tactical::identify_tactical_moves;
use kingfisher::search::see;
use kingfisher::move_types::Move;

fn main() {
    println!(" Kingfisher Chess Engine - SEE Integration Demo");
    println!("=================================================\n");

    // Test positions where SEE makes a significant difference
    let test_positions = vec![
        (
            "Complex Exchange Position",
            "r1bqkb1r/pppp1ppp/2n2n2/4p3/2B1P3/3P1N2/PPP2PPP/RNBQK2R w KQkq - 4 4",
            "Multiple pieces attacking central squares - SEE crucial for evaluation"
        ),
        (
            "Hanging Piece Position", 
            "r1bqk2r/pppp1ppp/2n2n2/2b1p3/2B1P3/5N2/PPPP1PPP/RNBQK2R w KQkq - 6 4",
            "Black bishop on c5 can be captured - SEE determines if it's profitable"
        ),
        (
            "Defended Pawn Position",
            "rnbqkb1r/ppp2ppp/3p1n2/4p3/4P3/5N2/PPPP1PPP/RNBQKB1R w KQkq - 0 4", 
            "Central pawns defended by multiple pieces"
        ),
        (
            "Queen vs Pieces Exchange",
            "r1bqk2r/pppp1ppp/2n2n2/8/1bB1P3/3P1N2/PPP2PPP/RNBQK2R w KQkq - 0 5",
            "Black bishop attacks white bishop - complex exchange evaluation"
        ),
    ];

    let move_gen = MoveGen::new();
    
    println!(" Phase 1: SEE Impact Analysis");
    println!("===============================\n");
    
    analyze_see_impact(&test_positions, &move_gen);
    
    println!("\n Phase 2: Tactical Move Quality Comparison");
    println!("===========================================\n");
    
    compare_tactical_quality(&test_positions, &move_gen);]]>
</content>
</file>

<file path="src/bin/self_play.rs" tokens="550" focus="false" inclusion="skeleton" relevance="2.1" reason="Medium relevance (2.08), skeletonized">
<content>
<![CDATA[
//! Self-Play Data Generation Binary
//! 
//! This binary plays games of the engine against itself to generate training data
//! for the neural network. It outputs binary files compatible with the Python training script.

use kingfisher::board::Board;
use kingfisher::eval::PestoEval;
use kingfisher::move_generation::MoveGen;
use kingfisher::mcts::{tactical_mcts_search_for_training, TacticalMctsConfig};
use kingfisher::neural_net::NeuralNetPolicy;
use kingfisher::piece_types::{PAWN, KNIGHT, BISHOP, ROOK, QUEEN, KING, WHITE, BLACK};
use kingfisher::tensor::move_to_index;
use std::fs::File;
use std::io::Write;
use std::sync::Mutex;
use std::time::{Duration, SystemTime, UNIX_EPOCH};
use rayon::prelude::*;

// Data structure for holding a single training sample in memory before serialization
struct TrainingSample {
    board: Board,
    policy: Vec<(u16, f32)>, // (Move Index, Probability)
    value_target: f32,       // +1 (Win), -1 (Loss), 0 (Draw)
    material_scalar: f32,
}

fn main() {
    let args: Vec<String> = std::env::args().collect();
    let num_games = if args.len() > 1 { args[1].parse().unwrap_or(1) } else { 1 };
    let simulations = if args.len() > 2 { args[2].parse().unwrap_or(800) } else { 800 };
    let output_dir = if args.len() > 3 { &args[3] } else { "data/training" };
    let model_path = if args.len() > 4 { Some(args[4].clone()) } else { None };

    println!(" Self-Play Generator Starting...");
    println!("   Games: {}", num_games);
    println!("   Simulations/Move: {}", simulations);
    println!("   Output Dir: {}", output_dir);
    println!("   Model Path: {:?}", model_path);

    std::fs::create_dir_all(output_dir).unwrap();

    let completed_games = Mutex::new(0);

    // Run games in parallel
    (0..num_games).into_par_iter().for_each(|i| {
        let samples = play_game(i, simulations, model_path.clone());
        
        if !samples.is_empty() {
            // Save binary data
            let timestamp = SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs();]]>
</content>
</file>

<file path="src/bin/mate_search_tt_demo.rs" tokens="498" focus="false" inclusion="skeleton" relevance="2.1" reason="Medium relevance (2.06), skeletonized">
<content>
<![CDATA[
//! Transposition Table and Mate Search Demo
//!
//! This demo showcases how the transposition table improves the efficiency of
//! tactical-first MCTS by caching mate search results and allowing them to
//! be reused across different branches of the search tree.

use kingfisher::board::Board;
use kingfisher::eval::PestoEval;
use kingfisher::move_generation::MoveGen;
use kingfisher::mcts::{tactical_mcts_search_with_tt, TacticalMctsConfig};
use kingfisher::transposition::TranspositionTable;
use std::time::{Duration, Instant};

fn main() {
    println!(" Transposition Table Mate Search Demo");
    println!("=======================================");
    
    let move_gen = MoveGen::new();
    let pesto_eval = PestoEval::new();
    
    // Sample tactical positions
    let positions = vec![
        ("Back Rank Mate", "6k1/5ppp/8/8/8/8/8/4R2K w - - 0 1"),
        ("Smothered Mate", "6rk/5Npp/8/8/8/8/8/7K b - - 0 1"),
        ("Complex Mate-in-3", "r5rk/5p1p/5R2/4B3/8/8/7P/7K w - - 0 1"),
    ];
    
    // 1. Show speedup from cold vs warm TT
    show_tt_speedup(&positions, &move_gen, &pesto_eval);
    
    // 2. Analyze cache efficiency
    analyze_mate_cache_efficiency(&positions, &move_gen, &pesto_eval);
    
    // 3. Benchmark repeated searches
    benchmark_repeated_searches(&positions, &move_gen, &pesto_eval);
}

fn show_tt_speedup(
    positions: &[(&str, &str)],
    move_gen: &MoveGen,
    pesto_eval: &PestoEval,
) {
    println!("\n--- Part 1: Cold vs Warm TT Speedup ---");
    
    let config = TacticalMctsConfig {
        max_iterations: 100,
        time_limit: Duration::from_millis(500),
        mate_search_depth: 4,
        exploration_constant: 1.414,
        use_neural_policy: false,]]>
</content>
</file>

<file path="src/bin/strength_test.rs" tokens="435" focus="false" inclusion="skeleton" relevance="2.0" reason="Medium relevance (2.04), skeletonized">
<content>
<![CDATA[
//! Comprehensive Strength Testing Binary
//!
//! Runs extensive benchmarks comparing all engine variants to demonstrate
//! the effectiveness of our mate-search-first + neural network approach.

use kingfisher::benchmarks::strength_testing::{StrengthTester, StrengthTestConfig};
use std::env;

fn main() {
    println!(" Kingfisher Chess Engine - Comprehensive Strength Testing");
    println!("===========================================================");
    
    // Parse command line arguments
    let args: Vec<String> = env::args().collect();
    let config = parse_args(&args);
    
    println!("  Test Configuration:");
    println!("   Time per position: {}ms", config.time_limit_ms);
    println!("   MCTS iterations: {}", config.mcts_iterations);
    println!("   Alpha-beta depth: {}", config.ab_depth);
    println!("   Mate search depth: {}", config.mate_search_depth);
    if let Some(ref model_path) = config.neural_model_path {
        println!("   Neural model: {}", model_path);
    } else {
        println!("   Neural model: None (will skip neural variants)");
    }
    
    // Create and run strength tester
    let mut tester = StrengthTester::new(config);
    let results = tester.run_comprehensive_test();
    
    // Save detailed results
    if let Err(e) = results.save_to_csv("strength_test_results.csv") {
        println!("  Failed to save detailed results: {}", e);
    }
    
    println!("\n Strength testing complete!");
    println!(" Detailed results saved to: strength_test_results.csv");
    println!("\nKey takeaways:");
    println!("- Compare the rankings to see which approach works best");
    println!("- Look for positive improvement percentages in mate-search and neural network");
    println!("- Use these results to tune parameters and validate our innovations");
}

fn parse_args(args: &[String]) -> StrengthTestConfig {
    let mut config = StrengthTestConfig::default();
    
    let mut i = 1;
    while i < args.len() {
        match args[i].as_str() {]]>
</content>
</file>

<file path="src/bin/verify_tactical_graft.rs" tokens="483" focus="false" inclusion="skeleton" relevance="2.0" reason="Medium relevance (2.02), skeletonized">
<content>
<![CDATA[
use kingfisher::board::Board;
use kingfisher::move_generation::MoveGen;
use kingfisher::eval::PestoEval;
use kingfisher::mcts::TacticalMctsConfig;
use kingfisher::mcts::tactical_mcts::tactical_mcts_search;
use std::time::Duration;

fn main() {
    let move_gen = MoveGen::new();
    let pesto = PestoEval::new();
    
    println!(" Verifying Tier 2 Tactical Grafting (Queen Sac Test)...");

    // Position: White Queen can take a protected Pawn on e5.
    // r1bqkbnr/pppp1ppp/2n5/4p3/4P3/4Q3/PPPP1PPP/RNB1KBNR w KQkq - 0 1
    let fen = "r1bqkbnr/pppp1ppp/2n5/4p3/4P3/4Q3/PPPP1PPP/RNB1KBNR w KQkq - 0 1";
    let board = Board::new_from_fen(fen);
    
    // We want to see if MCTS avoids Qxe5 (which is 37 to 36 index? No, e3 to e5).
    // e3 is 20, e5 is 36.
    
    let config = TacticalMctsConfig {
        max_iterations: 100,
        time_limit: Duration::from_secs(2),
        ..Default::default()
    };

    let mut nn = None;
    let (best_move, stats, _) = tactical_mcts_search(board, &move_gen, &pesto, &mut nn, config);

    println!("\nSearch Results:");
    println!("  Best Move: {}", best_move.map_or("None".to_string(), |m| m.to_uci()));
    println!("  Nodes Expanded: {}", stats.nodes_expanded);
    
    if let Some(mv) = best_move {
        if mv.to_uci() == "e3e5" {
            println!(" FAILURE: Engine chose the Queen Sacrifice!");
        } else {
            println!(" SUCCESS: Engine avoided the Queen Sacrifice.");
        }
    }
}]]>
</content>
</file>

<file path="src/bin/benchmark_gates.rs" tokens="575" focus="false" inclusion="skeleton" relevance="2.0" reason="Medium relevance (2.00), skeletonized">
<content>
<![CDATA[
use kingfisher::board::Board;
use kingfisher::move_generation::MoveGen;
use kingfisher::eval::PestoEval;
use kingfisher::search::koth_center_in_3;
use kingfisher::mcts::tactical_mcts::{tactical_mcts_search, TacticalMctsConfig};
use kingfisher::search::mate_search;
use kingfisher::boardstack::BoardStack;
use std::time::Instant;

fn main() {
    let move_gen = MoveGen::new();
    let pesto = PestoEval::new();
    
    println!(" Benchmarking Safety Gates & MCTS Inspector...");

    // --- 1. MCTS Search + Inspector Test ---
    println!("\n--- MCTS Inspector Test ---");
    let fen = "r1bqkbnr/pppp1ppp/2n5/4p3/4P3/4Q3/PPPP1PPP/RNB1KBNR w KQkq - 0 1";
    let board = Board::new_from_fen(fen);
    let mut nn = None;
    let config = TacticalMctsConfig {
        max_iterations: 100,
        ..Default::default()
    };

    let (_mv, _stats, root) = tactical_mcts_search(board, &move_gen, &pesto, &mut nn, config);
    let dot = root.borrow().export_dot(3, 0);
    
    match std::fs::write("test_tree.dot", dot) {
        Ok(_) => println!(" MCTS Inspector: test_tree.dot generated successfully."),
        Err(e) => println!(" MCTS Inspector: Failed to generate dot file: {}", e),
    }

    // --- 2. Mate Search Tests ---
    println!("\n--- Tier 1: Mate Search (Checks Only) ---");
    let mate_puzzles = vec![
        ("4k3/Q7/4K3/8/8/8/8/8 w - - 0 1", "Mate in 1"),
        ("6k1/5ppp/8/8/8/8/8/4R2K w - - 0 1", "Mate in 2"),
    ];

    for (fen, name) in mate_puzzles {
        let board = Board::new_from_fen(fen);
        let mut stack = BoardStack::with_board(board);
        
        let start = Instant::now();
        let (score, mv, nodes) = mate_search(&mut stack, &move_gen, 3, false);
        let duration = start.elapsed();
        
        println!("{}: {} ({} nodes) in {:?}", 
            name, ]]>
</content>
</file>

<file path="src/bin/tactical_benchmark.rs" tokens="392" focus="false" inclusion="skeleton" relevance="2.0" reason="Medium relevance (1.98), skeletonized">
<content>
<![CDATA[
//! Comprehensive Tactical-Enhanced MCTS Benchmark Suite
//!
//! This benchmark validates the efficiency claims of the Tactics-Enhanced MCTS
//! by comparing it against classical MCTS and alpha-beta search across
//! various tactical and strategic positions.

use kingfisher::benchmarks::tactical_suite::{get_tactical_test_suite, TacticalPosition};
use kingfisher::board::Board;
use kingfisher::eval::PestoEval;
use kingfisher::move_generation::MoveGen;
use kingfisher::mcts::{tactical_mcts_search, TacticalMctsConfig, mcts_pesto_search};
use std::time::{Duration, Instant};

#[derive(Debug, Clone)]
pub struct BenchmarkConfig {
    pub tactical_mcts_time: Duration,
    pub classical_mcts_time: Duration,
    pub alpha_beta_time: Duration,
    pub tactical_mcts_iterations: u32,
    pub classical_mcts_iterations: u32,
    pub alpha_beta_depth: i32,
    pub mate_search_depth: i32,
}

impl Default for BenchmarkConfig {
    fn default() -> Self {
        BenchmarkConfig {
            tactical_mcts_time: Duration::from_millis(1000),
            classical_mcts_time: Duration::from_millis(1000),
            alpha_beta_time: Duration::from_millis(1000),
            tactical_mcts_iterations: 500,
            classical_mcts_iterations: 500,
            alpha_beta_depth: 6,
            mate_search_depth: 3,
        }
    }
}

#[derive(Debug)]
pub struct SearchResult {
    pub best_move: Option<kingfisher::move_types::Move>,
    pub search_time: Duration,
    pub nodes_searched: u64,
    pub nn_evaluations: u32,
    pub tactical_moves_explored: u32,
    pub mates_found: u32,
    pub engine_type: String,
}

#[derive(Debug)]]]>
</content>
</file>

<file path="src/lib.rs" tokens="487" focus="false" inclusion="skeleton" relevance="2.0" reason="Medium relevance (1.96), skeletonized">
<content>
<![CDATA[
//! # Kingfisher Chess Engine Library
//!
//! A sophisticated chess engine featuring innovative **Tactical-First MCTS with Lazy Policy Evaluation**.
//! This library combines classical chess programming techniques with cutting-edge AI methods,
//! implementing a three-tier search prioritization system that follows chess principles while
//! maintaining computational efficiency.
//!
//! ## Key Innovations
//!
//! ### Tactical-First MCTS Architecture
//! - **Tier 1**: Mate search first (exhaustive forced-win analysis)
//! - **Tier 2**: Tactical moves prioritized (captures, checks, forks using classical heuristics)
//! - **Tier 3**: Lazy neural policy evaluation (deferred until after tactical exploration)
//!
//! This approach implements the chess principle of "examine all checks, captures, and threats"
//! while substantially reducing neural network computational overhead.
//!
//! ## Core Modules
//!
//! ### Search & AI
//! - **`mcts`** - Tactical-first MCTS with lazy policy evaluation
//! - **`search`** - Classical alpha-beta with enhancements
//! - **`neural_net`** - Neural network policy integration
//! - **`agent`** - Engine interface and move selection
//!
//! ### Chess Foundation
//! - **`board`**, **`board_utils`**, **`boardstack`** - Board representation
//! - **`move_generation`**, **`magic_bitboard`** - Move generation with magic bitboards
//! - **`eval`**, **`eval_constants`** - Pesto-style tapered evaluation
//! - **`transposition`** - Transposition table for caching
//!
//! ### Training & Analysis
//! - **`training`** - Neural network training pipeline
//! - **`benchmarks`** - Comprehensive strength testing
//! - **`tuning`** - Texel tuning for evaluation optimization
//! - **`egtb`** - Endgame tablebase integration
//!
//! ### Infrastructure
//! - **`uci`** - Universal Chess Interface protocol
//! - **`move_types`**, **`piece_types`** - Core chess types
//! - **`bits`**, **`hash`**, **`utils`** - Utility functions

pub mod agent;
pub mod arena;
pub mod benchmarks;
pub mod bits;
pub mod board;
pub mod board_utils;
pub mod boardstack;
pub mod eval;]]>
</content>
</file>

<file path="src/tensor.rs" tokens="477" focus="false" inclusion="skeleton" relevance="1.9" reason="Medium relevance (1.94), skeletonized">
<content>
<![CDATA[
//! Tensor mapping logic for AlphaZero policy representation
//!
//! Maps chess moves to a flat index (0..4672) representing the 8x8x73 policy tensor.

use crate::move_types::Move;
use crate::piece_types::{KNIGHT, BISHOP, ROOK, QUEEN};

/// Converts a move to a flat index in the 8x8x73 policy tensor.
///
/// Formula: Index = (SourceSquare * 73) + PlaneIndex
pub fn move_to_index(mv: Move) -> usize {
    let src = mv.from;
    let dst = mv.to;
    
    let src_rank = (src / 8) as i32;
    let src_file = (src % 8) as i32;
    let dst_rank = (dst / 8) as i32;
    let dst_file = (dst % 8) as i32;
    
    let dx = dst_file - src_file;
    let dy = dst_rank - src_rank;
    
    let plane = if mv.is_promotion() && mv.promotion.unwrap() != QUEEN {
        // Case A: Underpromotion (Promoting to N, B, R)
        let promo_piece = mv.promotion.unwrap();
        
        let direction_offset = match dx {
            0 => 0,  // Straight
            -1 => 1, // Capture Left
            1 => 2,  // Capture Right
            _ => panic!("Invalid promotion move dx: {}", dx),
        };
        
        let piece_offset = match promo_piece {
            KNIGHT => 0,
            BISHOP => 3,
            ROOK => 6,
            _ => panic!("Invalid underpromotion piece: {}", promo_piece),
        };
        
        64 + direction_offset + piece_offset
    } else if (dx * dy).abs() == 2 {
        // Case B: Knight Move
        // Map (dx, dy) to 0..7
        let knight_idx = match (dx, dy) {
            (1, 2) => 0,
            (2, 1) => 1,
            (2, -1) => 2,
            (1, -2) => 3,
            (-1, -2) => 4,]]>
</content>
</file>

<file path="src/egtb.rs" tokens="439" focus="false" inclusion="skeleton" relevance="1.9" reason="Medium relevance (1.92), skeletonized">
<content>
<![CDATA[
// src/egtb.rs

// Use internal project types
use crate::board::Board;
use crate::move_types::Move;
 // Needed for piece count calculation

// Use the Syzygy library
use shakmaty::Board as ShakmatyBoard;
use shakmaty_syzygy::{Wdl, Dtz};

// Define the error type for EGTB operations
#[derive(Debug, Clone)]
pub enum EgtbError {
    LoadError(String), // Error loading tablebases
    ProbeError(String), // Error during probing
    ConversionError(String), // Error converting board representation
}

impl std::fmt::Display for EgtbError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            EgtbError::LoadError(s) => write!(f, "EGTB Load Error: {}", s),
            EgtbError::ProbeError(s) => write!(f, "EGTB Probe Error: {}", s),
            EgtbError::ConversionError(s) => write!(f, "Board Conversion Error: {}", s),
        }
    }
}

impl std::error::Error for EgtbError {}


/// Information obtained from probing the endgame tablebases.
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct EgtbInfo {
    /// Win/Draw/Loss status from the perspective of the side to move.
    pub wdl: Wdl,
    /// Distance to Zeroing move (often related to Distance to Mate).
    pub dtz: Option<Dtz>,
    /// The best move according to the tablebase, if available. (Currently always None)
    pub best_move: Option<Move>, // Use crate::move_types::Move
}

/// Structure to handle Syzygy endgame tablebase probing.
#[derive(Clone)]
pub struct EgtbProber {
    // tablebases: Tablebase<ShakmatyBoard>, // Temporarily commented out to fix compilation
    pub max_pieces: u8, // Store the max pieces supported by loaded tables
}
]]>
</content>
</file>

<file path="src/make_move.rs" tokens="417" focus="false" inclusion="skeleton" relevance="1.9" reason="Medium relevance (1.90), skeletonized">
<content>
<![CDATA[
//! Module for making moves on the chess board
//!
//! This module provides functionality to apply moves on the Bitboard representation of a chess position.

use crate::board::Board;
use crate::board_utils::sq_ind_to_bit;
use crate::move_types::Move;
use crate::piece_types::{BLACK, KING, PAWN, ROOK, WHITE};

impl Board {
    /// Makes a move on the board, returning a new board with the move applied
    ///
    /// This method assumes the move is legal and does not perform any legality checks.
    ///
    /// # Arguments
    ///
    /// * `the_move` - The Move to be applied to the board
    ///
    /// # Returns
    ///
    /// A new Bitboard representing the position after the move has been made
    pub fn apply_move_to_board(&self, the_move: Move) -> Board {
        // Make a move, returning a new board.
        // Assumes the move is legal.

        let mut new_board = self.clone();

        // Null move: remove en passant ability and return new board
        if the_move.from == 0 && the_move.to == 0 {
            new_board.en_passant = None;
            new_board.w_to_move = !new_board.w_to_move;
            if new_board.w_to_move {
                new_board.fullmove_number += 1;
            }
            new_board.zobrist_hash = new_board.compute_zobrist_hash();
            return new_board;
        }

        new_board.halfmove_clock += 1;

        let from_bit = sq_ind_to_bit(the_move.from);
        let to_bit = sq_ind_to_bit(the_move.to);

        let from_piece = self.get_piece(the_move.from);
        if from_piece.is_none() {
            panic!("No piece at from_sq_ind {} ({})", the_move.from, crate::board_utils::sq_ind_to_algebraic(the_move.from));
        }

        let to_piece = self.get_piece(the_move.to);
        if to_piece.is_some() {]]>
</content>
</file>

<file path="src/training/mod.rs" tokens="379" focus="false" inclusion="skeleton" relevance="1.9" reason="Medium relevance (1.89), skeletonized">
<content>
<![CDATA[
//! Training data generation for neural network policy
//!
//! This module provides functionality to generate training data for the neural network
//! by analyzing positions with the engine and extracting features.

use crate::board::Board;
use crate::eval::PestoEval;
use crate::move_generation::MoveGen;
use crate::move_types::Move;
use std::collections::HashMap;
use std::fs::File;
use std::io::{Write, BufRead, BufReader};
use std::path::Path;

/// Training position with target values for neural network
#[derive(Debug, Clone)]
pub struct TrainingPosition {
    /// Board position as FEN string
    pub fen: String,
    /// Game result (1.0 = white wins, 0.5 = draw, 0.0 = black wins)
    pub game_result: f64,
    /// Best move in UCI format (if available)
    pub best_move: Option<String>,
    /// Engine evaluation in centipawns
    pub engine_eval: Option<i32>,
    /// Description/source of position
    pub description: String,
}

impl TrainingPosition {
    pub fn new(board: &Board, game_result: f64, best_move: Option<Move>, description: String) -> Self {
        TrainingPosition {
            fen: board.to_fen().unwrap_or_default(),
            game_result,
            best_move: best_move.map(|mv| mv.to_uci()),
            engine_eval: None,
            description,
        }
    }
    
    /// Convert to CSV format for Python training pipeline
    pub fn to_csv_line(&self) -> String {
        format!("{},{},{},{},\"{}\"",
            self.fen,
            self.game_result,
            self.best_move.as_deref().unwrap_or(""),
            self.engine_eval.unwrap_or(0),
            self.description
        )
    }]]>
</content>
</file>

<file path="results/figures/summary.md" tokens="158" focus="false" inclusion="summary" relevance="2.3" reason="Documentation (summarized)">
<content>
<![CDATA[
# Ablation Study Results Summary
| Configuration | NN Reduction | Tier 1 | Tier 2 | NN Calls | Safety |
|---------------|--------------|--------|--------|----------|--------|
| baseline_mcts | 25.0% | 0 | 0 | 0 | 33% |
| tier1_only | 25.0% | 585 | 0 | 0 | 67% |
| classical_hybrid | 37.5% | 587 | 76 | 0 | 67% |
| neural_only | 25.0% | 0 | 0 | 0 | 33% |
| full_system | 37.5% | 587 | 76 | 0 | 67% |]]>
</content>
</file>

<file path="STREAM_OF_CONSCIOUSNESS_IMPLEMENTATION_GUIDE.md" tokens="309" focus="false" inclusion="summary" relevance="2.2" reason="Documentation (summarized)">
<content>
<![CDATA[
Stream of Consciousness Logger: Complete Implementation Guide
Goal
Create a real-time text narration system that explains why the search is making specific decisions at each tier transition. This is invaluable for:
Understanding why certain moves are prioritized
Debugging when Tier 1/2 overrides are not firing correctly
Educational purposes (explaining MCTS to users)
Building intuition about the engine's "thought process"
Architecture

                     SearchLogger                             

  log_tier1_gate(reason, move, score)                        
  log_tier2_graft(qs_result, principal_variation)            
  log_tier3_neural(policy_probs, value)                      
  log_selection(node, chosen_child, reason)                  
  log_backprop(path, values)                                 
  log_iteration_summary(stats)                               

  Output Sinks: Console, File, Structured (JSON)             


<!-- Additional sections: -->
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
#[derive(Debug, Clone)]
#[derive(Debug, Clone)]
#[derive(Debug, Clone)]
#[test]
#[test]
#[test]
#[test]
#[test]
#[test]]]>
</content>
</file>

<file path="BENCHMARKING.md" tokens="388" focus="false" inclusion="summary" relevance="2.2" reason="Documentation (summarized)">
<content>
<![CDATA[
# Caissawary Chess Engine - Benchmarking Guide
This guide covers comprehensive performance testing and analysis of the Caissawary Chess Engine, including our novel mate-search-first MCTS approach and neural network integration.
##  Benchmarking Philosophy
Caissawary's benchmarking suite provides professional-grade performance analysis comparing 5 distinct engine variants across tactical, positional, and endgame scenarios with statistical Elo estimation.
##  Engine Variants Tested
### 1. **Alpha-Beta** (Baseline)
- Pure classical alpha-beta search
- Enhanced with iterative deepening, transposition tables
- Pesto evaluation function
- Represents traditional chess programming approach
### 2. **MCTS-Classical** 
- Standard Monte Carlo Tree Search
- Classical evaluation for leaf nodes
- UCT selection formula
- No tactical enhancements
### 3. **MCTS-Mate-Priority** 
- **Our Innovation**: Mate-search-first MCTS
- Performs exhaustive mate search before MCTS evaluation
- Exact tactical analysis when forced wins exist
- Falls back to classical evaluation when no mate found
### 4. **MCTS-Neural**
- MCTS with neural network policy guidance
- PyTorch ResNet architecture (1788  policy/value)
- Trained on human chess games
- No mate search enhancement
### 5. **MCTS-Complete**
- **Ultimate Hybrid**: Combines all innovations
- Mate-search-first + neural network guidance

<!-- Additional sections: -->
##  Quick Benchmarking
### Basic Strength Test
# Quick comparison (500ms per position)
# Results in ~30 seconds
### Comprehensive Analysis
# Thorough test with neural networks (2+ minutes per position)  
# Detailed Elo analysis with high confidence
### Specific Variants Only
# Test without neural networks (faster)
# Custom neural model path]]>
</content>
</file>

<file path="HUMANLIKE_AGENT.md" tokens="390" focus="false" inclusion="summary" relevance="2.1" reason="Documentation (summarized)">
<content>
<![CDATA[
# HumanlikeAgent Implementation Documentation
## Overview
The HumanlikeAgent is a chess engine that combines classical chess techniques with Monte Carlo Tree Search (MCTS). While designed with future extensions for neural networks and human-like play in mind, the current implementation uses a three-phase decision process:
1. Optional EGTB (Endgame Tablebase) lookup
2. Mate Search
3. MCTS with Pesto evaluation
## Components
### 1. Agent Structure
### 2. Decision Flow
#### Phase 1: EGTB (Optional)
- If `egtb_prober` is Some and position has  max_pieces:
  - Probes EGTB for perfect play information
  - Currently only logs results without using them for move selection
  - Future: Will use EGTB moves when available
#### Phase 2: Mate Search
- Performs classical mate search up to specified depth
- If mate is found, immediately returns the mating move
- Uses standard alpha-beta mate search algorithm
#### Phase 3: MCTS
If no mate is found, performs MCTS with the following characteristics:
##### A. Node Selection
- Uses PUCT (Polynomial Upper Confidence Trees) for tree traversal
- Exploration constant: 2 (1.414)
- Selection formula: Q + U where:
  - Q = average value for selector
  - U = c * P * (N_parent) / (1 + N_child)
  - P = 1/num_legal_moves (uniform prior)
##### B. Move Prioritization
Moves are categorized and explored in strict priority order:
1. **Checks** (Highest Priority)

<!-- Additional sections: -->
##### C. Position Evaluation
##### D. Backpropagation
##### E. Final Move Selection
### 3. Termination Conditions
## Current Limitations
## Future Extensions
## Performance Considerations]]>
</content>
</file>

<file path="RESEARCH.md" tokens="544" focus="false" inclusion="summary" relevance="2.0" reason="Documentation (summarized)">
<content>
<![CDATA[
# Caissawary: Safe and Sample-Efficient Reinforcement Learning through Structured Inductive Biases
## Abstract
We present Caissawary, a chess engine demonstrating that **structured inductive biases from classical game theory dramatically improve sample efficiency and safety in reinforcement learning**. Our three-tier architecture prioritizes exact analysis over approximate inference: (1) Safety gates guarantee correct behavior in forced tactical situations, (2) Tactical grafting injects classical search results into the learning tree, and (3) Neural network evaluation handles genuinely uncertain positions. This approach reduces neural network calls by 40-70% while **provably preventing tactical blunders** - a critical safety property for real-world RL deployment.
## Key Contributions
1. **Formal Safety Guarantees**: Tier 1 gates provide mathematically provable correct decisions in positions with forced outcomes, ensuring the agent cannot make catastrophic errors regardless of neural network quality.
2. **Sample Efficiency**: By reserving expensive neural inference for genuinely uncertain positions, we reduce NN calls by 40-70% without sacrificing playing strength.
3. **Graceful Degradation**: Unlike pure neural approaches, our system maintains strong performance even with randomly initialized networks, enabling faster training convergence.
4. **Interpretable Decision Making**: The tier system provides clear explanations for why decisions were made - essential for debugging and trust in AI systems.
## Research Questions
**RQ1**: How much can structured inductive biases reduce neural network inference requirements?
- *Hypothesis*: Tier 1+2 can handle 40-70% of positions without NN calls
- *Metric*: Neural network call reduction percentage
**RQ2**: Do safety gates prevent tactical blunders during exploration?
- *Hypothesis*: Tier 1 achieves 100% accuracy on positions with forced mates
- *Metric*: Forced mate detection rate
**RQ3**: How does the hybrid approach affect training sample efficiency?
- *Hypothesis*: Faster convergence due to cleaner training signal
- *Metric*: Training games to reach target Elo
## Methodology
### Experimental Setup
We compare five configurations:
1. **Baseline MCTS**: Standard MCTS with classical evaluation
2. **Tier 1 Only**: MCTS + Safety gates
3. **Classical Hybrid**: MCTS + Tier 1 + Tier 2 (no neural network)
4. **Neural Only**: MCTS + Neural network (AlphaZero-style)
5. **Full System**: All three tiers

<!-- Additional sections: -->
### Test Suite
### Metrics
## Discussion
### Implications for Safe RL
### Limitations
## Conclusion
## Reproducibility]]>
</content>
</file>

<file path="TESTING.md" tokens="440" focus="false" inclusion="summary" relevance="2.0" reason="Documentation (summarized)">
<content>
<![CDATA[
# Testing Guide for Caissawary
Caissawary employs a comprehensive testing strategy ensuring correctness, stability, and performance. The test suite is divided into several categories targeting different layers of the engine.
## Quick Start
To run the full test suite (Unit, Integration, Property, and Regression):
To run only standard Cargo tests:
## Test Categories
### 1. Unit Tests (`tests/unit/`)
Focus on individual components in isolation.
- **Board:** FEN parsing, state representation, castling rights.
- **Move Generation:** Validity of moves, pseudo-legal vs legal generation.
- **Node:** MCTS node value logic, terminal state handling.
- **Selection:** UCB/PUCT calculations.
### 2. Integration Tests (`tests/integration/`)
Test the interaction between subsystems, particularly the MCTS search pipeline.
- **Mate Search:** Verifies the engine finds mates in complex positions.
- **Tactical Priority:** Ensures tactical moves (captures, checks) are prioritized.
- **Neural Integration:** Tests the flow between the search tree and (mocked) inference server.
### 3. Property Tests (`tests/property/`)
Uses `proptest` to generate random inputs and verify invariants.
- **Legal Moves:** Random positions are generated to ensure `generate_legal_moves` never produces illegal states.
- **Value Domains:** Verifies evaluations stay within valid bounds (e.g., tanh domain [-1, 1]).
### 4. Regression Tests (`tests/regression/`)
Target specific bugs found during development to ensure they do not reoccur.
- **Stack Overflow:** Verifies fix for `BoardStack` history handling.
- **Castling Rules:** Ensures castling is correctly blocked when traversing check.
### 5. Perft Tests (`tests/perft_tests.rs`)
Performance and correctness tests for move generation. These walk the game tree to a fixed depth and compare the leaf node count against known correct values.
## Running Specific Tests
To run a specific test file or test case:

<!-- Additional sections: -->
# Run only regression tests
# Run a specific test case
## Continuous Integration]]>
</content>
</file>

<file path="STREAM_OF_CONSCIOUSNESS_LOGGER.md" tokens="547" focus="false" inclusion="summary" relevance="0.9" reason="Documentation (summarized)">
<content>
<![CDATA[
# Caissawary Stream of Consciousness Logger
The **Stream of Consciousness Logger** is a real-time narration system for Caissawary's search process. It provides a human-readable "thought process" of the engine as it navigates the search tree, explaining why specific moves are prioritized and how different tiers of the hybrid search architecture interact.
##  Purpose
- **Explainable Search:** Understand the "why" behind the engine's move choices.
- **Debugging Tier Transitions:** Verify that Tier 1 gates and Tier 2 grafts are firing correctly in sharp positions.
- **Educational Tool:** Learn how MCTS and PUCT selection work through real-time examples.
- **Performance Analysis:** Identify where the engine is spending time (e.g., mate search vs. neural inference).
##  Verbosity Levels
The logger supports five hierarchical verbosity levels:
| Level | Description | Key Events Logged |
|-------|-------------|-------------------|
| **Silent (0)** | No output | None |
| **Minimal (1)** | Crucial events only | Tier 1 Gate triggers, Search completion, 100-iteration summaries |
| **Normal (2)** | Standard narration | Tier 2 Grafts, Tier 3 NN values, Tactical move counts, 50-iteration summaries |
| **Verbose (3)** | Detailed trace | Mate search starts, QS PVs, Selection decisions (UCB components), Policy priors |
| **Debug (4)** | Full internal state | Iteration starts, Node entry/exit, Backpropagation, Raw state dumps |
##  The `verbose_search` Tool
Caissawary includes a dedicated CLI tool to run searches with the logger enabled.
### Basic Usage
### Options
- `--verbosity <level>`: Set output level (`silent`, `minimal`, `normal`, `verbose`, `debug`). Defaults to `normal`.
- `--iterations <n>`: Number of MCTS iterations to run. Defaults to 200.
- `--no-emoji`: Disable emoji icons in the output for better compatibility with some terminals.
### Example: Analyzing a Mate-in-1
**Example Output:**
##  Technical Implementation
### Thread-Safe Design
The logger is designed to be shared across threads using `Arc<SearchLogger>`. It uses internal mutability with `Mutex` and `Atomic` types to ensure that logging from different search threads (if enabled) or asynchronous inference callbacks is safe and consistent.
### Output Sinks
The system supports multiple output destinations:

<!-- Additional sections: -->
### Performance Conscious
##  Testing the Logger]]>
</content>
</file>

<file path="IMPLEMENTATION_GUIDE.md" tokens="508" focus="false" inclusion="summary" relevance="0.9" reason="Documentation (summarized)">
<content>
<![CDATA[
# Implementation Guide: Elevating Caissawary for Safe & Sample-Efficient RL Research
## Framing the Research Contribution
**Thesis**: Caissawary demonstrates that **structured inductive biases from classical game theory can dramatically improve sample efficiency and safety in reinforcement learning**, reducing reliance on expensive neural network inference while guaranteeing correct behavior in tractable subproblems.
**Key Claims to Validate**:
1. Tier 1 gates provide **provably correct** decisions in forced tactical situations
2. Tier 2 grafting reduces neural network calls by 40-70% without strength loss
3. The hybrid approach enables **safe exploration** - the agent cannot make catastrophic tactical blunders even with a randomly initialized policy network
4. Training converges faster because the NN only needs to learn strategic/positional concepts, not tactics
---
## Phase 1: Establish Rigorous Experimental Infrastructure
### Task 1.1: Create Experiment Configuration System
Create a new file `src/experiments/config.rs` that defines ablation configurations:
### Task 1.2: Create Metrics Collection System
Create `src/experiments/metrics.rs`:
### Task 1.3: Create the Experiment Runner Binary
Create `src/bin/run_experiments.rs`:
### Task 1.4: Update the Module Structure
Create `src/experiments/mod.rs`:
Update `src/lib.rs` to include the new module:
Add required dependencies to `Cargo.toml`:
---
## Phase 2: Implement Proper Metrics Tracking in Search
### Task 2.1: Update TacticalMctsStats
Modify `src/mcts/tactical_mcts.rs` to track all metrics needed for the experiments. The struct already has most fields, but ensure they're properly populated:
### Task 2.2: Create Position Classification
Create `src/experiments/position_classifier.rs`:
---
## Phase 3: Create Visualization and Analysis Tools
### Task 3.1: Create Analysis Script
Create `scripts/analyze_results.py`:
---
## Phase 4: Strengthen the Research Narrative
### Task 4.1: Create Research Summary Document
Create `RESEARCH.md`:

<!-- Additional sections: -->
# Caissawary: Safe and Sample-Efficient Reinforcement Learning through Structured Inductive Biases
## Abstract
## Key Contributions
## Research Questions
## Methodology
### Experimental Setup
### Test Suite
### Metrics
## Results
### RQ1: Sample Efficiency]]>
</content>
</file>

<file path="requirements.txt" tokens="52" focus="false" inclusion="summary" relevance="0.9" reason="Documentation (summarized)">
<content>
<![CDATA[
torch>=2.0.0
numpy>=1.24.0
python-chess>=1.9.0
matplotlib>=3.7.0
pandas>=2.0.0
seaborn>=0.12.0]]>
</content>
</file>

<file path="PAPER_READY_IMPLEMENTATION_GUIDE.md" tokens="258" focus="false" inclusion="summary" relevance="0.9" reason="Documentation (summarized)">
<content>
<![CDATA[
Implementation Guide: Paper-Ready Experimental Framework
Priority 1: Rigorous Elo Testing Framework
Create src/benchmarks/elo_tournament.rs:
rust//! Elo Tournament Framework for Statistical Validation
//!
//! Runs statistically significant head-to-head matches between engine variants
//! to produce confidence intervals on Elo differences.
use crate::board::Board;
use crate::eval::PestoEval;
use crate::move_generation::MoveGen;
use crate::move_types::Move;
use crate::mcts::tactical_mcts::{tactical_mcts_search, TacticalMctsConfig};
use crate::search::alpha_beta::alpha_beta_search;
use crate::mcts::inference_server::InferenceServer;
use crate::boardstack::BoardStack;
use std::sync::Arc;
use std::time::{Duration, Instant};
use std::collections::HashMap;
use rand::prelude::*;
use rand::rngs::StdRng;

<!-- Additional sections: -->
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[derive(Debug, Clone, Copy)]
#[derive(Debug, Clone)]
#[derive(Debug, Clone)]
#[derive(Debug)]
# Install Python for training
# Create virtual environment
# Install Python dependencies
# Copy Rust project
# Build Rust project]]>
</content>
</file>

<file path="DESIGN_DOC.md" tokens="629" focus="false" inclusion="summary" relevance="0.9" reason="Documentation (summarized)">
<content>
<![CDATA[
# Chess Engine: Design Doc
Version: 1.3
Date: 2025-06-24
## 1. Introduction & Goals
This document outlines the design for a chess engine aimed at providing a human-like sparring experience, targeting players in a specific Elo range. The engine will feature an interpretable evaluation function, explore a novel combination of classical search and neural network guided Monte Carlo Tree Search (MCTS), and leverage existing chess knowledge to bootstrap its capabilities.
Key Goals:
*   **Humanlike Sparring Partner:** Create an engine whose style, opening choices, and (to some extent) strategic priorities resemble human play in a target Elo range (e.g. 2000-2200).
*   **Interpretable Evaluation:** Employ an evaluation function whose core components are understandable to humans, allowing for analysis and potential learning.
*   **Novel Architecture:** Explore innovative tactical-first MCTS with lazy policy evaluation, combining classical chess heuristics with modern neural network guidance.
*   **Leverage Chess Knowledge:** Incorporate established chess principles and classical engine techniques to reduce the learning burden on the NN and ensure baseline competence.
## 2. Core Architecture
The engine features a sophisticated **Tactical-First MCTS** architecture as its primary search algorithm, implementing a three-tier prioritization system.
*   **Search:** Tactical-First MCTS with lazy policy evaluation.
    *   *Status:* **Fully implemented** (`src/mcts/tactical_mcts.rs`). Features mate-search-first, tactical move prioritization, and lazy neural network policy evaluation.
*   **Tactical Prioritization:** Classical chess heuristics prioritize forcing moves before strategic analysis.
    *   *Status:* **Implemented** (`src/mcts/tactical.rs`). Includes MVV-LVA capture ordering, knight/pawn fork detection, check move prioritization, and SEE integration.
*   **Guidance (Policy):** Neural Network Policy provides strategic guidance after tactical moves are explored.
    *   *Status:* **Interface complete** (`src/mcts/policy.rs`, `src/neural_net.rs`). Lazy evaluation reduces computational overhead by 60-80%.
*   **Evaluation (Value):** Enhanced static evaluation provides position assessments for MCTS leaf nodes.
    *   *Status:* See Section 3.
## 3. Evaluation Subsystem (V_{enhanced})
The evaluation of positions within the MCTS relies on a two-tiered approach:
*   **E_{classical} (Classical Static Evaluation):**
    *   Purpose: Provides a fast, interpretable baseline evaluation.

<!-- Additional sections: -->
## 4. Tactical-First MCTS Architecture
### 4.1 Three-Tier Search Prioritization
### 4.2 Technical Implementation
### 4.3 Chess Principle Integration
## 5. Search Algorithm (Per Move)
## 5. Human-like Elements & Considerations
## 6. Training Strategy
## 7. Opening Book Implementation
## 8. Technology Stack & Status Summary
## 9. Key Tunable Parameters]]>
</content>
</file>

<file path="MCTS_TACTICAL_PRIORITY.md" tokens="514" focus="false" inclusion="summary" relevance="0.9" reason="Documentation (summarized)">
<content>
<![CDATA[
# Design: MCTS Selection Formula Modification for Tactical Priority
## 1. Goal
To enhance the tactical awareness of the MCTS search within the humanlike engine by giving explicit priority to exploring checks and captures during the tree traversal (selection phase), while still leveraging the guidance from the Policy Network (P) and accumulated simulation results (Q).
## 2. Mechanism: Modified PUCT Selection Formula
The standard PUCT formula used for selecting the child node `a` to explore from parent node `s` will be modified to include an additive "Urgency Bonus" based on the move type.
## 3. Formula
**Standard PUCT:**
Select action `a` = argmax_a [ `Q(s,a)` + `C_puct` * `P(s,a)` * sqrt(`N(s)`) / (1 + `N(s,a)`) ]
Where:
*   `Q(s,a)` is the average action value (exploitation term).
*   `P(s,a)` is the prior probability from the Policy Network.
*   `N(s)` is the visit count of the parent node.
*   `N(s,a)` is the visit count of the child node.
*   `C_puct` is the exploration constant.
**Modified PUCT with Tactical Bonus:**
Select action `a` = argmax_a [ `Q(s,a)` + `C_puct` * `P(s,a)` * sqrt(`N(s)`) / (1 + `N(s,a)`) + `Bonus(a)` ]
## 4. Bonus Term Definition
The `Bonus(a)` term is defined as follows:
*   **If move `a` is a Check:**
    *   `Bonus(a)` = `check_urgency_bonus`
*   **If move `a` is a Capture:**
    *   `Bonus(a)` = `capture_urgency_bonus` * `scale(MVV_LVA(a))`
    *   `MVV_LVA(a)`: Score based on Most Valuable Victim - Least Valuable Aggressor heuristic.
    *   `scale()`: A function to normalize the `MVV_LVA(a)` score (e.g., to the range [0, 1] or another suitable range relative to Q-values and the exploration term).
*   **If move `a` is a Quiet move:**

<!-- Additional sections: -->
## 5. Tunable Parameters
## 6. Rationale
## 7. Integration Point]]>
</content>
</file>

<file path="ARCHITECTURE.md" tokens="450" focus="false" inclusion="summary" relevance="0.7" reason="Documentation (summarized)">
<content>
<![CDATA[
# Caissawary Chess Engine - Technical Architecture
This document provides a detailed technical overview of the Caissawary Chess Engine architecture, focusing on our novel mate-search-first MCTS approach and neural network integration.
##  Core Architecture Overview
##  Mate-Search-First MCTS Innovation
### Problem Statement
Traditional neural network chess engines face a fundamental challenge: expensive neural network evaluations on positions where exact analysis is possible. This is particularly problematic during training when the neural network is randomly initialized and provides poor guidance.
### Solution: Hybrid Classical-Modern Approach
Our mate-search-first MCTS performs the following at each leaf node:
### Key Benefits
1. **Exact Tactical Analysis**: Forced wins/losses get perfect evaluation
2. **Reduced NN Dependency**: Fewer expensive neural network calls
3. **Training Acceleration**: Correct play in tactical positions from day 1
4. **Interpretable Results**: Classical analysis provides explainable decisions
### Implementation Details
**Mate Search Integration** (`src/mcts/mod.rs`):
- Depth-limited classical search (typically 3-5 plies)
- Alpha-beta with aggressive pruning for mate detection
- Return values: `(score, best_move, depth_to_mate)`
**MCTS Tree Integration** (`src/mcts/node.rs`):
- Exact results bypass neural network evaluation
- Immediate backpropagation of forced results
- Enhanced move ordering based on tactical threats
##  Neural Network Architecture
### Network Design
**ResNet-Style Architecture**:
**Board Representation**:
- 17 channels total:
    - 12 channels: 6 piece types  2 colors
    - 1 channel: En Passant target square

<!-- Additional sections: -->
### Training Pipeline
# Quality filtering criteria
# Policy loss: Cross-entropy with actual moves
# Value loss: Mean squared error with game outcomes
##  Search Algorithm Enhancements
### Alpha-Beta Framework (`src/search/alpha_beta.rs`)
### MCTS Implementation (`src/mcts/`)
##  Evaluation Systems
### Pesto Evaluation (`src/eval.rs`)
### Texel Tuning (`src/tuning/`)]]>
</content>
</file>

<file path="TRAINING_GUIDE.md" tokens="672" focus="false" inclusion="summary" relevance="0.7" reason="Documentation (summarized)">
<content>
<![CDATA[
# Design Doc: Self-Play Reinforcement Learning Loop
## 1. Objective
To demonstrate the superior training efficiency of the **Caissawary** (Hybrid MCTS + Mate Search) architecture compared to standard AlphaZero. We aim to create a fully automated pipeline that iteratively improves the neural network through self-play, leveraging the engine's tactical priors to accelerate learning.
## 2. Core Hypothesis
Standard AlphaZero starts from random play and must "learn" basic tactics (like mate-in-1) through trial and error, which is computationally expensive.
**Caissawary Hypothesis:** By injecting "Tactical Priors" (Mate Search + Tier 2 Tactics) into the MCTS:
1.  The engine plays tactically valid chess from Generation 0.
2.  The neural network receives cleaner, higher-quality training data (fewer random blunders).
3.  **Result:** The engine reaches a respectable Elo with significantly fewer training games/compute than AlphaZero.
## 3. Architecture
### A. The Loop (Python Controller)
A master Python script (`python/rl_loop.py`) orchestrates the cycle:
1.  **Generation Phase:** Call Rust engine to play `N` self-play games.
2.  **Training Phase:** Train PyTorch model on the generated games.
3.  **Evaluation Phase:** Play matches between `New Model` vs `Best Model`.
4.  **Promotion:** If `New` > `Best` (win rate > 55%), replace `Best`.
### B. Rust Self-Play Binary (`src/bin/self_play.rs`)
A specialized binary focused on high-throughput data generation.
*   **Input:** Path to `model.pt`, number of games, simulations per move.
*   **Concurrency:** Runs multiple games in parallel threads (using Rayon).
*   **Output:** `training_data_{gen}.json` containing a list of states, each with:
    *   **FEN (Board State):** The position in algebraic notation.
    *   **MCTS Policy Target (`pi`):** The visit counts for each legal move from the MCTS search, representing the "best move" according to the search. (Normalized to a probability distribution).
    *   **Game Outcome Value Target (`z`):** The final outcome of the game (+1 for win, 0 for draw, -1 for loss) from the perspective of the player to move in that specific FEN. This value is backpropagated to all positions in the game.
### C. Training Pipeline (`python/train_gen.py`)
*   **Input:** `training_data_{gen}.json`.
*   **Model:** Uses `MinimalViableNet` (7-layer ResNet) for speed.

<!-- Additional sections: -->
## 4. Implementation Steps & Estimates
### Phase 1: Rust Data Generation (Estimated: 2 Hours)
### Phase 2: Python Training Integration (Estimated: 1.5 Hours)
### Phase 3: The Loop Controller (Estimated: 1 Hour)
### Phase 4: Visualization (Estimated: 0.5 Hours)
## 5. Execution Order
## 6. Training Constraints (AlphaZero Style)
## 7. Success Metric]]>
</content>
</file>

<file path="MCTS_INSPECTOR_IMPLEMENTATION_GUIDE.md" tokens="271" focus="false" inclusion="summary" relevance="0.7" reason="Documentation (summarized)">
<content>
<![CDATA[
Complete Implementation Guide: MCTS Inspector (Graphviz Dumper)
Goal
Finalize the Graphviz dumper to visually distinguish:
 Red (firebrick1): Tier 1 Gate nodes (mate search or KOTH wins)
 Orange (gold): Tier 2 Grafted nodes (from quiescence search)
 Blue (lightblue): Tier 3 Neural nodes (standard MCTS)
 Grey Dashed: Shadow priors (refuted tactical moves)
Files to Modify
src/mcts/node.rs - Enhance export_dot and recursive_dot
src/mcts/mod.rs - Export the inspector functionality
tests/unit/graphviz_tests.rs - New test file
src/bin/mcts_inspector.rs - New binary for CLI usage
Step-by-Step Implementation
Step 1: Define Node Origin Enum
Add to src/mcts/node.rs (after line 465):
rust/// Tracks how this node was created/evaluated for visualization
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum NodeOrigin {
    #[default]
    Unknown,
    /// Tier 1: Solved by mate search or KOTH gate
    Gate,

<!-- Additional sections: -->
#[test]
#[test]
#[test]
#[test]
#[test]
#[test]
#[test]
#[test]]]>
</content>
</file>

<file path="python/README.md" tokens="450" focus="false" inclusion="summary" relevance="0.7" reason="Documentation (summarized)">
<content>
<![CDATA[
# Kingfisher Chess AI Training Pipeline
This directory contains the complete training pipeline for the Kingfisher chess engine's neural network policy. The system combines Rust-based position analysis with PyTorch-based deep learning.
## Quick Start
### 1. Install Dependencies
### 2. Run Complete Training Pipeline
### 3. Test the Trained Model
## Training Pipeline Components
### Core Files
- **`train_chess_ai.py`** - Complete end-to-end training pipeline
- **`chess_net.py`** - PyTorch neural network architecture
- **`training_pipeline.py`** - Data processing and model training
- **`data_collection.py`** - Data downloading and preprocessing
### Rust Integration
- **`src/training/mod.rs`** - Rust training data generation
- **`src/neural_net.rs`** - Neural network integration with engine
- **`src/bin/generate_training_data.rs`** - Training data generator binary
## Neural Network Architecture
The chess neural network uses a ResNet-style architecture:
- **Input**: 1788 tensor (6 piece types  2 colors  en passant  castling  88 board)
- **Body**: 8 residual blocks with 256 channels
- **Policy Head**: Outputs 4672 move probabilities (AlphaZero encoding)
- **Value Head**: Outputs position evaluation [-1, 1]
## Training Data
### Data Sources
1. **Sample Data** - Built-in tactical and strategic positions
2. **Lichess Database** - Downloaded tournament games
3. **Custom PGN** - Your own game collections
### Data Format
Training data is stored in CSV format:
### Quality Filters
- Minimum player rating: 1800 (configurable)
- Game length: 20-100 moves
- Time control: 3 minutes

<!-- Additional sections: -->
## Usage Examples
### Basic Training
# Quick test with sample data
# Longer training with more epochs
### Data Collection
# Download sample games
# Download Lichess rapid games
# Filter existing PGN file
### Custom Training
# Train on custom PGN file]]>
</content>
</file>

</file_contents>

<omitted_files>
<file path="src/hash.rs" relevance="1.9">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="src/alpha_beta.rs" relevance="1.9">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="src/mcts/search_logger.rs" relevance="1.8">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="src/mcts/nn_counter.rs" relevance="1.8">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="src/mcts/neural_mcts.rs" relevance="1.8">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="src/mcts/policy.rs" relevance="1.8">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="src/mcts/tactical.rs" relevance="1.8">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="src/mcts/tactical_mcts.rs" relevance="1.8">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="src/mcts/mod.rs" relevance="1.7">
  <reason>Architecturally Significant</reason>
</file>
<file path="src/mcts/inference_server.rs" relevance="1.7">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="src/mcts/node.rs" relevance="1.7">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="src/mcts/selection.rs" relevance="1.7">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="src/mcts/simulation.rs" relevance="1.7">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="src/mcts/unit_tests/tactical_tests.rs" relevance="1.7">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="src/mcts/unit_tests/mcts_integration_tests.rs" relevance="1.7">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="src/mcts/unit_tests/selection_tests.rs" relevance="1.6">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="src/piece_types.rs" relevance="1.6">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="src/move_types.rs" relevance="1.6">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="src/arena.rs" relevance="1.6">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="src/boardstack.rs" relevance="1.6">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="src/transposition.rs" relevance="1.6">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="src/bits.rs" relevance="1.6">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="src/board.rs" relevance="1.6">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="src/move_generation.rs" relevance="1.5">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="src/experiments/metrics.rs" relevance="1.5">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="src/experiments/mod.rs" relevance="1.5">
  <reason>Architecturally Significant</reason>
</file>
<file path="src/experiments/position_classifier.rs" relevance="1.5">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="src/experiments/config.rs" relevance="1.5">
  <reason>Architecturally Significant</reason>
</file>
<file path="src/eval_constants.rs" relevance="1.5">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="src/uci.rs" relevance="1.5">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="src/eval.rs" relevance="1.5">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="src/search/mate_search.rs" relevance="1.4">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="src/search/see.rs" relevance="1.4">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="src/search/quiescence.rs" relevance="1.4">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="src/search/koth.rs" relevance="1.4">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="src/search/iterative_deepening.rs" relevance="1.4">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="src/search/mod.rs" relevance="1.4">
  <reason>Architecturally Significant</reason>
</file>
<file path="src/search/alpha_beta.rs" relevance="1.4">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="src/search/history.rs" relevance="1.4">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="src/utils.rs" relevance="1.4">
  <reason>Architecturally Significant</reason>
</file>
<file path="src/main.rs" relevance="1.4">
  <reason>Architecturally Significant</reason>
</file>
<file path="src/agent.rs" relevance="1.4">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="src/magic_bitboard.rs" relevance="1.3">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="scripts/analyze_results.py" relevance="1.3">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="scripts/run_paper_experiments.sh" relevance="1.3">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="scripts/generate_figures.py" relevance="1.3">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="scripts/test.sh" relevance="1.3">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="test_tactical_mcts.rs" relevance="1.3">
  <reason>Hybrid Retrieval</reason>
</file>
<file path=".github/workflows/experiments.yml" relevance="1.2">
  <reason>Hybrid Retrieval</reason>
</file>
<file path=".github/workflows/rust.yml" relevance="1.2">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="tests/property/mod.rs" relevance="1.2">
  <reason>Architecturally Significant</reason>
</file>
<file path="tests/property/invariant_tests.rs" relevance="1.2">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="tests/eval_piece_bonus_tests.rs" relevance="1.2">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="tests/bitboard_tests.rs" relevance="1.2">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="tests/common/mod.rs" relevance="1.2">
  <reason>Architecturally Significant</reason>
</file>
<file path="tests/unit/graphviz_tests.rs" relevance="1.2">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="tests/unit/node_tests.rs" relevance="1.2">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="tests/unit/move_generation_tests.rs" relevance="1.2">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="tests/unit/mod.rs" relevance="1.2">
  <reason>Architecturally Significant</reason>
</file>
<file path="tests/unit/tensor_tests.rs" relevance="1.2">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="tests/unit/search_logger_tests.rs" relevance="1.1">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="tests/unit/board_tests.rs" relevance="1.1">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="tests/unit/selection_tests.rs" relevance="1.1">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="tests/move_generation_tests.rs" relevance="1.1">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="tests/neural_integration_tests.rs" relevance="1.1">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="tests/perft_tests.rs" relevance="1.1">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="tests/regression/mod.rs" relevance="1.1">
  <reason>Architecturally Significant</reason>
</file>
<file path="tests/regression/recent_fixes_tests.rs" relevance="1.1">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="tests/make_move_tests.rs" relevance="1.1">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="tests/mate_portfolio_tests.rs" relevance="1.1">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="tests/repetition_tests.rs" relevance="1.1">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="tests/integration/mod.rs" relevance="1.1">
  <reason>Architecturally Significant</reason>
</file>
<file path="tests/integration/mcts_integration_tests.rs" relevance="1.1">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="tests/mcts_tests.rs" relevance="1.1">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="tests/eval_pawn_structure_tests.rs" relevance="1.1">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="python/export_model.py" relevance="1.0">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="python/train.py" relevance="1.0">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="python/orchestrate.py" relevance="1.0">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="python/model.py" relevance="1.0">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="python/training_pipeline.py" relevance="1.0">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="python/train_chess_ai.py" relevance="1.0">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="python/test_architectures.py" relevance="1.0">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="python/data_collection.py" relevance="1.0">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="run_validation_experiments.sh" relevance="1.0">
  <reason>Hybrid Retrieval</reason>
</file>
</omitted_files>

</repository_context>