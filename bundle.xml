<repository_context>
<metadata>
  <total_tokens>91874</total_tokens>
  <max_tokens>90000</max_tokens>
  <files_included>35</files_included>
  <files_omitted>95</files_omitted>
  <query>Summarize the main functions of this MCTS / alpha-beta hybrid chess engine</query>
  <generated_at>2026-01-04T23:20:07.004902190+00:00</generated_at>
</metadata>

<directory_structure>
  <directory>.cargo</directory>
  <directory>.github/workflows</directory>
  <directory>python</directory>
  <directory>scripts</directory>
  <directory>src</directory>
  <directory>src/benchmarks</directory>
  <directory>src/bin</directory>
  <directory>src/mcts</directory>
  <directory>src/mcts/unit_tests</directory>
  <directory>src/search</directory>
  <directory>src/training</directory>
  <directory>src/tuning</directory>
  <directory>tests</directory>
  <directory>tests/common</directory>
  <directory>tests/integration</directory>
  <directory>tests/property</directory>
  <directory>tests/regression</directory>
  <directory>tests/unit</directory>
</directory_structure>

<dependencies>
  <most_imported>
    <module path="src/bin/see_integration_demo.rs" score="0.0" />
    <module path="src/mcts/inference_server.rs" score="0.0" />
    <module path="src/main.rs" score="0.0" />
    <module path="src/mcts/neural_mcts.rs" score="0.0" />
    <module path="src/boardstack.rs" score="0.0" />
    <module path="tests/neural_integration_tests.rs" score="0.0" />
    <module path="src/search/alpha_beta.rs" score="0.0" />
    <module path="src/magic_bitboard.rs" score="0.0" />
    <module path="src/lib.rs" score="0.0" />
    <module path="src/board.rs" score="0.0" />
  </most_imported>
  <import_relationships>
    <file path="src/neural_net.rs">
      <imports>use crate::board::Board;</imports>
      <imports>use crate::move_types::Move;</imports>
      <imports>use crate::piece_types::{PAWN, KNIGHT, BISHOP, ROOK, QUEEN, KING, WHITE, BLACK};</imports>
      <imports>use crate::tensor::move_to_index;</imports>
      <imports>use tch::{CModule, Tensor, Device, Kind};</imports>
      <imports>use std::path::Path;</imports>
      <imports>use crate::board::Board;</imports>
      <imports>use crate::move_types::Move;</imports>
      <imports>pub use self::real::NeuralNetPolicy;</imports>
      <imports>pub use self::stub::NeuralNetPolicy;</imports>
    </file>
    <file path="src/tuning/data_loader.rs">
      <imports>use super::*;</imports>
      <imports>use std::fs::File;</imports>
      <imports>use std::io::{BufRead, BufReader, Write};</imports>
      <imports>use std::path::Path;</imports>
      <imports>use super::*;</imports>
      <imports>use std::io::Write;</imports>
      <imports>use tempfile::NamedTempFile;</imports>
    </file>
    <file path="src/tuning/mod.rs">
      <imports>use crate::board::Board;</imports>
      <imports>use super::*;</imports>
    </file>
    <file path="src/tuning/texel.rs">
      <imports>use super::*;</imports>
      <imports>use crate::eval::{PestoEval, EvalWeights};</imports>
      <imports>use crate::move_generation::MoveGen;</imports>
      <imports>use std::f64;</imports>
      <imports>use super::*;</imports>
      <imports>use crate::move_generation::MoveGen;</imports>
    </file>
    <file path="src/benchmarks/strength_testing.rs">
      <imports>use crate::board::Board;</imports>
      <imports>use crate::eval::PestoEval;</imports>
      <imports>use crate::move_generation::MoveGen;</imports>
      <imports>use crate::move_types::Move;</imports>
      <imports>use crate::mcts::neural_mcts::neural_mcts_search;</imports>
      <imports>use crate::neural_net::NeuralNetPolicy;</imports>
      <imports>use std::collections::HashMap;</imports>
      <imports>use std::time::{Duration, Instant};</imports>
      <imports>use std::fmt;</imports>
    </file>
    <file path="src/benchmarks/elo_tournament.rs">
      <imports>use crate::board::Board;</imports>
      <imports>use crate::eval::PestoEval;</imports>
      <imports>use crate::move_generation::MoveGen;</imports>
      <imports>use crate::move_types::Move;</imports>
      <imports>use crate::mcts::tactical_mcts::{tactical_mcts_search, TacticalMctsConfig};</imports>
      <imports>use crate::search::iterative_deepening::iterative_deepening_ab_search;</imports>
      <imports>use crate::transposition::TranspositionTable;</imports>
      <imports>use crate::mcts::inference_server::InferenceServer;</imports>
      <imports>use crate::boardstack::BoardStack;</imports>
      <imports>use std::sync::Arc;</imports>
      <imports>use std::time::Duration;</imports>
      <imports>use std::collections::HashMap;</imports>
      <imports>use rand::prelude::*;</imports>
      <imports>use rand::rngs::StdRng;</imports>
    </file>
    <file path="src/benchmarks/mod.rs">
      <imports>use crate::boardstack::BoardStack;</imports>
      <imports>use crate::move_types::Move;</imports>
      <imports>use crate::move_generation::MoveGen;</imports>
      <imports>use crate::eval::PestoEval;</imports>
      <imports>use crate::agent::{Agent, SimpleAgent, HumanlikeAgent};</imports>
      <imports>use std::time::{Duration, Instant};</imports>
    </file>
    <file path="src/benchmarks/performance.rs">
      <imports>use super::*;</imports>
      <imports>use crate::benchmarks::tactical_suite::{run_tactical_benchmark, get_tactical_test_suite};</imports>
      <imports>use std::time::Duration;</imports>
      <imports>use super::*;</imports>
    </file>
    <file path="src/benchmarks/elo_estimation.rs">
      <imports>use std::collections::HashMap;</imports>
      <imports>use crate::benchmarks::strength_testing::{EngineVariant, PositionResult};</imports>
    </file>
    <file path="src/benchmarks/tactical_suite.rs">
      <imports>use super::*;</imports>
      <imports>use crate::move_types::Move;</imports>
      <imports>use super::*;</imports>
      <imports>use crate::board::Board;</imports>
    </file>
    <file path="src/board_utils.rs">
      <imports>use crate::piece_types::{BLACK, WHITE};</imports>
      <imports>use lazy_static::lazy_static;</imports>
    </file>
    <file path="src/bin/tactical_cache_demo.rs">
      <imports>use kingfisher::board::Board;</imports>
      <imports>use kingfisher::move_generation::MoveGen;</imports>
      <imports>use kingfisher::mcts::tactical::{identify_tactical_moves, get_tactical_cache_stats, clear_tactical_cache};</imports>
      <imports>use std::time::Instant;</imports>
    </file>
    <file path="src/bin/tactical_profiler.rs">
      <imports>use kingfisher::board::Board;</imports>
      <imports>use kingfisher::eval::PestoEval;</imports>
      <imports>use kingfisher::move_generation::MoveGen;</imports>
      <imports>use kingfisher::mcts::{tactical_mcts_search, TacticalMctsConfig};</imports>
      <imports>use std::time::{Duration, Instant};</imports>
    </file>
    <file path="src/bin/neural_integration_demo.rs">
      <imports>use kingfisher::board::Board;</imports>
      <imports>use kingfisher::eval::PestoEval;</imports>
      <imports>use kingfisher::move_generation::MoveGen;</imports>
      <imports>use kingfisher::mcts::{tactical_mcts_search, TacticalMctsConfig};</imports>
      <imports>use kingfisher::mcts::inference_server::InferenceServer;</imports>
      <imports>use kingfisher::neural_net::NeuralNetPolicy;</imports>
      <imports>use std::sync::Arc;</imports>
      <imports>use std::time::{Duration, Instant};</imports>
    </file>
    <file path="src/bin/generate_training_data.rs">
      <imports>use kingfisher::training::{TrainingDataGenerator, ParsedGame};</imports>
      <imports>use kingfisher::move_types::Move;</imports>
    </file>
    <file path="src/bin/benchmark.rs">
      <imports>use kingfisher::benchmarks::performance::{run_performance_comparison, mate_speed_benchmark};</imports>
      <imports>use kingfisher::benchmarks::tactical_suite::run_tactical_benchmark;</imports>
      <imports>use kingfisher::benchmarks::{create_simple_agent, create_humanlike_agent};</imports>
      <imports>use std::env;</imports>
      <imports>use std::time::Duration;</imports>
      <imports>use super::*;</imports>
      <imports>use kingfisher::benchmarks::tactical_suite::get_tactical_test_suite;</imports>
    </file>
    <file path="src/bin/mcts_inspector.rs">
      <imports>use std::env;</imports>
      <imports>use std::fs::File;</imports>
      <imports>use std::io::Write;</imports>
      <imports>use std::time::Duration;</imports>
      <imports>use std::sync::Arc;</imports>
      <imports>use kingfisher::board::Board;</imports>
      <imports>use kingfisher::eval::PestoEval;</imports>
      <imports>use kingfisher::mcts::tactical_mcts::{tactical_mcts_search, TacticalMctsConfig};</imports>
      <imports>use kingfisher::mcts::inference_server::InferenceServer;</imports>
      <imports>use kingfisher::move_generation::MoveGen;</imports>
    </file>
    <file path="src/bin/quick_test.rs">
      <imports>use kingfisher::benchmarks::tactical_suite::get_tactical_test_suite;</imports>
      <imports>use kingfisher::benchmarks::create_simple_agent;</imports>
      <imports>use kingfisher::boardstack::BoardStack;</imports>
      <imports>use kingfisher::agent::Agent;</imports>
      <imports>use std::time::Instant;</imports>
    </file>
    <file path="src/bin/verbose_search.rs">
      <imports>use std::env;</imports>
      <imports>use std::sync::Arc;</imports>
      <imports>use std::time::Duration;</imports>
      <imports>use kingfisher::board::Board;</imports>
      <imports>use kingfisher::eval::PestoEval;</imports>
      <imports>use kingfisher::mcts::tactical_mcts::{tactical_mcts_search, TacticalMctsConfig};</imports>
      <imports>use kingfisher::mcts::inference_server::InferenceServer;</imports>
      <imports>use kingfisher::mcts::search_logger::{SearchLogger, Verbosity};</imports>
      <imports>use kingfisher::move_generation::MoveGen;</imports>
    </file>
    <file path="src/bin/verify_features.rs">
      <imports>use kingfisher::board::Board;</imports>
      <imports>use kingfisher::neural_net::NeuralNetPolicy;</imports>
      <imports>use kingfisher::piece_types::{PAWN, KNIGHT, BISHOP, ROOK, QUEEN, KING};</imports>
    </file>
    <file path="src/bin/texel_tune.rs">
      <imports>use kingfisher::tuning::texel::{TexelTuner, create_test_dataset};</imports>
      <imports>use kingfisher::tuning::data_loader::DataLoader;</imports>
      <imports>use kingfisher::eval_constants::EvalWeights;</imports>
      <imports>use kingfisher::move_generation::MoveGen;</imports>
    </file>
    <file path="src/bin/elo_tournament.rs">
      <imports>use kingfisher::benchmarks::elo_tournament::{
    EloTournament,
    TournamentConfig,
    TournamentEngine,
};</imports>
      <imports>use std::env;</imports>
      <imports>use std::fs::File;</imports>
      <imports>use std::io::Write;</imports>
    </file>
    <file path="src/bin/see_integration_demo.rs">
      <imports>use kingfisher::board::Board;</imports>
      <imports>use kingfisher::move_generation::MoveGen;</imports>
      <imports>use kingfisher::mcts::tactical::identify_tactical_moves;</imports>
      <imports>use kingfisher::search::see;</imports>
      <imports>use kingfisher::move_types::Move;</imports>
    </file>
    <file path="src/bin/self_play.rs">
      <imports>use kingfisher::board::Board;</imports>
      <imports>use kingfisher::eval::PestoEval;</imports>
      <imports>use kingfisher::move_generation::MoveGen;</imports>
      <imports>use kingfisher::mcts::{tactical_mcts_search_for_training, TacticalMctsConfig};</imports>
      <imports>use kingfisher::neural_net::NeuralNetPolicy;</imports>
      <imports>use kingfisher::piece_types::{PAWN, KNIGHT, BISHOP, ROOK, QUEEN, KING, WHITE, BLACK};</imports>
      <imports>use kingfisher::tensor::move_to_index;</imports>
      <imports>use std::fs::File;</imports>
      <imports>use std::io::Write;</imports>
      <imports>use std::sync::Mutex;</imports>
      <imports>use std::time::{Duration, SystemTime, UNIX_EPOCH};</imports>
      <imports>use rayon::prelude::*;</imports>
    </file>
    <file path="src/bin/mate_search_tt_demo.rs">
      <imports>use kingfisher::board::Board;</imports>
      <imports>use kingfisher::eval::PestoEval;</imports>
      <imports>use kingfisher::move_generation::MoveGen;</imports>
      <imports>use kingfisher::mcts::{tactical_mcts_search_with_tt, TacticalMctsConfig};</imports>
      <imports>use kingfisher::transposition::TranspositionTable;</imports>
      <imports>use std::time::{Duration, Instant};</imports>
    </file>
    <file path="src/bin/strength_test.rs">
      <imports>use kingfisher::benchmarks::strength_testing::{StrengthTester, StrengthTestConfig};</imports>
      <imports>use std::env;</imports>
    </file>
    <file path="src/bin/verify_tactical_graft.rs">
      <imports>use kingfisher::board::Board;</imports>
      <imports>use kingfisher::move_generation::MoveGen;</imports>
      <imports>use kingfisher::eval::PestoEval;</imports>
      <imports>use kingfisher::mcts::TacticalMctsConfig;</imports>
      <imports>use kingfisher::mcts::tactical_mcts::tactical_mcts_search;</imports>
      <imports>use std::time::Duration;</imports>
    </file>
    <file path="src/bin/benchmark_gates.rs">
      <imports>use kingfisher::board::Board;</imports>
      <imports>use kingfisher::move_generation::MoveGen;</imports>
      <imports>use kingfisher::eval::PestoEval;</imports>
      <imports>use kingfisher::search::koth_center_in_3;</imports>
      <imports>use kingfisher::mcts::tactical_mcts::{tactical_mcts_search, TacticalMctsConfig};</imports>
      <imports>use kingfisher::search::mate_search;</imports>
      <imports>use kingfisher::boardstack::BoardStack;</imports>
      <imports>use std::time::Instant;</imports>
    </file>
    <file path="src/bin/tactical_benchmark.rs">
      <imports>use kingfisher::benchmarks::tactical_suite::{get_tactical_test_suite, TacticalPosition};</imports>
      <imports>use kingfisher::board::Board;</imports>
      <imports>use kingfisher::eval::PestoEval;</imports>
      <imports>use kingfisher::move_generation::MoveGen;</imports>
      <imports>use kingfisher::mcts::{tactical_mcts_search, TacticalMctsConfig, mcts_pesto_search};</imports>
      <imports>use std::time::{Duration, Instant};</imports>
    </file>
    <file path="src/tensor.rs">
      <imports>use crate::move_types::Move;</imports>
      <imports>use crate::piece_types::{KNIGHT, BISHOP, ROOK, QUEEN};</imports>
      <imports>use super::*;</imports>
      <imports>use crate::piece_types::{QUEEN, ROOK, KNIGHT};</imports>
    </file>
    <file path="src/egtb.rs">
      <imports>use crate::board::Board;</imports>
      <imports>use crate::move_types::Move;</imports>
      <imports>use shakmaty::Board as ShakmatyBoard;</imports>
      <imports>use shakmaty_syzygy::{Wdl, Dtz};</imports>
      <imports>use super::*;</imports>
      <imports>use crate::board::Board;</imports>
      <imports>use shakmaty::Chess;</imports>
    </file>
    <file path="src/make_move.rs">
      <imports>use crate::board::Board;</imports>
      <imports>use crate::board_utils::sq_ind_to_bit;</imports>
      <imports>use crate::move_types::Move;</imports>
      <imports>use crate::piece_types::{BLACK, KING, PAWN, ROOK, WHITE};</imports>
    </file>
    <file path="src/training/mod.rs">
      <imports>use crate::board::Board;</imports>
      <imports>use crate::eval::PestoEval;</imports>
      <imports>use crate::move_generation::MoveGen;</imports>
      <imports>use crate::move_types::Move;</imports>
      <imports>use std::collections::HashMap;</imports>
      <imports>use std::fs::File;</imports>
      <imports>use std::io::{Write, BufRead, BufReader};</imports>
      <imports>use std::path::Path;</imports>
      <imports>use super::*;</imports>
    </file>
    <file path="src/hash.rs">
      <imports>use crate::bits::bits;</imports>
      <imports>use crate::board::Board;</imports>
      <imports>use crate::boardstack::BoardStack;</imports>
      <imports>use crate::piece_types::{BISHOP, BLACK, KING, KNIGHT, PAWN, QUEEN, ROOK, WHITE};</imports>
      <imports>use lazy_static::lazy_static;</imports>
      <imports>use rand::Rng;</imports>
    </file>
    <file path="src/mcts/search_logger.rs">
      <imports>use crate::board::Board;</imports>
      <imports>use crate::move_types::Move;</imports>
      <imports>use crate::mcts::node::{MctsNode, NodeOrigin};</imports>
      <imports>use crate::mcts::tactical::TacticalMove;</imports>
      <imports>use std::cell::RefCell;</imports>
      <imports>use std::fmt::Write as FmtWrite;</imports>
      <imports>use std::fs::File;</imports>
      <imports>use std::io::{self, Write};</imports>
      <imports>use std::rc::Rc;</imports>
      <imports>use std::sync::atomic::{AtomicBool, AtomicUsize, AtomicU32, Ordering};</imports>
      <imports>use std::sync::Mutex;</imports>
      <imports>use std::time::Instant;</imports>
    </file>
    <file path="src/mcts/nn_counter.rs">
      <imports>use crate::neural_net::NeuralNetPolicy;</imports>
      <imports>use crate::board::Board;</imports>
      <imports>use std::cell::RefCell;</imports>
      <imports>use std::rc::Rc;</imports>
      <imports>use super::*;</imports>
      <imports>use crate::board::Board;</imports>
    </file>
    <file path="src/mcts/neural_mcts.rs">
      <imports>use crate::board::Board;</imports>
      <imports>use crate::eval::PestoEval;</imports>
      <imports>use crate::move_generation::MoveGen;</imports>
      <imports>use crate::move_types::Move;</imports>
      <imports>use crate::neural_net::NeuralNetPolicy;</imports>
      <imports>use crate::mcts::tactical_mcts::{tactical_mcts_search, TacticalMctsConfig};</imports>
      <imports>use std::time::Duration;</imports>
    </file>
    <file path="src/mcts/policy.rs">
      <imports>use crate::board::Board;</imports>
      <imports>use crate::move_types::Move;</imports>
      <imports>use std::collections::HashMap;</imports>
    </file>
    <file path="src/mcts/tactical.rs">
      <imports>use crate::board::Board;</imports>
      <imports>use crate::move_generation::MoveGen;</imports>
      <imports>use crate::move_types::Move;</imports>
      <imports>use crate::piece_types::{PAWN, KNIGHT, BISHOP, ROOK, QUEEN, KING};</imports>
      <imports>use crate::search::see;</imports>
      <imports>use std::collections::{HashMap, HashSet};</imports>
      <imports>use std::cell::RefCell;</imports>
      <imports>use super::*;</imports>
      <imports>use crate::board::Board;</imports>
    </file>
    <file path="src/mcts/tactical_mcts.rs">
      <imports>use crate::board::Board;</imports>
      <imports>use crate::boardstack::BoardStack;</imports>
      <imports>use crate::eval::{PestoEval, extrapolate_value};</imports>
      <imports>use crate::mcts::node::{MctsNode, NodeOrigin};</imports>
      <imports>use crate::mcts::selection::select_child_with_tactical_priority;</imports>
      <imports>use crate::mcts::inference_server::InferenceServer;</imports>
      <imports>use crate::mcts::search_logger::{SearchLogger, GateReason};</imports>
      <imports>use crate::move_generation::MoveGen;</imports>
      <imports>use crate::move_types::Move;</imports>
      <imports>use crate::neural_net::NeuralNetPolicy;</imports>
      <imports>use crate::search::mate_search;</imports>
      <imports>use crate::search::koth_center_in_3;</imports>
      <imports>use crate::search::quiescence_search_tactical;</imports>
      <imports>use crate::transposition::TranspositionTable;</imports>
      <imports>use std::cell::RefCell;</imports>
      <imports>use std::rc::Rc;</imports>
      <imports>use std::sync::Arc;</imports>
      <imports>use std::time::{Duration, Instant};</imports>
    </file>
    <file path="src/mcts/mod.rs">
      <imports>use crate::board::Board;</imports>
      <imports>use crate::eval::PestoEval;</imports>
      <imports>use crate::move_generation::MoveGen;</imports>
      <imports>use crate::move_types::Move;</imports>
      <imports>use std::time::Duration;</imports>
      <imports>pub use self::node::{MctsNode, MoveCategory, NodeOrigin, select_leaf_for_expansion};</imports>
      <imports>pub use self::tactical_mcts::{
    tactical_mcts_search, tactical_mcts_search_for_training, tactical_mcts_search_with_tt,
    TacticalMctsConfig, TacticalMctsStats,
};</imports>
      <imports>pub use self::neural_mcts::neural_mcts_search;</imports>
      <imports>pub use self::inference_server::InferenceServer;</imports>
      <imports>pub use self::search_logger::{SearchLogger, Verbosity, GateReason, SelectionReason};</imports>
    </file>
    <file path="src/mcts/inference_server.rs">
      <imports>use crate::board::Board;</imports>
      <imports>use crate::neural_net::NeuralNetPolicy;</imports>
      <imports>use crossbeam_channel::{unbounded, Receiver, Sender};</imports>
      <imports>use std::thread;</imports>
      <imports>use std::time::Duration;</imports>
      <imports>use rand::Rng;</imports>
    </file>
    <file path="src/mcts/node.rs">
      <imports>use crate::board::Board;</imports>
      <imports>use crate::move_generation::MoveGen;</imports>
      <imports>use crate::move_types::Move;</imports>
      <imports>use crate::mcts::tactical::TacticalMove;</imports>
      <imports>use std::cell::RefCell;</imports>
      <imports>use std::collections::{HashMap, HashSet};</imports>
      <imports>use std::f64;</imports>
      <imports>use std::rc::{Rc, Weak};</imports>
    </file>
    <file path="src/mcts/selection.rs">
      <imports>use crate::move_generation::MoveGen;</imports>
      <imports>use crate::move_types::Move;</imports>
      <imports>use crate::mcts::node::MctsNode;</imports>
      <imports>use crate::mcts::tactical::identify_tactical_moves;</imports>
      <imports>use crate::mcts::tactical_mcts::{TacticalMctsStats, TacticalMctsConfig};</imports>
      <imports>use crate::mcts::search_logger::{SearchLogger, SelectionReason};</imports>
      <imports>use crate::neural_net::NeuralNetPolicy;</imports>
      <imports>use std::cell::RefCell;</imports>
      <imports>use std::rc::Rc;</imports>
      <imports>use std::sync::Arc;</imports>
      <imports>use super::*;</imports>
      <imports>use crate::board::Board;</imports>
    </file>
    <file path="src/mcts/simulation.rs">
      <imports>use crate::board::Board;</imports>
      <imports>use crate::move_generation::MoveGen;</imports>
      <imports>use rand::seq::SliceRandom;</imports>
    </file>
    <file path="src/mcts/unit_tests/tactical_tests.rs">
      <imports>use crate::board::Board;</imports>
      <imports>use crate::move_generation::MoveGen;</imports>
      <imports>use crate::move_types::Move;</imports>
      <imports>use crate::mcts::tactical::{identify_tactical_moves, TacticalMove, calculate_mvv_lva};</imports>
      <imports>use super::*;</imports>
    </file>
    <file path="src/mcts/unit_tests/mcts_integration_tests.rs">
      <imports>use crate::board::Board;</imports>
      <imports>use crate::eval::PestoEval;</imports>
      <imports>use crate::move_generation::MoveGen;</imports>
      <imports>use crate::move_types::Move;</imports>
      <imports>use crate::mcts::{tactical_mcts_search, TacticalMctsConfig};</imports>
      <imports>use std::time::Duration;</imports>
      <imports>use super::*;</imports>
    </file>
    <file path="src/mcts/unit_tests/selection_tests.rs">
      <imports>use crate::board::Board;</imports>
      <imports>use crate::move_generation::MoveGen;</imports>
      <imports>use crate::move_types::Move;</imports>
      <imports>use crate::mcts::node::MctsNode;</imports>
      <imports>use crate::mcts::selection::{select_child_with_tactical_priority, get_tactical_statistics};</imports>
      <imports>use crate::mcts::tactical_mcts::{TacticalMctsStats, TacticalMctsConfig};</imports>
      <imports>use std::cell::RefCell;</imports>
      <imports>use std::rc::Rc;</imports>
      <imports>use std::time::Duration;</imports>
      <imports>use super::*;</imports>
    </file>
    <file path="src/move_types.rs">
      <imports>use crate::board_utils::sq_ind_to_algebraic;</imports>
      <imports>use crate::piece_types::{BISHOP, KNIGHT, QUEEN, ROOK};</imports>
      <imports>use std::fmt;</imports>
      <imports>use std::hash::{Hash, Hasher};</imports>
      <imports>use super::*;</imports>
    </file>
    <file path="src/arena.rs">
      <imports>use crate::agent;</imports>
      <imports>use crate::boardstack::BoardStack;</imports>
    </file>
    <file path="src/boardstack.rs">
      <imports>use crate::board::Board;</imports>
      <imports>use crate::move_types::Move;</imports>
      <imports>use std::collections::{HashMap, VecDeque};</imports>
    </file>
    <file path="src/transposition.rs">
      <imports>use crate::board::Board;</imports>
      <imports>use crate::move_types::Move;</imports>
      <imports>use std::collections::HashMap;</imports>
    </file>
    <file path="src/board.rs">
      <imports>use crate::board_utils::{algebraic_to_sq_ind, bit_to_sq_ind, coords_to_sq_ind, sq_ind_to_bit};</imports>
      <imports>use crate::move_generation::MoveGen;</imports>
      <imports>use crate::move_types::CastlingRights;</imports>
      <imports>use crate::piece_types::{BISHOP, BLACK, KING, KNIGHT, PAWN, QUEEN, ROOK, WHITE};</imports>
      <imports>use crate::bits::popcnt;</imports>
    </file>
    <file path="src/move_generation.rs">
      <imports>use crate::bits::bits;</imports>
      <imports>use crate::board::Board;</imports>
      <imports>use crate::board_utils::sq_ind_to_bit;</imports>
      <imports>use crate::magic_bitboard::{
    append_promotions, init_bishop_moves, init_king_moves, init_knight_moves,
    init_pawn_captures_promotions, init_pawn_moves, init_rook_moves,
};</imports>
      <imports>use crate::magic_constants::{B_BITS, B_MAGICS, B_MASKS, R_BITS, R_MAGICS, R_MASKS};</imports>
      <imports>use crate::move_types::Move;</imports>
      <imports>use crate::eval::PestoEval;</imports>
      <imports>use crate::piece_types::{BISHOP, BLACK, KING, KNIGHT, PAWN, QUEEN, ROOK, WHITE};</imports>
      <imports>use crate::search::HistoryTable;</imports>
    </file>
    <file path="src/uci.rs">
      <imports>use crate::agent::{Agent, HumanlikeAgent, SimpleAgent};</imports>
      <imports>use crate::boardstack::BoardStack;</imports>
      <imports>use crate::egtb::EgtbProber;</imports>
      <imports>use crate::eval::PestoEval;</imports>
      <imports>use crate::move_generation::MoveGen;</imports>
      <imports>use lazy_static::lazy_static;</imports>
      <imports>use crate::move_types::Move;</imports>
      <imports>use std::io::{self, BufRead, Write};</imports>
      <imports>use std::time::{Duration, Instant};</imports>
      <imports>use super::*;</imports>
      <imports>use crate::board::Board;</imports>
    </file>
    <file path="src/eval.rs">
      <imports>use crate::bits::{bits, popcnt};</imports>
      <imports>use crate::board::Board;</imports>
      <imports>use crate::board_utils::flip_sq_ind_vertically;</imports>
      <imports>use crate::board_utils::{
    get_adjacent_files_mask, get_file_mask, get_front_span_mask, get_king_attack_zone_mask,
    get_king_shield_zone_mask, get_passed_pawn_mask, get_rank_mask, sq_ind_to_bit, sq_to_file,
    sq_to_rank,
};</imports>
      <imports>pub use crate::eval_constants::EvalWeights;</imports>
      <imports>use crate::eval_constants::{
    EG_PESTO_TABLE, EG_VALUE, GAMEPHASE_INC, MG_PESTO_TABLE, MG_VALUE,
};</imports>
      <imports>use crate::move_generation::MoveGen;</imports>
      <imports>use crate::piece_types::{BISHOP, BLACK, KING, KNIGHT, PAWN, QUEEN, ROOK, WHITE};</imports>
      <imports>use std::cmp::min;</imports>
    </file>
    <file path="src/search/mate_search.rs">
      <imports>use crate::boardstack::BoardStack;</imports>
      <imports>use crate::move_generation::MoveGen;</imports>
      <imports>use crate::move_types::Move;</imports>
      <imports>use std::sync::atomic::{AtomicBool, AtomicUsize, Ordering};</imports>
      <imports>use std::sync::{Arc, Mutex};</imports>
    </file>
    <file path="src/search/see.rs">
      <imports>use crate::board::Board;</imports>
      <imports>use crate::move_generation::MoveGen;</imports>
      <imports>use crate::piece_types::{KING, PAWN};</imports>
      <imports>use std::cmp::max;</imports>
    </file>
    <file path="src/search/quiescence.rs">
      <imports>use super::see::see;</imports>
      <imports>use crate::boardstack::BoardStack;</imports>
      <imports>use crate::eval::PestoEval;</imports>
      <imports>use crate::move_generation::MoveGen;</imports>
      <imports>use crate::move_types::Move;</imports>
      <imports>use std::time::{Duration, Instant};</imports>
    </file>
    <file path="src/search/koth.rs">
      <imports>use crate::board::{Board, KOTH_CENTER};</imports>
      <imports>use crate::move_generation::MoveGen;</imports>
      <imports>use crate::piece_types::{KING, WHITE, BLACK};</imports>
    </file>
    <file path="src/search/iterative_deepening.rs">
      <imports>use super::alpha_beta::alpha_beta_search;</imports>
      <imports>use super::history::HistoryTable;</imports>
      <imports>use super::history::MAX_PLY;</imports>
      <imports>use crate::boardstack::BoardStack;</imports>
      <imports>use crate::eval::PestoEval;</imports>
      <imports>use crate::move_generation::MoveGen;</imports>
      <imports>use crate::move_types::{Move, NULL_MOVE};</imports>
      <imports>use crate::transposition::TranspositionTable;</imports>
      <imports>use crate::utils::print_move;</imports>
      <imports>use std::time::{Duration, Instant};</imports>
    </file>
    <file path="src/search/mod.rs">
      <imports>pub use history::{HistoryTable, MAX_PLY};</imports>
      <imports>pub use mate_search::mate_search;</imports>
      <imports>pub use quiescence::{quiescence_search, quiescence_search_tactical};</imports>
      <imports>pub use iterative_deepening::{iterative_deepening_ab_search, aspiration_window_ab_search};</imports>
      <imports>pub use koth::koth_center_in_3;</imports>
      <imports>pub use see::see;</imports>
    </file>
    <file path="src/search/alpha_beta.rs">
      <imports>use super::history::HistoryTable;</imports>
      <imports>use super::history::MAX_PLY;</imports>
      <imports>use super::quiescence::quiescence_search;</imports>
      <imports>use crate::board::Board;</imports>
      <imports>use crate::boardstack::BoardStack;</imports>
      <imports>use crate::eval::PestoEval;</imports>
      <imports>use crate::move_generation::MoveGen;</imports>
      <imports>use crate::move_types::{Move, NULL_MOVE};</imports>
      <imports>use crate::transposition::TranspositionTable;</imports>
      <imports>use std::time::{Duration, Instant};</imports>
    </file>
    <file path="src/search/history.rs">
      <imports>use crate::move_types::Move;</imports>
    </file>
    <file path="src/utils.rs">
      <imports>use crate::board_utils::{coords_to_sq_ind, sq_ind_to_algebraic, sq_ind_to_bit};</imports>
      <imports>use crate::move_types::Move;</imports>
      <imports>use crate::piece_types::{BISHOP, KNIGHT, QUEEN, ROOK};</imports>
    </file>
    <file path="src/main.rs">
      <imports>use kingfisher::agent::SimpleAgent;</imports>
      <imports>use kingfisher::arena::Match;</imports>
      <imports>use kingfisher::eval::PestoEval;</imports>
      <imports>use kingfisher::move_generation::MoveGen;</imports>
      <imports>use kingfisher::uci::UCIEngine;</imports>
    </file>
    <file path="src/agent.rs">
      <imports>use crate::boardstack::BoardStack;</imports>
      <imports>use crate::eval::PestoEval;</imports>
      <imports>use crate::move_generation::MoveGen;</imports>
      <imports>use crate::move_types::Move;</imports>
      <imports>use crate::mcts::tactical_mcts::{tactical_mcts_search, TacticalMctsConfig};</imports>
      <imports>use crate::mcts::node::MctsNode;</imports>
      <imports>use crate::search::mate_search;</imports>
      <imports>use crate::egtb::EgtbProber;</imports>
      <imports>use std::cell::RefCell;</imports>
      <imports>use std::rc::Rc;</imports>
      <imports>use std::time::Duration;</imports>
    </file>
    <file path="src/magic_bitboard.rs">
      <imports>use crate::bits::bits;</imports>
      <imports>use crate::board_utils::sq_ind_to_bit;</imports>
      <imports>use crate::magic_constants::{B_BITS, B_MASKS, R_BITS, R_MASKS};</imports>
      <imports>use crate::move_types::Move;</imports>
      <imports>use crate::piece_types::{BISHOP, KNIGHT, QUEEN, ROOK};</imports>
    </file>
    <file path="scripts/generate_figures.py">
      <imports>import pandas as pd</imports>
      <imports>import matplotlib.pyplot as plt</imports>
      <imports>import seaborn as sns</imports>
      <imports>import sys</imports>
      <imports>import os</imports>
    </file>
    <file path="test_tactical_mcts.rs">
      <imports>use kingfisher::board::Board;</imports>
      <imports>use kingfisher::eval::PestoEval;</imports>
      <imports>use kingfisher::move_generation::MoveGen;</imports>
      <imports>use kingfisher::mcts::{tactical_mcts_search, TacticalMctsConfig, print_search_stats};</imports>
      <imports>use kingfisher::neural_net::NeuralNetPolicy;</imports>
      <imports>use std::time::Duration;</imports>
    </file>
    <file path="tests/property/invariant_tests.rs">
      <imports>use kingfisher::board::Board;</imports>
      <imports>use kingfisher::move_generation::MoveGen;</imports>
      <imports>use kingfisher::mcts::node::MctsNode;</imports>
      <imports>use kingfisher::piece_types::{WHITE, BLACK, KING};</imports>
      <imports>use proptest::prelude::*;</imports>
      <imports>use crate::common::positions;</imports>
      <imports>use super::*;</imports>
      <imports>use kingfisher::neural_net::NeuralNetPolicy;</imports>
      <imports>use tch::Tensor;</imports>
    </file>
    <file path="tests/eval_piece_bonus_tests.rs">
      <imports>use kingfisher::board::Board;</imports>
      <imports>use kingfisher::board_utils;</imports>
      <imports>use kingfisher::eval::PestoEval;</imports>
      <imports>use kingfisher::eval_constants::{KING_SAFETY_PAWN_SHIELD_BONUS, TWO_BISHOPS_BONUS};</imports>
      <imports>use kingfisher::piece_types::{BISHOP, BLACK, KNIGHT, PAWN, WHITE};</imports>
      <imports>use kingfisher::move_generation::MoveGen;</imports>
    </file>
    <file path="tests/bitboard_tests.rs">
      <imports>use kingfisher::board::Board;</imports>
      <imports>use kingfisher::boardstack::BoardStack;</imports>
      <imports>use kingfisher::move_generation::MoveGen;</imports>
      <imports>use kingfisher::move_types::Move;</imports>
      <imports>use kingfisher::piece_types::{BLACK, KING, KNIGHT, PAWN, ROOK, WHITE};</imports>
    </file>
    <file path="tests/common/mod.rs">
      <imports>use kingfisher::board::Board;</imports>
      <imports>use kingfisher::move_generation::MoveGen;</imports>
      <imports>use kingfisher::move_types::Move;</imports>
      <imports>use std::collections::HashSet;</imports>
    </file>
    <file path="tests/unit/graphviz_tests.rs">
      <imports>use kingfisher::board::Board;</imports>
      <imports>use kingfisher::eval::PestoEval;</imports>
      <imports>use kingfisher::mcts::node::{MctsNode, NodeOrigin};</imports>
      <imports>use kingfisher::mcts::tactical_mcts::{tactical_mcts_search, TacticalMctsConfig};</imports>
      <imports>use kingfisher::mcts::inference_server::InferenceServer;</imports>
      <imports>use kingfisher::move_generation::MoveGen;</imports>
      <imports>use std::sync::Arc;</imports>
      <imports>use std::time::Duration;</imports>
      <imports>use super::common::positions;</imports>
    </file>
    <file path="tests/unit/node_tests.rs">
      <imports>use kingfisher::mcts::node::MctsNode;</imports>
      <imports>use kingfisher::board::Board;</imports>
      <imports>use kingfisher::move_generation::MoveGen;</imports>
      <imports>use crate::common::{board_from_fen, assert_in_tanh_domain, positions};</imports>
    </file>
    <file path="tests/unit/move_generation_tests.rs">
      <imports>use kingfisher::board::Board;</imports>
      <imports>use kingfisher::move_generation::MoveGen;</imports>
      <imports>use kingfisher::move_types::Move;</imports>
      <imports>use crate::common::{board_from_fen, legal_moves_set, positions, generate_legal_moves};</imports>
    </file>
    <file path="tests/unit/tensor_tests.rs">
      <imports>use kingfisher::neural_net::NeuralNetPolicy;</imports>
      <imports>use kingfisher::board::Board;</imports>
      <imports>use kingfisher::piece_types::{WHITE, BLACK, KING};</imports>
      <imports>use crate::common::{board_from_fen, positions};</imports>
      <imports>use tch::Tensor;</imports>
    </file>
    <file path="tests/unit/search_logger_tests.rs">
      <imports>use kingfisher::mcts::search_logger::{
    SearchLogger, Verbosity, GateReason, SelectionReason, LogSink,
};</imports>
      <imports>use kingfisher::move_types::Move;</imports>
    </file>
    <file path="tests/unit/board_tests.rs">
      <imports>use kingfisher::board::{Board, KOTH_CENTER};</imports>
      <imports>use kingfisher::move_generation::MoveGen;</imports>
      <imports>use kingfisher::piece_types::{WHITE, BLACK, PAWN, KING};</imports>
      <imports>use crate::common::{board_from_fen, positions};</imports>
    </file>
    <file path="tests/unit/selection_tests.rs">
      <imports>use kingfisher::mcts::selection::calculate_ucb_value;</imports>
      <imports>use kingfisher::mcts::node::MctsNode;</imports>
      <imports>use kingfisher::board::Board;</imports>
      <imports>use kingfisher::move_generation::MoveGen;</imports>
      <imports>use crate::common::assert_approx_eq;</imports>
    </file>
    <file path="tests/move_generation_tests.rs">
      <imports>use kingfisher::board::Board;</imports>
      <imports>use kingfisher::boardstack::BoardStack;</imports>
      <imports>use kingfisher::eval::PestoEval;</imports>
      <imports>use kingfisher::move_generation::MoveGen;</imports>
      <imports>use kingfisher::move_types::Move;</imports>
      <imports>use kingfisher::piece_types::QUEEN;</imports>
    </file>
    <file path="tests/neural_integration_tests.rs">
      <imports>use kingfisher::board::Board;</imports>
      <imports>use kingfisher::eval::PestoEval;</imports>
      <imports>use kingfisher::mcts::neural_mcts_search;</imports>
      <imports>use kingfisher::move_generation::MoveGen;</imports>
      <imports>use kingfisher::neural_net::NeuralNetPolicy;</imports>
      <imports>use std::time::Duration;</imports>
    </file>
    <file path="tests/perft_tests.rs">
      <imports>use kingfisher::board::Board;</imports>
      <imports>use kingfisher::move_generation::MoveGen;</imports>
      <imports>use kingfisher::utils::print_move;</imports>
    </file>
    <file path="tests/regression/recent_fixes_tests.rs">
      <imports>use kingfisher::board::Board;</imports>
      <imports>use kingfisher::move_generation::MoveGen;</imports>
      <imports>use kingfisher::mcts::node::MctsNode;</imports>
      <imports>use kingfisher::mcts::inference_server::InferenceServer;</imports>
      <imports>use kingfisher::mcts::tactical_mcts::{tactical_mcts_search, TacticalMctsConfig, TacticalMctsStats};</imports>
      <imports>use kingfisher::mcts::selection::select_child_with_tactical_priority;</imports>
      <imports>use kingfisher::move_types::Move;</imports>
      <imports>use kingfisher::eval::PestoEval;</imports>
      <imports>use kingfisher::neural_net::NeuralNetPolicy;</imports>
      <imports>use crate::common::{board_from_fen, positions};</imports>
      <imports>use std::time::Duration;</imports>
      <imports>use std::rc::Rc;</imports>
      <imports>use std::cell::RefCell;</imports>
      <imports>use std::sync::Arc;</imports>
      <imports>use super::*;</imports>
      <imports>use super::*;</imports>
      <imports>use super::*;</imports>
      <imports>use super::*;</imports>
      <imports>use tch::Tensor;</imports>
    </file>
    <file path="tests/make_move_tests.rs">
      <imports>use kingfisher::board::Board;</imports>
      <imports>use kingfisher::board_utils;</imports>
      <imports>use kingfisher::move_generation::MoveGen;</imports>
      <imports>use kingfisher::move_types::Move;</imports>
      <imports>use kingfisher::piece_types::*;</imports>
    </file>
    <file path="tests/mate_portfolio_tests.rs">
      <imports>use kingfisher::board::Board;</imports>
      <imports>use kingfisher::boardstack::BoardStack;</imports>
      <imports>use kingfisher::move_generation::MoveGen;</imports>
      <imports>use kingfisher::search::mate_search;</imports>
      <imports>use std::time::Instant;</imports>
    </file>
    <file path="tests/repetition_tests.rs">
      <imports>use kingfisher::boardstack::BoardStack;</imports>
      <imports>use kingfisher::move_types::Move;</imports>
    </file>
    <file path="tests/integration/mcts_integration_tests.rs">
      <imports>use kingfisher::mcts::tactical_mcts::{tactical_mcts_search, TacticalMctsConfig};</imports>
      <imports>use kingfisher::mcts::inference_server::InferenceServer;</imports>
      <imports>use kingfisher::board::Board;</imports>
      <imports>use kingfisher::move_generation::MoveGen;</imports>
      <imports>use kingfisher::eval::PestoEval;</imports>
      <imports>use kingfisher::move_types::Move;</imports>
      <imports>use crate::common::{board_from_fen, positions};</imports>
      <imports>use std::time::Duration;</imports>
      <imports>use std::sync::Arc;</imports>
    </file>
    <file path="tests/mcts_tests.rs">
      <imports>use std::cell::RefCell;</imports>
      <imports>use std::collections::HashMap;</imports>
      <imports>use std::hash::{Hash, Hasher};</imports>
      <imports>use std::rc::Rc;</imports>
      <imports>use std::time::{Duration, Instant};</imports>
      <imports>use kingfisher::board::Board;</imports>
      <imports>use kingfisher::eval::PestoEval;</imports>
      <imports>use kingfisher::move_generation::MoveGen;</imports>
      <imports>use kingfisher::mcts::{
        mcts_pesto_search, select_leaf_for_expansion, MctsNode, MoveCategory,
    };</imports>
      <imports>use kingfisher::mcts::simulation::simulate_random_playout;</imports>
      <imports>use kingfisher::move_types::{Move, NULL_MOVE};</imports>
      <imports>use kingfisher::board_utils;</imports>
      <imports>use kingfisher::search::mate_search;</imports>
      <imports>use kingfisher::boardstack::BoardStack;</imports>
    </file>
    <file path="tests/eval_pawn_structure_tests.rs">
      <imports>use kingfisher::board::Board;</imports>
      <imports>use kingfisher::board_utils;</imports>
      <imports>use kingfisher::eval::PestoEval;</imports>
      <imports>use kingfisher::eval_constants::{
        ISOLATED_PAWN_PENALTY, MOBILE_PAWN_DUO_BONUS_EG, MOBILE_PAWN_DUO_BONUS_MG,
        PASSED_PAWN_BONUS_EG, PASSED_PAWN_BONUS_MG, PAWN_CHAIN_BONUS, PAWN_DUO_BONUS,
        KING_SAFETY_PAWN_SHIELD_BONUS,
    };</imports>
      <imports>use kingfisher::piece_types::{BLACK, PAWN, WHITE};</imports>
      <imports>use kingfisher::move_generation::MoveGen;</imports>
    </file>
    <file path="python/export_model.py">
      <imports>import torch</imports>
      <imports>from model_architectures import MinimalViableNet</imports>
      <imports>import os</imports>
    </file>
    <file path="python/train.py">
      <imports>import torch</imports>
      <imports>import torch.nn as nn</imports>
      <imports>import torch.optim as optim</imports>
      <imports>import torch.nn.functional as F</imports>
      <imports>from torch.utils.data import Dataset, DataLoader</imports>
      <imports>import numpy as np</imports>
      <imports>import os</imports>
      <imports>import struct</imports>
      <imports>import glob</imports>
      <imports>import sys</imports>
      <imports>from model import LogosNet</imports>
    </file>
    <file path="python/orchestrate.py">
      <imports>import os</imports>
      <imports>import subprocess</imports>
      <imports>import torch</imports>
      <imports>import shutil</imports>
      <imports>from model import LogosNet</imports>
    </file>
    <file path="python/model.py">
      <imports>import torch</imports>
      <imports>import torch.nn as nn</imports>
      <imports>import torch.nn.functional as F</imports>
      <imports>import math</imports>
    </file>
    <file path="python/training_pipeline.py">
      <imports>import torch</imports>
      <imports>import torch.nn as nn</imports>
      <imports>import torch.nn.functional as F</imports>
      <imports>import torch.optim as optim</imports>
      <imports>from torch.utils.data import Dataset, DataLoader</imports>
      <imports>import numpy as np</imports>
      <imports>import chess</imports>
      <imports>import chess.pgn</imports>
      <imports>import chess.engine</imports>
      <imports>import os</imports>
      <imports>import json</imports>
      <imports>import random</imports>
      <imports>from typing import List, Tuple, Dict, Optional</imports>
      <imports>from pathlib import Path</imports>
      <imports>import argparse</imports>
      <imports>from tqdm import tqdm</imports>
      <imports>import logging</imports>
      <imports>from chess_net import ChessNet, ChessNetInterface</imports>
    </file>
    <file path="python/train_chess_ai.py">
      <imports>import argparse</imports>
      <imports>import os</imports>
      <imports>import sys</imports>
      <imports>import subprocess</imports>
      <imports>from pathlib import Path</imports>
      <imports>import logging</imports>
    </file>
    <file path="python/test_architectures.py">
      <imports>import torch</imports>
      <imports>import torch.optim as optim</imports>
      <imports>import torch.nn.functional as F</imports>
      <imports>from model import LogosNet</imports>
    </file>
    <file path="python/data_collection.py">
      <imports>import requests</imports>
      <imports>import gzip</imports>
      <imports>import os</imports>
      <imports>import chess.pgn</imports>
      <imports>from pathlib import Path</imports>
      <imports>import argparse</imports>
      <imports>import logging</imports>
      <imports>from typing import List, Optional</imports>
      <imports>from tqdm import tqdm</imports>
    </file>
  </import_relationships>
</dependencies>

<ml_architecture>
  <framework>PyTorch</framework>
  <models>
    <model>SEBlock</model>
    <model>ResBlock</model>
    <model>LogosNet</model>
  </models>
</ml_architecture>

<git_history>
  <current_branch>main</current_branch>
  <recent_commits>
    <commit hash="1495e74">
      <message>Add documentation for stream of consciousness logger</message>
      <author>Adam Holmes</author>
      <timestamp>2025-12-29T02:27:24+00:00</timestamp>
      <files_changed>
        <file change="Modified">ARCHITECTURE.md</file>
        <file change="Modified">BENCHMARKING.md</file>
        <file change="Modified">README.md</file>
        <file change="Modified">src/uci.rs</file>
      </files_changed>
    </commit>
    <commit hash="13d47fa">
      <message>Implement Stream of Consciousness logger for MCTS search narration</message>
      <author>Adam Holmes</author>
      <timestamp>2025-12-29T02:24:30+00:00</timestamp>
      <files_changed>
        <file change="Modified">Cargo.toml</file>
        <file change="Modified">src/bin/mate_search_tt_demo.rs</file>
        <file change="Modified">src/bin/mcts_inspector.rs</file>
        <file change="Modified">src/bin/neural_integration_demo.rs</file>
        <file change="Modified">src/bin/self_play.rs</file>
      </files_changed>
    </commit>
    <commit hash="fe1dc7c">
      <message>Add documentation for MCTS Inspector and tree visualization</message>
      <author>Adam Holmes</author>
      <timestamp>2025-12-28T21:51:49+00:00</timestamp>
      <files_changed>
        <file change="Modified">README.md</file>
      </files_changed>
    </commit>
    <commit hash="cea317e">
      <message>Implement MCTS inspector and enhanced Graphviz tree visualization</message>
      <author>Adam Holmes</author>
      <timestamp>2025-12-28T21:41:23+00:00</timestamp>
      <files_changed>
        <file change="Modified">Cargo.toml</file>
        <file change="Modified">bundle_repo.py</file>
        <file change="Modified">src/bin/benchmark_gates.rs</file>
        <file change="Added">src/bin/mcts_inspector.rs</file>
        <file change="Modified">src/mcts/mod.rs</file>
      </files_changed>
    </commit>
    <commit hash="cf04658">
      <message>Add testing documentation and update README</message>
      <author>Adam Holmes</author>
      <timestamp>2025-12-28T19:52:08+00:00</timestamp>
      <files_changed>
        <file change="Modified">README.md</file>
        <file change="Added">TESTING.md</file>
      </files_changed>
    </commit>
    <commit hash="2bbd91d">
      <message>Implement comprehensive test suite and fix BoardStack history overflow</message>
      <author>Adam Holmes</author>
      <timestamp>2025-12-28T19:43:38+00:00</timestamp>
      <files_changed>
        <file change="Modified">Cargo.lock</file>
        <file change="Modified">Cargo.toml</file>
        <file change="Added">scripts/test.sh</file>
        <file change="Modified">src/boardstack.rs</file>
        <file change="Modified">src/magic_bitboard.rs</file>
      </files_changed>
    </commit>
    <commit hash="ba6a107">
      <message>Fix perspective bug in MctsNode constructors for terminal values</message>
      <author>Adam Holmes</author>
      <timestamp>2025-12-28T10:39:43+00:00</timestamp>
      <files_changed>
        <file change="Modified">src/mcts/node.rs</file>
        <file change="Modified">tests/mcts_tests.rs</file>
      </files_changed>
    </commit>
    <commit hash="3359b45">
      <message>Use tactical values for Q-initialization instead of policy priors</message>
      <author>Adam Holmes</author>
      <timestamp>2025-12-28T10:34:45+00:00</timestamp>
      <files_changed>
        <file change="Modified">src/mcts/mod.rs</file>
        <file change="Modified">src/mcts/node.rs</file>
        <file change="Modified">src/mcts/selection.rs</file>
        <file change="Modified">src/mcts/tactical_mcts.rs</file>
      </files_changed>
    </commit>
    <commit hash="a83a2f0">
      <message>Sync training data generators with perspective-relative inference convention</message>
      <author>Adam Holmes</author>
      <timestamp>2025-12-28T10:16:47+00:00</timestamp>
      <files_changed>
        <file change="Modified">python/test_architectures.py</file>
        <file change="Modified">python/train.py</file>
        <file change="Modified">python/train_chess_ai.py</file>
        <file change="Modified">python/training_pipeline.py</file>
        <file change="Modified">src/bin/self_play.rs</file>
      </files_changed>
    </commit>
    <commit hash="6e0ccdf">
      <message>Enforce Side-to-Move convention with relative backpropagation and input flip</message>
      <author>Adam Holmes</author>
      <timestamp>2025-12-28T10:03:27+00:00</timestamp>
      <files_changed>
        <file change="Modified">src/mcts/tactical_mcts.rs</file>
        <file change="Modified">src/neural_net.rs</file>
      </files_changed>
    </commit>
  </recent_commits>
  <uncommitted_changes>
    <file>.gitignore</file>
    <file>Cargo.toml</file>
    <file>bundle_repo.py</file>
    <file>src/benchmarks/mod.rs</file>
    <file>src/bin/mate_search_tt_demo.rs</file>
    <file>src/bin/mcts_inspector.rs</file>
    <file>src/bin/neural_integration_demo.rs</file>
    <file>src/bin/self_play.rs</file>
    <file>src/bin/tactical_benchmark.rs</file>
    <file>src/bin/tactical_profiler.rs</file>
    <file>src/board.rs</file>
    <file>src/eval.rs</file>
    <file>src/make_move.rs</file>
    <file>src/mcts/mod.rs</file>
    <file>src/mcts/neural_mcts.rs</file>
    <file>src/mcts/node.rs</file>
    <file>src/mcts/selection.rs</file>
    <file>src/mcts/simulation.rs</file>
    <file>src/mcts/tactical_mcts.rs</file>
    <file>src/mcts/unit_tests/selection_tests.rs</file>
    <file>src/move_generation.rs</file>
    <file>src/search/alpha_beta.rs</file>
    <file>src/search/mate_search.rs</file>
    <file>src/search/mod.rs</file>
    <file>tests/property/invariant_tests.rs</file>
    <file>tests/regression/recent_fixes_tests.rs</file>
    <file>tests/unit/selection_tests.rs</file>
    <file>Dockerfile</file>
    <file>MCTS_INSPECTOR_IMPLEMENTATION_GUIDE.md</file>
    <file>PAPER_READY_IMPLEMENTATION_GUIDE.md</file>
    <file>STREAM_OF_CONSCIOUSNESS_IMPLEMENTATION_GUIDE.md</file>
    <file>STREAM_OF_CONSCIOUSNESS_LOGGER.md</file>
    <file>bundle.xml</file>
    <file>files</file>
    <file>mcts_tree.dot</file>
    <file>mcts_tree.png</file>
    <file>mcts_tree.svg</file>
    <file>requirements.txt</file>
    <file>results/</file>
    <file>scripts/generate_figures.py</file>
    <file>scripts/run_paper_experiments.sh</file>
    <file>src/benchmarks/elo_tournament.rs</file>
    <file>src/bin/elo_tournament.rs</file>
    <file>src/bin/verbose_search.rs</file>
    <file>src/mcts/search_logger.rs</file>
    <file>tests/unit/search_logger_tests.rs</file>
  </uncommitted_changes>
</git_history>

<annotations>
  <total_count>57</total_count>
  <critical>
    <annotation type="Safety" line="40">
      <file>./DESIGN_DOC.md</file>
      <message>heuristics</message>
    </annotation>
    <annotation type="Safety" line="510">
      <file>./PAPER_READY_IMPLEMENTATION_GUIDE.md</file>
      <message>Gates: Mate Search + KOTH)</message>
    </annotation>
    <annotation type="Safety" line="23">
      <file>./README.md</file>
      <message>Gates (Tier 1):</message>
    </annotation>
    <annotation type="Safety" line="380">
      <file>./src/board_utils.rs</file>
      <context>fn get_front_span_mask</context>
      <message>evaluations and detecting attacks against the king.</message>
    </annotation>
    <annotation type="Safety" line="209">
      <file>./src/eval_constants.rs</file>
      <message>Bonus per Pawn in Shield Zone (MG/EG)</message>
    </annotation>
    <annotation type="Safety" line="284">
      <file>./src/eval_constants.rs</file>
      <message>Constants Removed ---</message>
    </annotation>
    <annotation type="Safety" line="518">
      <file>./src/mcts/node.rs</file>
      <context>fn recursive_dot</context>
      <message>check for move legality</message>
    </annotation>
    <annotation type="Safety" line="225">
      <file>./src/mcts/selection.rs</file>
      <context>fn select_ucb_with_policy</context>
      <message>check</message>
    </annotation>
    <annotation type="Safety" line="41">
      <file>./src/mcts/tactical_mcts.rs</file>
      <context>struct TacticalMctsConfig</context>
      <message>Gates: Mate Search + KOTH)</message>
    </annotation>
    <annotation type="Safety" line="11">
      <file>./src/search/koth.rs</file>
      <message>gate" to detect rapid KOTH wins.</message>
    </annotation>
    <annotation type="Safety" line="160">
      <file>./src/tuning/texel.rs</file>
      <context>fn optimize_positional_bonuses</context>
      <message>pawn shield bonus</message>
    </annotation>
    <annotation type="Safety" line="36">
      <file>./tests/integration/mcts_integration_tests.rs</file>
      <context>fn test_mcts_finds_mate_in_1</context>
      <message>Gate</message>
    </annotation>
    <annotation type="Safety" line="38">
      <file>./tests/integration/mcts_integration_tests.rs</file>
      <context>fn test_mcts_finds_mate_in_1</context>
      <message>gate is fast.</message>
    </annotation>
  </critical>
  <action_items>
    <annotation type="Todo" line="329">
      <file>./PAPER_READY_IMPLEMENTATION_GUIDE.md</file>
      <message>Need config flag to disable Tier 2</message>
    </annotation>
    <annotation type="Todo" line="129">
      <file>./src/benchmarks/tactical_suite.rs</file>
      <context>fn benchmark_position</context>
      <message>Add node counting to agents</message>
    </annotation>
    <annotation type="Todo" line="401">
      <file>./src/board_utils.rs</file>
      <context>fn get_king_attack_zone_mask</context>
      <message>Add functions to calculate attacks to a square if not using MoveGen directly in eval.</message>
    </annotation>
    <annotation type="Todo" line="67">
      <file>./src/egtb.rs</file>
      <context>fn probe</context>
      <message>Implement proper EGTB integration after MCTS is working</message>
    </annotation>
    <annotation type="Todo" line="75">
      <file>./src/egtb.rs</file>
      <context>fn convert_board</context>
      <message>Implement proper board conversion after MCTS is working</message>
    </annotation>
    <annotation type="Todo" line="110">
      <file>./src/mcts/policy.rs</file>
      <context>fn new</context>
      <message>Implement model loading logic here</message>
    </annotation>
    <annotation type="Todo" line="120">
      <file>./src/mcts/policy.rs</file>
      <context>fn evaluate</context>
      <message>Implement actual model inference here</message>
    </annotation>
    <annotation type="Todo" line="54">
      <file>./src/uci.rs</file>
      <context>fn new</context>
      <message>Add UCI option for EGTB path</message>
    </annotation>
    <annotation type="Todo" line="230">
      <file>./src/uci.rs</file>
      <context>fn handle_go</context>
      <message>Enhance Agent trait or agent implementations to use UCI time controls.</message>
    </annotation>
    <annotation type="Todo" line="333">
      <file>./src/uci.rs</file>
      <context>fn handle_setoption</context>
      <message>Store this path in UCIEngine struct and pass to HumanlikeAgent::new</message>
    </annotation>
    <annotation type="Todo" line="226">
      <file>./tests/mcts_tests.rs</file>
      <context>fn test_mcts_pesto_avoids_immediate_loss</context>
      <message>Add tests for Killer/History categorization integration</message>
    </annotation>
    <annotation type="Todo" line="227">
      <file>./tests/mcts_tests.rs</file>
      <context>fn test_mcts_pesto_avoids_immediate_loss</context>
      <message>Add tests for prioritized selection logic</message>
    </annotation>
  </action_items>
</annotations>

<file_signatures>
<file path="BENCHMARKING.md" included="true">
  <signatures>
  </signatures>
</file>
<file path="src/bin/mcts_inspector.rs" included="true">
  <signatures>
    <function visibility="Private">fn main()</function>
    <function visibility="Private">fn parse_arg(args: &amp;[String], flag: &amp;str) -&gt; Option&lt;u32&gt;</function>
    <function visibility="Private">fn parse_string_arg(args: &amp;[String], flag: &amp;str) -&gt; Option&lt;String&gt;</function>
    <function visibility="Private">fn print_usage()</function>
  </signatures>
</file>
<file path="src/bin/tactical_benchmark.rs" included="true">
  <signatures>
    <function visibility="Public">pub fn run_comprehensive_benchmark(config: BenchmarkConfig) -&gt; BenchmarkResults</function>
    <function visibility="Private">fn benchmark_tactical_mcts(
    board: &amp;Board,
    move_gen: &amp;MoveGen,
    pesto_eval: &amp;PestoEval,
    config: &amp;BenchmarkConfig,
) -&gt; SearchResult</function>
    <function visibility="Private">fn benchmark_classical_mcts(
    board: &amp;Board,
    move_gen: &amp;MoveGen,
    pesto_eval: &amp;PestoEval,
    config: &amp;BenchmarkConfig,
) -&gt; SearchResult</function>
    <function visibility="Private">fn benchmark_alpha_beta(
    board: &amp;Board,
    move_gen: &amp;MoveGen,
    pesto_eval: &amp;PestoEval,
    config: &amp;BenchmarkConfig,
) -&gt; SearchResult</function>
    <function visibility="Private">fn main()</function>
    <struct>pub struct BenchmarkConfig</struct>
    <struct>pub struct SearchResult</struct>
    <struct>pub struct BenchmarkResults</struct>
  </signatures>
</file>
<file path="src/bin/verify_tactical_graft.rs" included="true">
  <signatures>
    <function visibility="Private">fn main()</function>
  </signatures>
</file>
<file path="src/mcts/mod.rs" included="true">
  <signatures>
    <function visibility="Public">pub fn mcts_pesto_search(
    root_state: Board,
    move_gen: &amp;MoveGen,
    pesto_eval: &amp;PestoEval,
    mate_search_depth: i32,
    iterations: Option&lt;u32&gt;,
    time_limit: Option&lt;Duration&gt;,
) -&gt; Option&lt;Move&gt;</function>
  </signatures>
</file>
<file path="Cargo.toml" included="true">
  <signatures>
  </signatures>
</file>
<file path="src/mcts/nn_counter.rs" included="true">
  <signatures>
    <function visibility="Private">fn test_counting_neural_net_policy()</function>
    <function visibility="Private">fn test_efficiency_comparison()</function>
    <struct>pub struct CountingNeuralNetPolicy</struct>
    <struct>pub struct EfficiencyComparison</struct>
  </signatures>
</file>
<file path="STREAM_OF_CONSCIOUSNESS_IMPLEMENTATION_GUIDE.md" included="true">
  <signatures>
  </signatures>
</file>
<file path="src/mcts/tactical_mcts.rs" included="true">
  <signatures>
    <function visibility="Public">pub fn tactical_mcts_search(
    board: Board,
    move_gen: &amp;MoveGen,
    pesto_eval: &amp;PestoEval,
    nn_policy: &amp;mut Option&lt;NeuralNetPolicy&gt;,
    config: TacticalMctsConfig,
) -&gt; (Option&lt;Move&gt;, TacticalMctsStats, Rc&lt;RefCell&lt;MctsNode&gt;&gt;)</function>
    <function visibility="Public">pub fn tactical_mcts_search_with_tt(
    board: Board,
    move_gen: &amp;MoveGen,
    pesto_eval: &amp;PestoEval,
    nn_policy: &amp;mut Option&lt;NeuralNetPolicy&gt;,
    config: TacticalMctsConfig,
    transposition_table: &amp;mut TranspositionTable,
) -&gt; (Option&lt;Move&gt;, TacticalMctsStats, Rc&lt;RefCell&lt;MctsNode&gt;&gt;)</function>
    <function visibility="Private">fn select_leaf_node(
    mut current: Rc&lt;RefCell&lt;MctsNode&gt;&gt;,
    move_gen: &amp;MoveGen,
    nn_policy: &amp;mut Option&lt;NeuralNetPolicy&gt;,
    config: &amp;TacticalMctsConfig,
    stats: &amp;mut TacticalMctsStats,
    logger: Option&lt;&amp;Arc&lt;SearchLogger&gt;&gt;,
) -&gt; Rc&lt;RefCell&lt;MctsNode&gt;&gt;</function>
    <function visibility="Private">fn evaluate_leaf_node(
    node: Rc&lt;RefCell&lt;MctsNode&gt;&gt;,
    move_gen: &amp;MoveGen,
    pesto_eval: &amp;PestoEval,
    nn_policy: &amp;mut Option&lt;NeuralNetPolicy&gt;,
    config: &amp;TacticalMctsConfig,
    transposition_table: &amp;mut TranspositionTable,
    stats: &amp;mut TacticalMctsStats,
    logger: Option&lt;&amp;Arc&lt;SearchLogger&gt;&gt;,
) -&gt; f64</function>
    <function visibility="Private">fn evaluate_and_expand_node(
    node: Rc&lt;RefCell&lt;MctsNode&gt;&gt;,
    move_gen: &amp;MoveGen,
    pesto_eval: &amp;PestoEval,
    stats: &amp;mut TacticalMctsStats,
    config: &amp;TacticalMctsConfig,
    logger: Option&lt;&amp;Arc&lt;SearchLogger&gt;&gt;,
)</function>
    <function visibility="Private">fn backpropagate_value(node: Rc&lt;RefCell&lt;MctsNode&gt;&gt;, value: f64)</function>
    <function visibility="Private">fn select_best_move_from_root(
    root: Rc&lt;RefCell&lt;MctsNode&gt;&gt;,
    move_gen: &amp;MoveGen,
) -&gt; Option&lt;Move&gt;</function>
    <function visibility="Public">pub fn tactical_mcts_search_for_training(
    board: Board,
    move_gen: &amp;MoveGen,
    pesto_eval: &amp;PestoEval,
    nn_policy: &amp;mut Option&lt;NeuralNetPolicy&gt;,
    config: TacticalMctsConfig,
) -&gt; MctsTrainingResult</function>
    <function visibility="Public">pub fn print_search_stats(stats: &amp;TacticalMctsStats, best_move: Option&lt;Move&gt;)</function>
    <struct>pub struct TacticalMctsConfig</struct>
    <struct>pub struct TacticalMctsStats</struct>
    <struct>pub struct MctsTrainingResult</struct>
  </signatures>
</file>
<file path="Dockerfile" included="true">
  <signatures>
  </signatures>
</file>
<file path="src/egtb.rs" included="true">
  <signatures>
    <function visibility="Private">fn test_new_invalid_path()</function>
    <function visibility="Private">fn test_probe_piece_count_within_limit()</function>
    <function visibility="Private">fn test_probe_piece_count_exceeds_limit()</function>
    <struct>pub struct EgtbInfo</struct>
    <struct>pub struct EgtbProber</struct>
    <struct>struct PieceCountCheckProber</struct>
  </signatures>
</file>
<file path="HUMANLIKE_AGENT.md" included="true">
  <signatures>
  </signatures>
</file>
<file path="src/mcts/policy.rs" included="true">
  <signatures>
    <struct>pub struct RandomPolicy;</struct>
    <struct>pub struct MaterialPolicy;</struct>
    <struct>pub struct OnnxPolicyNetwork</struct>
    <trait>pub trait PolicyNetwork</trait>
  </signatures>
</file>
<file path=".cargo/config.toml" included="true">
  <signatures>
  </signatures>
</file>
<file path="src/search/alpha_beta.rs" included="true">
  <signatures>
    <function visibility="Public">pub fn alpha_beta_search(
    board: &amp;mut BoardStack,
    move_gen: &amp;MoveGen,
    pesto: &amp;PestoEval,
    tt: &amp;mut TranspositionTable,
    killers: &amp;mut [[Move; 2]; MAX_PLY],
    history: &amp;mut HistoryTable,
    depth: i32,
    alpha_init: i32,
    beta_init: i32,
    q_search_max_depth: i32,
    verbose: bool,
    start_time: Option&lt;Instant&gt;,
    time_limit: Option&lt;Duration&gt;,
) -&gt; (i32, Move, i32, bool)</function>
    <function visibility="Private">fn alpha_beta_recursive(
    board: &amp;mut BoardStack,
    move_gen: &amp;MoveGen,
    pesto: &amp;PestoEval,
    tt: &amp;mut TranspositionTable,
    killers: &amp;mut [[Move; 2]; MAX_PLY],
    history: &amp;mut HistoryTable,
    depth: i32,
    mut alpha: i32,
    beta: i32,
    q_search_max_depth: i32,
    verbose: bool,
    start_time: Option&lt;Instant&gt;, // Added
    time_limit: Option&lt;Duration&gt;, // Added
) -&gt; (i32, i32, bool)</function>
    <function visibility="Private">fn is_capture(board: &amp;Board, mv: &amp;Move) -&gt; bool</function>
  </signatures>
</file>
<file path="README.md" included="true">
  <signatures>
  </signatures>
</file>
<file path="TESTING.md" included="true">
  <signatures>
  </signatures>
</file>
<file path="src/mcts/neural_mcts.rs" included="true">
  <signatures>
    <function visibility="Public">pub fn neural_mcts_search(
    root_state: Board,
    move_gen: &amp;MoveGen,
    pesto_eval: &amp;PestoEval,
    nn_policy: &amp;mut Option&lt;NeuralNetPolicy&gt;,
    mate_search_depth: i32,
    iterations: Option&lt;u32&gt;,
    time_limit: Option&lt;Duration&gt;,
) -&gt; Option&lt;Move&gt;</function>
  </signatures>
</file>
<file path="src/mcts/unit_tests/mcts_integration_tests.rs" included="true">
  <signatures>
    <function visibility="Private">fn setup_test_env() -&gt; (MoveGen, PestoEval)</function>
    <function visibility="Private">fn get_test_config() -&gt; TacticalMctsConfig</function>
    <function visibility="Private">fn test_basic_search_functionality()</function>
    <function visibility="Private">fn test_tactical_position_search()</function>
    <function visibility="Private">fn test_mate_detection_integration()</function>
    <function visibility="Private">fn test_search_time_limits()</function>
    <function visibility="Private">fn test_iteration_limits()</function>
    <function visibility="Private">fn test_statistics_consistency()</function>
    <function visibility="Private">fn test_different_exploration_constants()</function>
    <function visibility="Private">fn test_mate_search_depth_effect()</function>
    <function visibility="Private">fn test_reproducible_search()</function>
  </signatures>
</file>
<file path="DESIGN_DOC.md" included="true">
  <signatures>
  </signatures>
</file>
<file path="src/neural_net.rs" included="true">
  <signatures>
    <struct>pub struct NeuralNetPolicy</struct>
    <struct>pub struct NeuralNetPolicy</struct>
  </signatures>
</file>
<file path="src/move_types.rs" included="true">
  <signatures>
    <function visibility="Private">fn test_move_from_uci()</function>
    <function visibility="Private">fn test_move_special_methods()</function>
    <struct>pub struct Move</struct>
    <struct>pub struct CastlingRights</struct>
  </signatures>
</file>
<file path="src/tuning/data_loader.rs" included="true">
  <signatures>
    <function visibility="Private">fn test_synthetic_data_generation()</function>
    <function visibility="Private">fn test_csv_loading() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt;</function>
    <struct>pub struct DataLoader;</struct>
  </signatures>
</file>
<file path="STREAM_OF_CONSCIOUSNESS_LOGGER.md" included="true">
  <signatures>
  </signatures>
</file>
<file path="src/uci.rs" included="true">
  <signatures>
    <function visibility="Private">fn test_handle_position_startpos()</function>
    <function visibility="Private">fn test_handle_position_startpos_moves()</function>
    <function visibility="Private">fn test_handle_position_fen()</function>
    <function visibility="Private">fn test_handle_position_fen_moves()</function>
    <function visibility="Private">fn test_parse_go_movetime()</function>
    <function visibility="Private">fn test_parse_go_wtime_btime_winc_binc()</function>
    <function visibility="Private">fn test_parse_go_depth()</function>
    <function visibility="Private">fn test_parse_go_nodes()</function>
    <function visibility="Private">fn test_parse_go_mate()</function>
    <function visibility="Private">fn test_parse_go_infinite()</function>
    <function visibility="Private">fn test_handle_setoption_agenttype()</function>
    <function visibility="Private">fn test_handle_setoption_unknown()</function>
    <function visibility="Private">fn test_handle_setoption_invalid_format()</function>
    <struct>pub struct UCIEngine</struct>
  </signatures>
</file>
<file path="src/agent.rs" included="true">
  <signatures>
    <struct>pub struct SimpleAgent&lt;'a&gt;</struct>
    <struct>pub struct HumanlikeAgent&lt;'a&gt;</struct>
    <trait>pub trait Agent</trait>
  </signatures>
</file>
<file path="src/tuning/mod.rs" included="true">
  <signatures>
    <function visibility="Private">fn calculate_game_phase(board: &amp;Board) -&gt; f64</function>
    <function visibility="Private">fn test_texel_position_creation()</function>
    <function visibility="Private">fn test_game_phase_calculation()</function>
    <function visibility="Private">fn test_pgn_result_parsing()</function>
    <struct>pub struct TexelPosition</struct>
  </signatures>
</file>
<file path="src/tuning/texel.rs" included="true">
  <signatures>
    <function visibility="Private">fn sigmoid(eval_cp: f64, k: f64) -&gt; f64</function>
    <function visibility="Public">pub fn create_test_dataset() -&gt; Vec&lt;TexelPosition&gt;</function>
    <function visibility="Private">fn test_sigmoid_function()</function>
    <function visibility="Private">fn test_texel_tuner_creation()</function>
    <function visibility="Private">fn test_error_calculation()</function>
    <struct>pub struct TexelTuner</struct>
  </signatures>
</file>
<file path="src/benchmarks/strength_testing.rs" included="true">
  <signatures>
    <struct>pub struct StrengthTestConfig</struct>
    <struct>pub struct PositionResult</struct>
    <struct>pub struct StrengthTestResults</struct>
    <struct>pub struct EngineSummary</struct>
    <struct>pub struct OverallComparison</struct>
    <struct>pub struct StrengthTester</struct>
    <struct>pub struct TestPosition</struct>
  </signatures>
</file>
<file path="ARCHITECTURE.md" included="true">
  <signatures>
  </signatures>
</file>
<file path="src/benchmarks/mod.rs" included="true">
  <signatures>
    <function visibility="Public">pub fn create_simple_agent() -&gt; SimpleAgent&lt;'static&gt;</function>
    <function visibility="Public">pub fn create_humanlike_agent() -&gt; HumanlikeAgent&lt;'static&gt;</function>
    <struct>pub struct BenchmarkResult</struct>
    <struct>pub struct BenchmarkSummary</struct>
  </signatures>
</file>
<file path="src/alpha_beta.rs" included="true">
  <signatures>
    <function visibility="Private">fn is_capture(board: &amp;Board, mv: &amp;Move) -&gt; bool</function>
  </signatures>
</file>
<file path="src/piece_types.rs" included="true">
  <signatures>
  </signatures>
</file>
<file path="src/search/mod.rs" included="true">
  <signatures>
  </signatures>
</file>
<file path="requirements.txt" included="true">
  <signatures>
  </signatures>
</file>
<file path="src/benchmarks/elo_tournament.rs" included="false" relevance="2.7">
  <signatures>
  </signatures>
</file>
<file path="tests/integration/mcts_integration_tests.rs" included="false" relevance="2.7">
  <signatures>
    <function>test_mcts_finds_mate_in_1</function>
    <function>test_mcts_finds_mate_for_black</function>
    <function>test_mcts_finds_koth_win</function>
    <function>test_mcts_prefers_winning_capture</function>
    <function>test_backpropagation_sign_consistency</function>
  </signatures>
</file>
<file path="src/search/iterative_deepening.rs" included="false" relevance="2.7">
  <signatures>
    <function>iterative_deepening_ab_search</function>
    <function>aspiration_window_ab_search</function>
  </signatures>
</file>
<file path="src/benchmarks/performance.rs" included="false" relevance="2.7">
  <signatures>
    <function>run_performance_comparison</function>
    <function>mate_speed_benchmark</function>
    <function>test_performance_comparison_structure</function>
  </signatures>
</file>
<file path="test_tactical_mcts.rs" included="false" relevance="2.7">
  <signatures>
    <function>main</function>
  </signatures>
</file>
<file path="tests/unit/node_tests.rs" included="false" relevance="2.6">
  <signatures>
    <function>test_terminal_value_checkmate</function>
    <function>test_terminal_value_stalemate</function>
    <function>test_values_in_tanh_domain</function>
  </signatures>
</file>
<file path="src/benchmarks/elo_estimation.rs" included="false" relevance="2.6">
  <signatures>
  </signatures>
</file>
<file path="src/benchmarks/tactical_suite.rs" included="false" relevance="2.6">
  <signatures>
    <function>get_tactical_test_suite</function>
    <function>benchmark_position</function>
    <function>run_tactical_benchmark</function>
    <function>test_tactical_positions_load</function>
    <function>test_best_move_parsing</function>
  </signatures>
</file>
<file path="PAPER_READY_IMPLEMENTATION_GUIDE.md" included="false" relevance="2.6">
  <signatures>
  </signatures>
</file>
<file path="tests/mcts_tests.rs" included="false" relevance="2.6">
  <signatures>
    <function>setup</function>
    <function>setup_test_env</function>
    <function>parse_uci_move</function>
    <function>create_move</function>
    <function>test_node_new_root</function>
  </signatures>
</file>
<file path="src/magic_constants.rs" included="false" relevance="2.6">
  <signatures>
  </signatures>
</file>
<file path="src/board_utils.rs" included="false" relevance="2.5">
  <signatures>
    <function>coords_to_sq_ind</function>
    <function>sq_ind_to_coords</function>
    <function>sq_ind_to_bit</function>
    <function>bit_to_sq_ind</function>
    <function>sq_ind_to_algebraic</function>
  </signatures>
</file>
<file path="src/bin/tactical_cache_demo.rs" included="false" relevance="2.5">
  <signatures>
    <function>main</function>
    <function>benchmark_cache_performance</function>
    <function>benchmark_repeated_positions</function>
    <function>display_final_statistics</function>
  </signatures>
</file>
<file path="src/bin/tactical_profiler.rs" included="false" relevance="2.5">
  <signatures>
    <function>profile_position</function>
    <function>run_profiling_suite</function>
    <function>print_profile_result</function>
    <function>print_scaling_result</function>
    <function>analyze_memory_usage</function>
  </signatures>
</file>
<file path="tests/regression/recent_fixes_tests.rs" included="false" relevance="2.5">
  <signatures>
    <function>test_no_probability_domain_values</function>
    <function>test_symmetric_position_symmetric_eval</function>
    <function>test_checkmate_value_is_loss_for_stm</function>
    <function>test_tactical_values_influence_selection</function>
    <function>extract_plane</function>
  </signatures>
</file>
<file path="TRAINING_GUIDE.md" included="false" relevance="2.5">
  <signatures>
  </signatures>
</file>
<file path="src/bin/neural_integration_demo.rs" included="false" relevance="2.4">
  <signatures>
    <function>main</function>
  </signatures>
</file>
<file path="src/bin/generate_training_data.rs" included="false" relevance="2.4">
  <signatures>
    <function>main</function>
    <function>create_sample_games</function>
  </signatures>
</file>
<file path="src/bin/benchmark.rs" included="false" relevance="2.4">
  <signatures>
    <function>print_banner</function>
    <function>print_usage</function>
    <function>run_tactical_benchmark_cmd</function>
    <function>run_comparison_cmd</function>
    <function>run_speed_cmd</function>
  </signatures>
</file>
<file path="tests/unit/selection_tests.rs" included="false" relevance="2.4">
  <signatures>
    <function>test_ucb_unvisited_uses_q_init</function>
    <function>test_ucb_visited_ignores_q_init</function>
    <function>test_ucb_exploration_term</function>
    <function>calculate_ucb_value_for_test</function>
  </signatures>
</file>
<file path="tests/neural_integration_tests.rs" included="false" relevance="2.4">
  <signatures>
    <function>test_neural_network_integration</function>
    <function>test_neural_network_stub_behavior</function>
  </signatures>
</file>
<file path="src/bin/quick_test.rs" included="false" relevance="2.3">
  <signatures>
    <function>main</function>
  </signatures>
</file>
<file path="src/bin/verbose_search.rs" included="false" relevance="2.3">
  <signatures>
    <function>main</function>
    <function>parse_arg</function>
    <function>parse_verbosity</function>
    <function>print_usage</function>
  </signatures>
</file>
<file path="src/bin/verify_features.rs" included="false" relevance="2.3">
  <signatures>
    <function>main</function>
  </signatures>
</file>
<file path="python/training_pipeline.py" included="false" relevance="2.3">
  <signatures>
    <function>move_to_index</function>
    <function>main</function>
  </signatures>
</file>
<file path="src/bin/texel_tune.rs" included="false" relevance="2.2">
  <signatures>
    <function>main</function>
  </signatures>
</file>
<file path="src/bin/elo_tournament.rs" included="false" relevance="2.2">
  <signatures>
    <function>main</function>
    <function>parse_arg</function>
    <function>parse_string_arg</function>
  </signatures>
</file>
<file path="src/bin/see_integration_demo.rs" included="false" relevance="2.2">
  <signatures>
    <function>main</function>
    <function>analyze_see_impact</function>
    <function>compare_tactical_quality</function>
    <function>demonstrate_exchange_evaluations</function>
  </signatures>
</file>
<file path="src/bin/self_play.rs" included="false" relevance="2.2">
  <signatures>
    <function>main</function>
    <function>play_game</function>
    <function>save_binary_data</function>
  </signatures>
</file>
<file path="src/bin/mate_search_tt_demo.rs" included="false" relevance="2.2">
  <signatures>
    <function>main</function>
    <function>show_tt_speedup</function>
    <function>analyze_mate_cache_efficiency</function>
    <function>benchmark_repeated_searches</function>
  </signatures>
</file>
<file path="src/bin/strength_test.rs" included="false" relevance="2.1">
  <signatures>
    <function>main</function>
    <function>parse_args</function>
    <function>print_help</function>
  </signatures>
</file>
<file path="src/bin/benchmark_gates.rs" included="false" relevance="2.1">
  <signatures>
    <function>main</function>
  </signatures>
</file>
<file path="src/lib.rs" included="false" relevance="2.0">
  <signatures>
  </signatures>
</file>
<file path="src/tensor.rs" included="false" relevance="2.0">
  <signatures>
    <function>move_to_index</function>
    <function>test_queen_slide</function>
    <function>test_knight_move</function>
    <function>test_underpromotion</function>
  </signatures>
</file>
<file path="src/make_move.rs" included="false" relevance="2.0">
  <signatures>
  </signatures>
</file>
<file path="src/training/mod.rs" included="false" relevance="2.0">
  <signatures>
    <function>test_training_position_csv</function>
    <function>test_tactical_positions</function>
    <function>test_piece_counting</function>
  </signatures>
</file>
<file path="src/hash.rs" included="false" relevance="1.9">
  <signatures>
  </signatures>
</file>
<file path="src/mcts/search_logger.rs" included="false" relevance="1.9">
  <signatures>
    <function>set_global_logger</function>
    <function>with_global_logger</function>
    <function>with_global_logger_mut</function>
  </signatures>
</file>
<file path="src/mcts/tactical.rs" included="false" relevance="1.8">
  <signatures>
    <function>identify_tactical_moves</function>
    <function>get_tactical_cache_stats</function>
    <function>clear_tactical_cache</function>
    <function>identify_tactical_moves_internal</function>
    <function>calculate_mvv_lva</function>
  </signatures>
</file>
<file path="src/mcts/inference_server.rs" included="false" relevance="1.8">
  <signatures>
  </signatures>
</file>
<file path="src/mcts/node.rs" included="false" relevance="1.8">
  <signatures>
    <function>should_expand_not_select</function>
    <function>select_leaf_for_expansion</function>
  </signatures>
</file>
<file path="src/mcts/selection.rs" included="false" relevance="1.8">
  <signatures>
    <function>select_child_with_tactical_priority</function>
    <function>ensure_node_expanded</function>
    <function>select_unexplored_tactical_move</function>
    <function>select_ucb_with_policy</function>
    <function>calculate_ucb_value</function>
  </signatures>
</file>
<file path="src/mcts/simulation.rs" included="false" relevance="1.7">
  <signatures>
    <function>simulate_random_playout</function>
    <function>simple_material_eval</function>
  </signatures>
</file>
<file path="src/mcts/unit_tests/tactical_tests.rs" included="false" relevance="1.7">
  <signatures>
    <function>setup_test_env</function>
    <function>test_mvv_lva_basic_scoring</function>
    <function>test_tactical_move_identification</function>
    <function>test_no_tactical_moves_in_quiet_position</function>
    <function>test_tactical_move_scoring</function>
  </signatures>
</file>
<file path="src/mcts/unit_tests/selection_tests.rs" included="false" relevance="1.7">
  <signatures>
    <function>setup_test_env</function>
    <function>test_node_expansion_from_start</function>
    <function>test_tactical_move_prioritization</function>
    <function>test_statistics_tracking</function>
    <function>test_ucb_selection_with_policy</function>
  </signatures>
</file>
<file path="src/arena.rs" included="false" relevance="1.7">
  <signatures>
  </signatures>
</file>
<file path="src/boardstack.rs" included="false" relevance="1.6">
  <signatures>
  </signatures>
</file>
<file path="src/transposition.rs" included="false" relevance="1.6">
  <signatures>
  </signatures>
</file>
<file path="src/bits.rs" included="false" relevance="1.6">
  <signatures>
    <function>bits</function>
    <function>ibset</function>
    <function>ibclr</function>
    <function>btest</function>
    <function>popcnt</function>
  </signatures>
</file>
<file path="src/board.rs" included="false" relevance="1.6">
  <signatures>
  </signatures>
</file>
<file path="src/move_generation.rs" included="false" relevance="1.6">
  <signatures>
    <function>generate_file_masks</function>
    <function>generate_rank_masks</function>
    <function>generate_diag_masks</function>
    <function>generate_anti_diag_masks</function>
  </signatures>
</file>
<file path="src/eval_constants.rs" included="false" relevance="1.6">
  <signatures>
  </signatures>
</file>
<file path="src/eval.rs" included="false" relevance="1.6">
  <signatures>
    <function>extrapolate_value</function>
  </signatures>
</file>
<file path="src/search/mate_search.rs" included="false" relevance="1.5">
  <signatures>
    <function>mate_search</function>
    <function>iterative_deepening_wrapper</function>
    <function>mate_search_recursive</function>
  </signatures>
</file>
<file path="src/search/see.rs" included="false" relevance="1.5">
  <signatures>
    <function>see</function>
    <function>find_least_valuable_attacker_sq</function>
    <function>get_piece_type_on_sq</function>
    <function>clear_square</function>
    <function>set_square</function>
  </signatures>
</file>
<file path="src/search/quiescence.rs" included="false" relevance="1.5">
  <signatures>
    <function>quiescence_search</function>
    <function>quiescence_search_tactical</function>
  </signatures>
</file>
<file path="src/search/koth.rs" included="false" relevance="1.5">
  <signatures>
    <function>koth_center_in_3</function>
    <function>solve_koth_in_3</function>
  </signatures>
</file>
<file path="src/search/history.rs" included="false" relevance="1.5">
  <signatures>
  </signatures>
</file>
<file path="src/utils.rs" included="false" relevance="1.4">
  <signatures>
    <function>print_bits</function>
    <function>print_move</function>
  </signatures>
</file>
<file path="src/main.rs" included="false" relevance="1.4">
  <signatures>
    <function>run_simple_game</function>
    <function>main</function>
  </signatures>
</file>
<file path="src/magic_bitboard.rs" included="false" relevance="1.4">
  <signatures>
    <function>find_magic_numbers</function>
    <function>init_king_moves</function>
    <function>init_knight_moves</function>
    <function>init_pawn_captures_promotions</function>
    <function>init_pawn_moves</function>
  </signatures>
</file>
<file path="scripts/run_paper_experiments.sh" included="false" relevance="1.4">
  <signatures>
  </signatures>
</file>
<file path="scripts/generate_figures.py" included="false" relevance="1.4">
  <signatures>
    <function>generate_figures</function>
  </signatures>
</file>
<file path="scripts/test.sh" included="false" relevance="1.4">
  <signatures>
  </signatures>
</file>
<file path=".github/workflows/rust.yml" included="false" relevance="1.3">
  <signatures>
  </signatures>
</file>
<file path="MCTS_TACTICAL_PRIORITY.md" included="false" relevance="1.3">
  <signatures>
  </signatures>
</file>
<file path="tests/property/mod.rs" included="false" relevance="1.3">
  <signatures>
  </signatures>
</file>
<file path="tests/property/invariant_tests.rs" included="false" relevance="1.3">
  <signatures>
    <function>random_position</function>
    <function>extract_plane</function>
  </signatures>
</file>
<file path="tests/eval_piece_bonus_tests.rs" included="false" relevance="1.3">
  <signatures>
    <function>get_raw_scores</function>
    <function>test_two_bishops_bonus</function>
    <function>test_king_safety_pawn_shield</function>
  </signatures>
</file>
<file path="tests/bitboard_tests.rs" included="false" relevance="1.3">
  <signatures>
    <function>test_initial_position</function>
    <function>test_get_piece_bitboard</function>
    <function>test_make_move</function>
    <function>test_is_legal</function>
    <function>test_is_illegal</function>
  </signatures>
</file>
<file path="tests/common/mod.rs" included="false" relevance="1.3">
  <signatures>
    <function>board_from_fen</function>
    <function>legal_moves_set</function>
    <function>generate_legal_moves</function>
    <function>assert_approx_eq</function>
    <function>assert_in_tanh_domain</function>
  </signatures>
</file>
<file path="tests/unit/graphviz_tests.rs" included="false" relevance="1.3">
  <signatures>
    <function>test_export_dot_basic_structure</function>
    <function>test_export_dot_mate_position_shows_gate_color</function>
    <function>test_export_dot_tactical_position_shows_graft_color</function>
    <function>test_node_origin_enum_colors</function>
    <function>test_node_origin_labels</function>
  </signatures>
</file>
<file path="tests/unit/move_generation_tests.rs" included="false" relevance="1.2">
  <signatures>
    <function>test_en_passant_generation</function>
    <function>test_castling_generation</function>
    <function>test_castling_blocked_by_check</function>
    <function>test_promotion_moves</function>
  </signatures>
</file>
<file path="tests/unit/mod.rs" included="false" relevance="1.2">
  <signatures>
  </signatures>
</file>
<file path="tests/unit/tensor_tests.rs" included="false" relevance="1.2">
  <signatures>
    <function>test_tensor_stm_symmetry</function>
    <function>test_tensor_dimensions</function>
    <function>test_castling_planes</function>
    <function>test_en_passant_plane</function>
    <function>extract_plane</function>
  </signatures>
</file>
<file path="tests/unit/search_logger_tests.rs" included="false" relevance="1.2">
  <signatures>
    <function>test_logger_silent_produces_no_output</function>
    <function>test_logger_buffered_captures_output</function>
    <function>test_logger_respects_verbosity_levels</function>
    <function>test_gate_reason_descriptions</function>
    <function>test_selection_reason_formatting</function>
  </signatures>
</file>
<file path="tests/unit/board_tests.rs" included="false" relevance="1.2">
  <signatures>
    <function>test_starting_position_parsing</function>
    <function>test_fen_roundtrip</function>
    <function>test_en_passant_square_parsing</function>
    <function>test_checkmate_detection</function>
    <function>test_stalemate_detection</function>
  </signatures>
</file>
<file path="tests/move_generation_tests.rs" included="false" relevance="1.2">
  <signatures>
    <function>test_initial_move_count</function>
    <function>test_knight_moves</function>
    <function>test_pawn_promotion</function>
    <function>test_capture_ordering</function>
    <function>test_non_capture_ordering_white</function>
  </signatures>
</file>
<file path="tests/perft_tests.rs" included="false" relevance="1.2">
  <signatures>
    <function>perft</function>
    <function>test_start_pos_perft1</function>
    <function>test_start_pos_perft2</function>
    <function>test_start_pos_perft3</function>
    <function>test_start_pos_perft4</function>
  </signatures>
</file>
<file path="tests/regression/mod.rs" included="false" relevance="1.2">
  <signatures>
  </signatures>
</file>
<file path="tests/make_move_tests.rs" included="false" relevance="1.2">
  <signatures>
    <function>create_move</function>
    <function>create_promo_move</function>
    <function>test_apply_pawn_push</function>
    <function>test_apply_capture</function>
    <function>test_apply_en_passant</function>
  </signatures>
</file>
<file path="tests/mate_portfolio_tests.rs" included="false" relevance="1.2">
  <signatures>
    <function>test_mate_search_portfolio</function>
    <function>run_portfolio_test_case</function>
  </signatures>
</file>
<file path="tests/repetition_tests.rs" included="false" relevance="1.2">
  <signatures>
    <function>test_threefold_repetition</function>
    <function>test_repetition_with_different_castling_rights</function>
    <function>test_repetition_with_different_en_passant</function>
  </signatures>
</file>
<file path="tests/integration/mod.rs" included="false" relevance="1.1">
  <signatures>
  </signatures>
</file>
<file path="tests/eval_pawn_structure_tests.rs" included="false" relevance="1.1">
  <signatures>
    <function>get_raw_scores</function>
    <function>test_passed_pawn_bonus</function>
    <function>test_isolated_pawn_penalty</function>
    <function>test_pawn_chain_bonus</function>
    <function>test_pawn_duo_bonus</function>
  </signatures>
</file>
<file path="MCTS_INSPECTOR_IMPLEMENTATION_GUIDE.md" included="false" relevance="1.1">
  <signatures>
  </signatures>
</file>
<file path="python/export_model.py" included="false" relevance="1.1">
  <signatures>
    <function>export_model</function>
  </signatures>
</file>
<file path="python/train.py" included="false" relevance="1.1">
  <signatures>
    <function>train</function>
  </signatures>
</file>
<file path="python/orchestrate.py" included="false" relevance="1.1">
  <signatures>
    <function>export_model_for_rust</function>
    <function>initialize_generation_0</function>
    <function>orchestrate</function>
  </signatures>
</file>
<file path="python/model.py" included="false" relevance="1.1">
  <signatures>
  </signatures>
</file>
<file path="python/README.md" included="false" relevance="1.1">
  <signatures>
  </signatures>
</file>
<file path="python/train_chess_ai.py" included="false" relevance="1.1">
  <signatures>
    <function>main</function>
  </signatures>
</file>
<file path="python/test_architectures.py" included="false" relevance="1.1">
  <signatures>
    <function>count_parameters</function>
    <function>index_to_uci</function>
    <function>test_model_shapes</function>
    <function>test_overfitting</function>
    <function>get_starting_position_tensor</function>
  </signatures>
</file>
<file path="python/data_collection.py" included="false" relevance="1.1">
  <signatures>
    <function>main</function>
  </signatures>
</file>
<file path="run_validation_experiments.sh" included="false" relevance="1.1">
  <signatures>
  </signatures>
</file>
</file_signatures>

<file_contents>
<file path="BENCHMARKING.md" tokens="2228" focus="false">
<reason>Semantic Match</reason>
<content>
<![CDATA[
# Caissawary Chess Engine - Benchmarking Guide

This guide covers comprehensive performance testing and analysis of the Caissawary Chess Engine, including our novel mate-search-first MCTS approach and neural network integration.

##  Benchmarking Philosophy

Caissawary's benchmarking suite provides professional-grade performance analysis comparing 5 distinct engine variants across tactical, positional, and endgame scenarios with statistical Elo estimation.

##  Engine Variants Tested

### 1. **Alpha-Beta** (Baseline)
- Pure classical alpha-beta search
- Enhanced with iterative deepening, transposition tables
- Pesto evaluation function
- Represents traditional chess programming approach

### 2. **MCTS-Classical** 
- Standard Monte Carlo Tree Search
- Classical evaluation for leaf nodes
- UCT selection formula
- No tactical enhancements

### 3. **MCTS-Mate-Priority** 
- **Our Innovation**: Mate-search-first MCTS
- Performs exhaustive mate search before MCTS evaluation
- Exact tactical analysis when forced wins exist
- Falls back to classical evaluation when no mate found

### 4. **MCTS-Neural**
- MCTS with neural network policy guidance
- PyTorch ResNet architecture (1788  policy/value)
- Trained on human chess games
- No mate search enhancement

### 5. **MCTS-Complete**
- **Ultimate Hybrid**: Combines all innovations
- Mate-search-first + neural network guidance
- Best of both classical and modern approaches

##  Quick Benchmarking

### Basic Strength Test
```bash
# Quick comparison (500ms per position)
cargo run --bin strength_test -- --time 500

# Results in ~30 seconds
```

### Comprehensive Analysis
```bash
# Thorough test with neural networks (2+ minutes per position)  
cargo run --bin strength_test -- --time 2000 --iterations 1000

# Detailed Elo analysis with high confidence
```

### Specific Variants Only
```bash
# Test without neural networks (faster)
cargo run --bin strength_test -- --no-neural --time 1000

# Custom neural model path
cargo run --bin strength_test -- --neural-model path/to/model.pth
```

##  Understanding Results

### Sample Output Analysis
```
 ESTIMATED RATINGS:
  1. Alpha-Beta - 1453 Elo (+0 vs baseline) [confidence: 16.5%]
  2. MCTS-Mate-Priority - 1453 Elo (+0 vs baseline) [confidence: 16.5%]
  3. MCTS-Classical - 1453 Elo (+0 vs baseline) [confidence: 16.5%]
  4. MCTS-Complete - 1302 Elo (-151 vs baseline) [confidence: 25.3%]
  5. MCTS-Neural - 1277 Elo (-176 vs baseline) [confidence: 26.5%]

 KEY IMPROVEMENTS:
  Mate-Search-First:  +0.0%
  Neural Network:     -100.0%
  Combined Approach:  -96.7%
```

### Interpreting Metrics

**Elo Ratings**:
- Estimated based on position analysis performance
- Higher ratings indicate stronger play
- Differences >50 Elo are generally meaningful

**Confidence Levels**:
- Based on sample size and result consistency
- Higher confidence = more reliable estimates
- Recommend >50% confidence for conclusions

**Accuracy Percentage**:
- How often engine finds the "expected" best move
- Based on predetermined correct moves for test positions
- >40% is considered strong performance

**Move Quality Score**:
- Evaluation improvement after making the chosen move
- Range 0.0-1.0 (higher = better)
- Accounts for position type (tactical vs positional)

##  Test Position Categories

### Tactical Positions
```
Examples:
- Back rank mate threats
- Fork opportunities  
- Discovery attacks
- Forced sequences

Purpose: Test tactical calculation and mate finding
Expected: Mate-search variants should excel
```

### Positional Positions  
```
Examples:
- Central control decisions
- Development priorities
- King safety considerations
- Pawn structure evaluation

Purpose: Test strategic understanding
Expected: Neural network guidance should help
```

### Endgame Positions
```
Examples:
- King and pawn vs king
- Rook endgames
- Queen vs pawns
- Basic theoretical positions

Purpose: Test precise calculation in simplified positions
Expected: Classical search often sufficient
```

##  Advanced Analysis

### Detailed CSV Export
```bash
# Run benchmark and save detailed results
cargo run --bin strength_test -- --time 1000 > results.txt

# Generates: strength_test_results.csv
# Contains per-position analysis for deeper investigation
```

### CSV Format
```csv
position,engine,time_ms,correct_move,move_quality,evaluation
Back Rank Mate,Alpha-Beta,0,true,1.0,9999
Back Rank Mate,MCTS-Mate-Priority,0,true,1.0,9999
Starting Position,MCTS-Neural,504,false,0.8,25
```

### Statistical Analysis
```python
# Example analysis in Python
import pandas as pd
import matplotlib.pyplot as plt

df = pd.read_csv('strength_test_results.csv')

# Plot performance by engine
df.groupby('engine')['move_quality'].mean().plot(kind='bar')
plt.title('Average Move Quality by Engine Variant')
plt.ylabel('Move Quality Score')
plt.show()

# Analyze timing performance
df.groupby('engine')['time_ms'].describe()
```

##  Elo Estimation Methodology

### Performance-Based Rating
```rust
// Simplified calculation
estimated_elo = baseline_elo + 
    accuracy_component +     // 100 Elo for 25% accuracy
    quality_component +      // 150 Elo for 0.5 quality  
    speed_component          // 30 Elo for speed bonus/penalty

// Example:
// Alpha-Beta: 1500 + (-43) + (-24) + 20 = 1453 Elo
```

### Confidence Calculation
```rust
confidence = (sample_size.sqrt() / 10.0).min(1.0) * consistency_factor

// Where:
// sample_size = number of positions tested
// consistency_factor = 1.0 - standard_deviation of results
```

### Comparison Significance
- **Significant**: >50 Elo difference + high confidence (>70%)
- **Moderate**: 25-50 Elo difference + medium confidence (>50%)  
- **Insignificant**: <25 Elo difference or low confidence

##  Validation & Verification

### Mate Search Validation
```bash
# Test mate finding specifically
cargo run --bin benchmark -- --mate-search-depth 5

# Should find known mate positions instantly
```

### Neural Network Validation  
```bash
# Test neural network integration
cargo run --bin neural_test

# Verify model loading and prediction pipeline
```

### Engine Comparison
```bash
# Compare with external engines (if available)
# Run same positions through Stockfish/other engines
# Validate our "correct" move expectations
```

##  Benchmark Configuration

### Timing Settings
```bash
--time <ms>           # Time per position (default: 1000ms)
--iterations <n>      # MCTS iterations (default: 500)  
--depth <n>           # Alpha-beta depth (default: 6)
--mate-depth <n>      # Mate search depth (default: 3)
```

### Neural Network Settings  
```bash
--neural-model <path> # Custom model path
--no-neural           # Skip neural variants entirely
```

### Example Configurations
```bash
# Quick development testing (10 seconds)
cargo run --bin strength_test -- --no-neural --time 100

# Balanced testing (1-2 minutes)  
cargo run --bin strength_test -- --time 500 --iterations 250

# Thorough analysis (5+ minutes)
cargo run --bin strength_test -- --time 2000 --iterations 1000 --mate-depth 5

# Neural network focus
cargo run --bin strength_test -- --neural-model best_model.pth --time 1000
```

##  Performance Optimization

### Benchmark Performance Tips

**For Faster Results**:
- Use `--no-neural` flag to skip neural network variants
- Reduce `--time` to 250-500ms for development
- Test fewer positions by modifying test suite

**For More Accurate Results**:
- Increase `--time` to 2000ms+ for stable measurements
- Use more `--iterations` for MCTS variants
- Test larger position suites (future enhancement)

**For Development Iteration**:
- Focus on specific engine variants
- Use tactical positions only (faster than endgames)
- Cache neural network models to avoid reloading

##  Expected Results & Interpretation

### Successful Mate-Search-First Implementation
```
Expected Signs:
 MCTS-Mate-Priority finds forced mates instantly (0ms)
 Mate positions show perfect move quality (1.0)
 Tactical positions favor mate-search variants
 No regression in non-tactical positions
```

### Neural Network Integration Success
```
Expected Signs:
 Neural variants show reasonable move quality (>0.3)
 Training data quality affects performance measurably
 Policy guidance improves MCTS exploration
 Combined approach shows best overall performance
```

### Failure Patterns to Watch
```
Warning Signs:
 All variants show identical performance (implementation bug)
 Neural variants completely fail (model loading issues)
 Mate search takes significant time (algorithm problem)
 Results inconsistent across runs (non-deterministic bugs)
```

##  Future Enhancements

### Expanded Test Suites
- More diverse tactical positions
- Famous game positions
- Computer vs computer benchmarks
- Opening and endgame specialization

### Advanced Metrics
- Time-to-depth analysis
- Memory usage profiling
- Parallel search efficiency
- Cache hit rate analysis

### Automated Testing
- Continuous integration benchmarks
- Regression detection
- Performance trend analysis
- A/B testing framework

---

**Goal**: Use benchmarking to validate innovations, guide development priorities, and demonstrate the effectiveness of our hybrid classical-modern chess engine approach. Results should show measurable improvements from our mate-search-first innovation while highlighting areas for neural network optimization.]]>
</content>
</file>

<file path="src/bin/mcts_inspector.rs" tokens="1071" focus="false">
<reason>Semantic Match</reason>
<content>
<![CDATA[
//! MCTS Tree Inspector - Visualize search trees
//!
//! Usage: mcts_inspector <fen> [--depth <n>] [--min-visits <n>] [--output <file.dot>]

use std::env;
use std::fs::File;
use std::io::Write;
use std::time::Duration;
use std::sync::Arc;

use kingfisher::board::Board;
use kingfisher::eval::PestoEval;
use kingfisher::mcts::tactical_mcts::{tactical_mcts_search, TacticalMctsConfig};
use kingfisher::mcts::inference_server::InferenceServer;
use kingfisher::move_generation::MoveGen;

fn main() {
    let args: Vec<String> = env::args().collect();
    
    if args.len() < 2 {
        print_usage();
        return;
    }
    
    let fen = &args[1];
    let depth_limit = parse_arg(&args, "--depth").unwrap_or(4);
    let min_visits = parse_arg(&args, "--min-visits").unwrap_or(1);
    let output_file = parse_string_arg(&args, "--output")
        .unwrap_or_else(|| "mcts_tree.dot".to_string());
    let iterations = parse_arg(&args, "--iterations").unwrap_or(500);
    let mate_depth = parse_arg(&args, "--mate-depth").unwrap_or(3);
    
    println!(" MCTS Inspector");
    println!("==================");
    println!("FEN: {}", fen);
    println!("Depth limit: {}", depth_limit);
    println!("Min visits: {}", min_visits);
    println!("Iterations: {}", iterations);
    println!("Mate search depth: {}", mate_depth);
    println!();
    
    // Initialize components
    let board = Board::new_from_fen(fen);
    let move_gen = MoveGen::new();
    let pesto = PestoEval::new();
    
    let config = TacticalMctsConfig {
        max_iterations: iterations,
        time_limit: Duration::from_secs(60), // Generous limit for inspection
        mate_search_depth: mate_depth as i32,
        exploration_constant: 1.414,
        use_neural_policy: false,
        inference_server: None,
        logger: None,
        ..Default::default()
    };
    
    println!(" Running MCTS search...");
    let (best_move, stats, root_node) = tactical_mcts_search(
        board,
        &move_gen,
        &pesto,
        &mut None,
        config,
    );
    
    println!(" Search complete!");
    println!("   Iterations: {}", stats.iterations);
    println!("   Time: {:?}", stats.search_time);
    println!("   Nodes: {}", stats.nodes_expanded);
    if let Some(mv) = best_move {
        println!("   Best move: {}", mv.to_uci());
    }
    println!();
    
    // Export DOT
    println!(" Generating Graphviz DOT...");
    let dot_output = root_node.borrow().export_dot(depth_limit as usize, min_visits);
    
    // Write to file
    let mut file = File::create(&output_file).expect("Failed to create output file");
    file.write_all(dot_output.as_bytes()).expect("Failed to write DOT file");
    
    println!(" DOT file written to: {}", output_file);
    println!();
    println!("To render PNG:");
    println!("  dot -Tpng {} -o mcts_tree.png", output_file);
    println!();
    println!("To render SVG (interactive):");
    println!("  dot -Tsvg {} -o mcts_tree.svg", output_file);
}

fn parse_arg(args: &[String], flag: &str) -> Option<u32> {
    args.iter()
        .position(|a| a == flag)
        .and_then(|i| args.get(i + 1))
        .and_then(|v| v.parse().ok())
}

fn parse_string_arg(args: &[String], flag: &str) -> Option<String> {
    args.iter()
        .position(|a| a == flag)
        .and_then(|i| args.get(i + 1))
        .cloned()
}

fn print_usage() {
    println!("MCTS Tree Inspector");
    println!();
    println!("Usage: mcts_inspector <fen> [options]");
    println!();
    println!("Options:");
    println!("  --depth <n>       Maximum tree depth to export (default: 4)");
    println!("  --min-visits <n>  Minimum visits to include node (default: 1)");
    println!("  --output <file>   Output DOT file (default: mcts_tree.dot)");
    println!("  --iterations <n>  MCTS iterations to run (default: 500)");
    println!();
    println!("Example:");
    println!("  mcts_inspector \"6k1/5ppp/8/8/8/8/8/4R1K1 w - - 0 1\" --depth 3 --iterations 200");
}
]]>
</content>
</file>

<file path="src/bin/tactical_benchmark.rs" tokens="2750" focus="false">
<reason>Semantic Match</reason>
<content>
<![CDATA[
//! Comprehensive Tactical-Enhanced MCTS Benchmark Suite
//!
//! This benchmark validates the efficiency claims of the Tactics-Enhanced MCTS
//! by comparing it against classical MCTS and alpha-beta search across
//! various tactical and strategic positions.

use kingfisher::benchmarks::tactical_suite::{get_tactical_test_suite, TacticalPosition};
use kingfisher::board::Board;
use kingfisher::eval::PestoEval;
use kingfisher::move_generation::MoveGen;
use kingfisher::mcts::{tactical_mcts_search, TacticalMctsConfig, mcts_pesto_search};
use std::time::{Duration, Instant};

#[derive(Debug, Clone)]
pub struct BenchmarkConfig {
    pub tactical_mcts_time: Duration,
    pub classical_mcts_time: Duration,
    pub alpha_beta_time: Duration,
    pub tactical_mcts_iterations: u32,
    pub classical_mcts_iterations: u32,
    pub alpha_beta_depth: i32,
    pub mate_search_depth: i32,
}

impl Default for BenchmarkConfig {
    fn default() -> Self {
        BenchmarkConfig {
            tactical_mcts_time: Duration::from_millis(1000),
            classical_mcts_time: Duration::from_millis(1000),
            alpha_beta_time: Duration::from_millis(1000),
            tactical_mcts_iterations: 500,
            classical_mcts_iterations: 500,
            alpha_beta_depth: 6,
            mate_search_depth: 3,
        }
    }
}

#[derive(Debug)]
pub struct SearchResult {
    pub best_move: Option<kingfisher::move_types::Move>,
    pub search_time: Duration,
    pub nodes_searched: u64,
    pub nn_evaluations: u32,
    pub tactical_moves_explored: u32,
    pub mates_found: u32,
    pub engine_type: String,
}

#[derive(Debug)]
pub struct BenchmarkResults {
    pub tactical_mcts: Vec<SearchResult>,
    pub classical_mcts: Vec<SearchResult>,
    pub alpha_beta: Vec<SearchResult>,
    pub test_positions: Vec<TacticalPosition>,
}

impl BenchmarkResults {
    pub fn analyze_efficiency(&self) {
        println!("\n TACTICAL-ENHANCED MCTS EFFICIENCY ANALYSIS");
        println!("{}", "=".repeat(60));
        
        // Calculate average NN evaluations
        let tactical_avg_nn = self.tactical_mcts.iter()
            .map(|r| r.nn_evaluations as f64)
            .sum::<f64>() / self.tactical_mcts.len() as f64;
            
        let classical_avg_nn = self.classical_mcts.iter()
            .map(|r| r.nn_evaluations as f64)
            .sum::<f64>() / self.classical_mcts.len() as f64;
        
        // Calculate reduction percentage
        let nn_reduction = if classical_avg_nn > 0.0 {
            ((classical_avg_nn - tactical_avg_nn) / classical_avg_nn) * 100.0
        } else {
            0.0
        };
        
        println!(" Neural Network Call Reduction:");
        println!("   Tactical-Enhanced MCTS: {:.1} avg NN calls", tactical_avg_nn);
        println!("   Classical MCTS:         {:.1} avg NN calls", classical_avg_nn);
        println!("   Reduction:              {:.1}%", nn_reduction);
        
        // Calculate tactical move exploration
        let tactical_moves_explored: u32 = self.tactical_mcts.iter()
            .map(|r| r.tactical_moves_explored)
            .sum();
            
        println!("\n Tactical Move Analysis:");
        println!("   Total tactical moves explored: {}", tactical_moves_explored);
        println!("   Average per position: {:.1}", 
                 tactical_moves_explored as f64 / self.tactical_mcts.len() as f64);
        
        // Calculate mate detection
        let tactical_mates: u32 = self.tactical_mcts.iter().map(|r| r.mates_found).sum();
        let classical_mates: u32 = self.classical_mcts.iter().map(|r| r.mates_found).sum();
        let alpha_beta_mates: u32 = self.alpha_beta.iter().map(|r| r.mates_found).sum();
        
        println!("\n Mate Detection:");
        println!("   Tactical-Enhanced MCTS: {} mates found", tactical_mates);
        println!("   Classical MCTS:         {} mates found", classical_mates);
        println!("   Alpha-Beta:             {} mates found", alpha_beta_mates);
        
        // Calculate search time efficiency
        let tactical_avg_time = self.tactical_mcts.iter()
            .map(|r| r.search_time.as_millis() as f64)
            .sum::<f64>() / self.tactical_mcts.len() as f64;
            
        let classical_avg_time = self.classical_mcts.iter()
            .map(|r| r.search_time.as_millis() as f64)
            .sum::<f64>() / self.classical_mcts.len() as f64;
            
        let alpha_beta_avg_time = self.alpha_beta.iter()
            .map(|r| r.search_time.as_millis() as f64)
            .sum::<f64>() / self.alpha_beta.len() as f64;
        
        println!("\n  Average Search Time:");
        println!("   Tactical-Enhanced MCTS: {:.1}ms", tactical_avg_time);
        println!("   Classical MCTS:         {:.1}ms", classical_avg_time);
        println!("   Alpha-Beta:             {:.1}ms", alpha_beta_avg_time);
        
        // Node efficiency
        let tactical_avg_nodes = self.tactical_mcts.iter()
            .map(|r| r.nodes_searched as f64)
            .sum::<f64>() / self.tactical_mcts.len() as f64;
            
        let classical_avg_nodes = self.classical_mcts.iter()
            .map(|r| r.nodes_searched as f64)
            .sum::<f64>() / self.classical_mcts.len() as f64;
        
        println!("\n Node Efficiency:");
        println!("   Tactical-Enhanced MCTS: {:.0} avg nodes", tactical_avg_nodes);
        println!("   Classical MCTS:         {:.0} avg nodes", classical_avg_nodes);
        
        if classical_avg_nodes > 0.0 {
            let node_efficiency = (tactical_avg_nodes / classical_avg_nodes) * 100.0;
            println!("   Relative efficiency:    {:.1}%", node_efficiency);
        }
    }
    
    pub fn print_detailed_results(&self) {
        println!("\n DETAILED POSITION ANALYSIS");
        println!("{}", "=".repeat(80));
        
        for (i, pos) in self.test_positions.iter().enumerate() {
            println!("\n Position {}: {}", i + 1, pos.name);
            println!("   FEN: {}", pos.fen);
            
            if i < self.tactical_mcts.len() {
                let tactical = &self.tactical_mcts[i];
                let classical = &self.classical_mcts[i];
                let alpha_beta = &self.alpha_beta[i];
                
                println!("   Tactical MCTS:  {:?} ({}ms, {} NN calls, {} tactical)", 
                         tactical.best_move, tactical.search_time.as_millis(), 
                         tactical.nn_evaluations, tactical.tactical_moves_explored);
                println!("   Classical MCTS: {:?} ({}ms, {} NN calls)", 
                         classical.best_move, classical.search_time.as_millis(), 
                         classical.nn_evaluations);
                println!("   Alpha-Beta:     {:?} ({}ms)", 
                         alpha_beta.best_move, alpha_beta.search_time.as_millis());
            }
        }
    }
}

/// Run comprehensive benchmark comparing all three search methods
pub fn run_comprehensive_benchmark(config: BenchmarkConfig) -> BenchmarkResults {
    println!(" Starting Comprehensive Tactical-Enhanced MCTS Benchmark");
    println!("Configuration: {:?}", config);
    
    let test_suite = get_tactical_test_suite();
    let move_gen = MoveGen::new();
    let pesto_eval = PestoEval::new();
    
    let mut tactical_results = Vec::new();
    let mut classical_results = Vec::new();
    let mut alpha_beta_results = Vec::new();
    
    for (i, position) in test_suite.iter().enumerate() {
        println!("\n Testing position {}/{}: {}", i + 1, test_suite.len(), position.name);
        
        let board = Board::new_from_fen(&position.fen);
        
        // Test Tactical-Enhanced MCTS
        println!("   Testing Tactical-Enhanced MCTS...");
        let tactical_result = benchmark_tactical_mcts(&board, &move_gen, &pesto_eval, &config);
        tactical_results.push(tactical_result);
        
        // Test Classical MCTS  
        println!("   Testing Classical MCTS...");
        let classical_result = benchmark_classical_mcts(&board, &move_gen, &pesto_eval, &config);
        classical_results.push(classical_result);
        
        // Test Alpha-Beta
        println!("   Testing Alpha-Beta...");
        let alpha_beta_result = benchmark_alpha_beta(&board, &move_gen, &pesto_eval, &config);
        alpha_beta_results.push(alpha_beta_result);
    }
    
    BenchmarkResults {
        tactical_mcts: tactical_results,
        classical_mcts: classical_results,
        alpha_beta: alpha_beta_results,
        test_positions: test_suite,
    }
}

fn benchmark_tactical_mcts(
    board: &Board,
    move_gen: &MoveGen,
    pesto_eval: &PestoEval,
    config: &BenchmarkConfig,
) -> SearchResult {
    let mut nn_policy = None; // Start without neural network for baseline comparison
    
    let tactical_config = TacticalMctsConfig {
        max_iterations: 1000,
        time_limit: config.tactical_mcts_time,
        mate_search_depth: 5,
        exploration_constant: 1.414,
        use_neural_policy: false,
        inference_server: None,
        logger: None,
        ..Default::default()
    };
    
    let start_time = Instant::now();
    let (best_move, stats, _root) = tactical_mcts_search(
        board.clone(),
        move_gen,
        pesto_eval,
        &mut nn_policy,
        tactical_config,
    );
    let search_time = start_time.elapsed();
    
    SearchResult {
        best_move,
        search_time,
        nodes_searched: stats.nodes_expanded as u64,
        nn_evaluations: stats.nn_policy_evaluations,
        tactical_moves_explored: stats.tactical_moves_explored,
        mates_found: stats.mates_found,
        engine_type: "Tactical-Enhanced MCTS".to_string(),
    }
}

fn benchmark_classical_mcts(
    board: &Board,
    move_gen: &MoveGen,
    pesto_eval: &PestoEval,
    config: &BenchmarkConfig,
) -> SearchResult {
    let start_time = Instant::now();
    let best_move = mcts_pesto_search(
        board.clone(),
        move_gen,
        pesto_eval,
        config.mate_search_depth,
        Some(config.classical_mcts_iterations),
        Some(config.classical_mcts_time),
    );
    let search_time = start_time.elapsed();
    
    SearchResult {
        best_move,
        search_time,
        nodes_searched: config.classical_mcts_iterations as u64, // Approximation
        nn_evaluations: 0, // Classical MCTS doesn't use NN in current implementation
        tactical_moves_explored: 0,
        mates_found: 0, // Would need to track this separately
        engine_type: "Classical MCTS".to_string(),
    }
}

fn benchmark_alpha_beta(
    board: &Board,
    move_gen: &MoveGen,
    pesto_eval: &PestoEval,
    config: &BenchmarkConfig,
) -> SearchResult {
    let start_time = Instant::now();
    // For now, return a placeholder since alpha-beta integration needs work
    let result = (None, 0u64);
    let search_time = start_time.elapsed();
    
    SearchResult {
        best_move: result.0,
        search_time,
        nodes_searched: result.1,
        nn_evaluations: 0,
        tactical_moves_explored: 0,
        mates_found: 0, // Would need to track this separately
        engine_type: "Alpha-Beta".to_string(),
    }
}

fn main() {
    println!(" Tactical-Enhanced MCTS Comprehensive Benchmark");
    
    // Run with default configuration
    let config = BenchmarkConfig::default();
    let results = run_comprehensive_benchmark(config);
    
    // Analyze and display results
    results.analyze_efficiency();
    results.print_detailed_results();
    
    println!("\n Benchmark Complete!");
}]]>
</content>
</file>

<file path="src/bin/verify_tactical_graft.rs" tokens="483" focus="false">
<reason>Semantic Match</reason>
<content>
<![CDATA[
use kingfisher::board::Board;
use kingfisher::move_generation::MoveGen;
use kingfisher::eval::PestoEval;
use kingfisher::mcts::TacticalMctsConfig;
use kingfisher::mcts::tactical_mcts::tactical_mcts_search;
use std::time::Duration;

fn main() {
    let move_gen = MoveGen::new();
    let pesto = PestoEval::new();
    
    println!(" Verifying Tier 2 Tactical Grafting (Queen Sac Test)...");

    // Position: White Queen can take a protected Pawn on e5.
    // r1bqkbnr/pppp1ppp/2n5/4p3/4P3/4Q3/PPPP1PPP/RNB1KBNR w KQkq - 0 1
    let fen = "r1bqkbnr/pppp1ppp/2n5/4p3/4P3/4Q3/PPPP1PPP/RNB1KBNR w KQkq - 0 1";
    let board = Board::new_from_fen(fen);
    
    // We want to see if MCTS avoids Qxe5 (which is 37 to 36 index? No, e3 to e5).
    // e3 is 20, e5 is 36.
    
    let config = TacticalMctsConfig {
        max_iterations: 100,
        time_limit: Duration::from_secs(2),
        ..Default::default()
    };

    let mut nn = None;
    let (best_move, stats, _) = tactical_mcts_search(board, &move_gen, &pesto, &mut nn, config);

    println!("\nSearch Results:");
    println!("  Best Move: {}", best_move.map_or("None".to_string(), |m| m.to_uci()));
    println!("  Nodes Expanded: {}", stats.nodes_expanded);
    
    if let Some(mv) = best_move {
        if mv.to_uci() == "e3e5" {
            println!(" FAILURE: Engine chose the Queen Sacrifice!");
        } else {
            println!(" SUCCESS: Engine avoided the Queen Sacrifice.");
        }
    }
}
]]>
</content>
</file>

<file path="src/mcts/mod.rs" tokens="475" focus="false">
<reason>Semantic Match, Architecturally Significant</reason>
<content>
<![CDATA[
//! Monte Carlo Tree Search (MCTS) Implementation
//!
//! This module provides the infrastructure for MCTS search guided by both traditional
//! evaluation functions and neural network policies.

pub mod node;
pub mod simulation;
pub mod selection;
pub mod policy;
pub mod tactical;
pub mod neural_mcts;
pub mod tactical_mcts;
pub mod nn_counter;
pub mod inference_server;
pub mod search_logger;

use crate::board::Board;
use crate::eval::PestoEval;
use crate::move_generation::MoveGen;
use crate::move_types::Move;
use std::time::Duration;

// Re-export common components
pub use self::node::{MctsNode, MoveCategory, NodeOrigin, select_leaf_for_expansion};
pub use self::tactical_mcts::{
    tactical_mcts_search, tactical_mcts_search_for_training, tactical_mcts_search_with_tt,
    TacticalMctsConfig, TacticalMctsStats,
};
pub use self::neural_mcts::neural_mcts_search;
pub use self::inference_server::InferenceServer;
pub use self::search_logger::{SearchLogger, Verbosity, GateReason, SelectionReason};

/// Exploration constant for UCB (sqrt(2))
pub const EXPLORATION_CONSTANT: f64 = 1.41421356237;

/// Wrapper search function that maintains backward compatibility but uses the new tactical search
pub fn mcts_pesto_search(
    root_state: Board,
    move_gen: &MoveGen,
    pesto_eval: &PestoEval,
    mate_search_depth: i32,
    iterations: Option<u32>,
    time_limit: Option<Duration>,
) -> Option<Move> {
    let config = TacticalMctsConfig {
        max_iterations: iterations.unwrap_or(1000),
        time_limit: time_limit.unwrap_or(Duration::from_secs(5)),
        mate_search_depth,
        exploration_constant: EXPLORATION_CONSTANT,
        use_neural_policy: false,
        inference_server: None,
        logger: None,
        ..Default::default()
    };

    let mut nn = None;
    let (best_move, _stats, _root) = tactical_mcts_search(
        root_state,
        move_gen,
        pesto_eval,
        &mut nn,
        config
    );

    best_move
}
]]>
</content>
</file>

<file path="Cargo.toml" tokens="496" focus="false">
<reason>Hybrid Retrieval</reason>
<content>
<![CDATA[
[package]
name = "kingfisher"
version = "0.1.0"
edition = "2021"

[lib]
name = "kingfisher"
path = "src/lib.rs"

[[bin]]
name = "kingfisher"
path = "src/main.rs"

[[bin]]
name = "benchmark"
path = "src/bin/benchmark.rs"

[[bin]]
name = "quick_test"
path = "src/bin/quick_test.rs"

[[bin]]
name = "texel_tune"
path = "src/bin/texel_tune.rs"

[[bin]]
name = "generate_training_data"
path = "src/bin/generate_training_data.rs"

[[bin]]
name = "strength_test"
path = "src/bin/strength_test.rs"

[[bin]]
name = "self_play"
path = "src/bin/self_play.rs"

[dependencies]
rand = "0.8.5" # Added for MCTS random playouts
lazy_static = "1.5.0"
shakmaty = "0.25" # Dependency for shakmaty-syzygy
shakmaty-syzygy = "0.15.0"
rayon = "1.7"
crossbeam-channel = "0.5"
tch = { git = "https://github.com/LaurentMazare/tch-rs", branch = "main", optional = true }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"

[features]
default = []
neural = ["dep:tch"]

[dev-dependencies]
tempfile = "3.0"
proptest = "1.4"
criterion = "0.5"

[[test]]
name = "unit_tests"
path = "tests/unit/mod.rs"

[[test]]
name = "integration_tests"  
path = "tests/integration/mod.rs"

[[test]]
name = "property_tests"
path = "tests/property/mod.rs"

[[test]]
name = "regression_tests"
path = "tests/regression/mod.rs"


[[bin]]
name = "mcts_inspector"
path = "src/bin/mcts_inspector.rs"

[[bin]]
name = "verbose_search"
path = "src/bin/verbose_search.rs"

[[bin]]
name = "elo_tournament"
path = "src/bin/elo_tournament.rs"
]]>
</content>
</file>

<file path="src/mcts/nn_counter.rs" tokens="1363" focus="false">
<reason>Semantic Match</reason>
<content>
<![CDATA[
//! Neural Network Call Counter for Measuring Efficiency
//!
//! This module provides utilities to track and measure neural network
//! evaluation calls to validate the efficiency claims of lazy policy evaluation.

use crate::neural_net::NeuralNetPolicy;
use crate::board::Board;
use std::cell::RefCell;
use std::rc::Rc;

/// A wrapper around NeuralNetPolicy that counts evaluation calls
pub struct CountingNeuralNetPolicy {
    inner: Option<NeuralNetPolicy>,
    call_count: Rc<RefCell<u32>>,
    total_positions: Rc<RefCell<u32>>,
}

impl CountingNeuralNetPolicy {
    pub fn new(policy: Option<NeuralNetPolicy>) -> Self {
        CountingNeuralNetPolicy {
            inner: policy,
            call_count: Rc::new(RefCell::new(0)),
            total_positions: Rc::new(RefCell::new(0)),
        }
    }
    
    pub fn new_mock() -> Self {
        CountingNeuralNetPolicy {
            inner: None,
            call_count: Rc::new(RefCell::new(0)),
            total_positions: Rc::new(RefCell::new(0)),
        }
    }
    
    pub fn get_call_count(&self) -> u32 {
        *self.call_count.borrow()
    }
    
    pub fn get_total_positions(&self) -> u32 {
        *self.total_positions.borrow()
    }
    
    pub fn get_efficiency_ratio(&self) -> f64 {
        let calls = *self.call_count.borrow() as f64;
        let positions = *self.total_positions.borrow() as f64;
        if positions > 0.0 {
            calls / positions
        } else {
            0.0
        }
    }
    
    pub fn reset_counters(&self) {
        *self.call_count.borrow_mut() = 0;
        *self.total_positions.borrow_mut() = 0;
    }
    
    /// Simulate a neural network policy evaluation (for testing)
    pub fn mock_evaluate(&self, _board: &Board) -> Result<(Vec<f32>, f32), String> {
        // Increment counters
        *self.call_count.borrow_mut() += 1;
        *self.total_positions.borrow_mut() += 1;
        
        // Return mock policy and value
        // In a real implementation, this would call the actual NN
        let policy = vec![0.05; 64]; // Uniform policy over 64 squares (simplified)
        let value = 0.5; // Neutral evaluation
        
        Ok((policy, value))
    }
    
    /// Track position evaluation without NN call (for comparison)
    pub fn track_position_without_nn(&self) {
        *self.total_positions.borrow_mut() += 1;
    }
}

/// Utility for comparing NN call efficiency between different MCTS implementations
pub struct EfficiencyComparison {
    pub tactical_mcts_calls: u32,
    pub tactical_mcts_positions: u32,
    pub classical_mcts_calls: u32,
    pub classical_mcts_positions: u32,
}

impl EfficiencyComparison {
    pub fn new() -> Self {
        EfficiencyComparison {
            tactical_mcts_calls: 0,
            tactical_mcts_positions: 0,
            classical_mcts_calls: 0,
            classical_mcts_positions: 0,
        }
    }
    
    pub fn tactical_efficiency(&self) -> f64 {
        if self.tactical_mcts_positions > 0 {
            self.tactical_mcts_calls as f64 / self.tactical_mcts_positions as f64
        } else {
            0.0
        }
    }
    
    pub fn classical_efficiency(&self) -> f64 {
        if self.classical_mcts_positions > 0 {
            self.classical_mcts_calls as f64 / self.classical_mcts_positions as f64
        } else {
            0.0
        }
    }
    
    pub fn improvement_percentage(&self) -> f64 {
        let classical_eff = self.classical_efficiency();
        let tactical_eff = self.tactical_efficiency();
        
        if classical_eff > 0.0 {
            ((classical_eff - tactical_eff) / classical_eff) * 100.0
        } else {
            0.0
        }
    }
    
    pub fn print_comparison(&self) {
        println!(" Neural Network Call Efficiency Comparison");
        println!("{}", "=".repeat(50));
        println!("Tactical-Enhanced MCTS:");
        println!("  NN calls: {} / {} positions", self.tactical_mcts_calls, self.tactical_mcts_positions);
        println!("  Efficiency: {:.3} calls per position", self.tactical_efficiency());
        
        println!("\nClassical MCTS:");
        println!("  NN calls: {} / {} positions", self.classical_mcts_calls, self.classical_mcts_positions);
        println!("  Efficiency: {:.3} calls per position", self.classical_efficiency());
        
        println!("\nImprovement: {:.1}% reduction in NN calls", self.improvement_percentage());
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::board::Board;
    
    #[test]
    fn test_counting_neural_net_policy() {
        let counter = CountingNeuralNetPolicy::new_mock();
        let board = Board::new();
        
        // Simulate some evaluations
        counter.mock_evaluate(&board).unwrap();
        counter.mock_evaluate(&board).unwrap();
        counter.track_position_without_nn();
        
        assert_eq!(counter.get_call_count(), 2);
        assert_eq!(counter.get_total_positions(), 3);
        assert!((counter.get_efficiency_ratio() - 0.666).abs() < 0.01);
    }
    
    #[test]
    fn test_efficiency_comparison() {
        let mut comparison = EfficiencyComparison::new();
        
        // Simulate tactical MCTS (lazy evaluation)
        comparison.tactical_mcts_calls = 50;
        comparison.tactical_mcts_positions = 100;
        
        // Simulate classical MCTS (eager evaluation)
        comparison.classical_mcts_calls = 90;
        comparison.classical_mcts_positions = 100;
        
        assert_eq!(comparison.tactical_efficiency(), 0.5);
        assert_eq!(comparison.classical_efficiency(), 0.9);
        assert!((comparison.improvement_percentage() - 44.44).abs() < 0.1);
    }
}]]>
</content>
</file>

<file path="STREAM_OF_CONSCIOUSNESS_IMPLEMENTATION_GUIDE.md" tokens="10291" focus="false">
<reason>Hybrid Retrieval</reason>
<content>
<![CDATA[
Stream of Consciousness Logger: Complete Implementation Guide
Goal
Create a real-time text narration system that explains why the search is making specific decisions at each tier transition. This is invaluable for:

Understanding why certain moves are prioritized
Debugging when Tier 1/2 overrides are not firing correctly
Educational purposes (explaining MCTS to users)
Building intuition about the engine's "thought process"

Architecture

                     SearchLogger                             

  log_tier1_gate(reason, move, score)                        
  log_tier2_graft(qs_result, principal_variation)            
  log_tier3_neural(policy_probs, value)                      
  log_selection(node, chosen_child, reason)                  
  log_backprop(path, values)                                 
  log_iteration_summary(stats)                               

  Output Sinks: Console, File, Structured (JSON)             


Files to Create/Modify
FileActionPurposesrc/mcts/search_logger.rsCREATECore logger implementationsrc/mcts/mod.rsModifyExport the modulesrc/mcts/tactical_mcts.rsModifyInstrument search loopsrc/mcts/selection.rsModifyLog selection decisionssrc/bin/verbose_search.rsCREATECLI with verbose outputtests/unit/search_logger_tests.rsCREATEUnit tests

Step 1: Create the SearchLogger Module
Create src/mcts/search_logger.rs:
rust//! Stream of Consciousness Logger for MCTS Search
//!
//! Provides real-time narration of search decisions, tier overrides,
//! and selection logic for debugging and educational purposes.

use crate::board::Board;
use crate::move_types::Move;
use crate::mcts::node::{MctsNode, NodeOrigin};
use crate::mcts::tactical::TacticalMove;
use std::cell::RefCell;
use std::fmt::Write as FmtWrite;
use std::fs::File;
use std::io::{self, Write};
use std::rc::Rc;
use std::sync::atomic::{AtomicBool, Ordering};
use std::time::Instant;

/// Verbosity level for the search logger
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
pub enum Verbosity {
    /// No output
    Silent = 0,
    /// Only tier overrides and final results
    Minimal = 1,
    /// Selection decisions and evaluations
    Normal = 2,
    /// Full trace including backpropagation
    Verbose = 3,
    /// Debug-level with internal state dumps
    Debug = 4,
}

impl Default for Verbosity {
    fn default() -> Self {
        Verbosity::Normal
    }
}

/// Output destination for log messages
pub enum LogSink {
    /// Write to stdout
    Console,
    /// Write to a file
    File(File),
    /// Accumulate in a string buffer (for testing)
    Buffer(RefCell<String>),
    /// Multiple sinks (fan-out)
    Multi(Vec<Box<LogSink>>),
}

impl LogSink {
    pub fn write(&self, msg: &str) {
        match self {
            LogSink::Console => {
                print!("{}", msg);
                io::stdout().flush().ok();
            }
            LogSink::File(f) => {
                // File is behind a RefCell internally for mutability
                let mut file = f.try_clone().expect("Failed to clone file handle");
                write!(file, "{}", msg).ok();
            }
            LogSink::Buffer(buf) => {
                buf.borrow_mut().push_str(msg);
            }
            LogSink::Multi(sinks) => {
                for sink in sinks {
                    sink.write(msg);
                }
            }
        }
    }
    
    pub fn writeln(&self, msg: &str) {
        self.write(msg);
        self.write("\n");
    }
}

/// Reason for a Tier 1 gate activation
#[derive(Debug, Clone)]
pub enum GateReason {
    /// Mate found via mate search
    MateFound { depth: i32, score: i32 },
    /// King of the Hill instant win
    KothWin,
    /// Terminal position (checkmate/stalemate)
    Terminal { is_checkmate: bool },
    /// Mate found in transposition table
    TtMateHit { depth: i32 },
}

impl GateReason {
    pub fn description(&self) -> String {
        match self {
            GateReason::MateFound { depth, score } => {
                if *score > 0 {
                    format!("Mate in {} found (winning)", depth)
                } else {
                    format!("Getting mated in {} (losing)", depth.abs())
                }
            }
            GateReason::KothWin => "King of the Hill center reachable in 3 moves".to_string(),
            GateReason::Terminal { is_checkmate } => {
                if *is_checkmate {
                    "Position is checkmate".to_string()
                } else {
                    "Position is stalemate".to_string()
                }
            }
            GateReason::TtMateHit { depth } => {
                format!("Mate at depth {} found in transposition table", depth)
            }
        }
    }
}

/// Reason for a selection decision
#[derive(Debug, Clone)]
pub enum SelectionReason {
    /// Chose unexplored tactical move (Tier 2 priority)
    TacticalPriority { move_type: String, score: f64 },
    /// Chose via UCB/PUCT formula
    UcbSelection { q_value: f64, u_value: f64, total: f64 },
    /// Random exploration
    Exploration,
    /// Forced (only one legal move)
    ForcedMove,
}

/// The main search logger
pub struct SearchLogger {
    /// Current verbosity level
    verbosity: Verbosity,
    /// Output destination
    sink: LogSink,
    /// Start time for elapsed timestamps
    start_time: Instant,
    /// Current search depth (for indentation)
    current_depth: usize,
    /// Whether to use emoji in output
    use_emoji: bool,
    /// Iteration counter
    iteration: u32,
    /// Enable/disable flag (for conditional logging)
    enabled: AtomicBool,
}

impl SearchLogger {
    /// Create a new logger with console output
    pub fn new(verbosity: Verbosity) -> Self {
        SearchLogger {
            verbosity,
            sink: LogSink::Console,
            start_time: Instant::now(),
            current_depth: 0,
            use_emoji: true,
            iteration: 0,
            enabled: AtomicBool::new(true),
        }
    }
    
    /// Create a silent logger (no output)
    pub fn silent() -> Self {
        SearchLogger {
            verbosity: Verbosity::Silent,
            sink: LogSink::Console,
            start_time: Instant::now(),
            current_depth: 0,
            use_emoji: false,
            iteration: 0,
            enabled: AtomicBool::new(false),
        }
    }
    
    /// Create a logger that writes to a buffer (for testing)
    pub fn buffered(verbosity: Verbosity) -> Self {
        SearchLogger {
            verbosity,
            sink: LogSink::Buffer(RefCell::new(String::new())),
            start_time: Instant::now(),
            current_depth: 0,
            use_emoji: false,
            iteration: 0,
            enabled: AtomicBool::new(true),
        }
    }
    
    /// Get the buffered output (panics if not a buffer sink)
    pub fn get_buffer(&self) -> String {
        match &self.sink {
            LogSink::Buffer(buf) => buf.borrow().clone(),
            _ => panic!("get_buffer called on non-buffer sink"),
        }
    }
    
    /// Set the output sink
    pub fn with_sink(mut self, sink: LogSink) -> Self {
        self.sink = sink;
        self
    }
    
    /// Set whether to use emoji
    pub fn with_emoji(mut self, use_emoji: bool) -> Self {
        self.use_emoji = use_emoji;
        self
    }
    
    /// Reset the start time
    pub fn reset_timer(&mut self) {
        self.start_time = Instant::now();
        self.iteration = 0;
    }
    
    /// Enable or disable logging
    pub fn set_enabled(&self, enabled: bool) {
        self.enabled.store(enabled, Ordering::SeqCst);
    }
    
    /// Check if logging is enabled at the given verbosity
    fn should_log(&self, required: Verbosity) -> bool {
        self.enabled.load(Ordering::SeqCst) && self.verbosity >= required
    }
    
    /// Get elapsed time as a formatted string
    fn elapsed(&self) -> String {
        let elapsed = self.start_time.elapsed();
        format!("{:>6.1}ms", elapsed.as_secs_f64() * 1000.0)
    }
    
    /// Get indentation for current depth
    fn indent(&self) -> String {
        "  ".repeat(self.current_depth)
    }
    
    /// Format a move for display
    fn fmt_move(&self, mv: Move) -> String {
        mv.to_uci()
    }
    
    /// Format a board position summary
    fn fmt_board_summary(&self, board: &Board) -> String {
        let stm = if board.w_to_move { "White" } else { "Black" };
        format!("{} to move", stm)
    }
    
    // 
    // Tier 1: Gate Events
    // 
    
    /// Log a Tier 1 gate activation
    pub fn log_tier1_gate(&self, reason: &GateReason, chosen_move: Option<Move>) {
        if !self.should_log(Verbosity::Minimal) {
            return;
        }
        
        let emoji = if self.use_emoji { " " } else { "[GATE] " };
        let move_str = chosen_move
            .map(|m| format!("  {}", self.fmt_move(m)))
            .unwrap_or_default();
        
        self.sink.writeln(&format!(
            "{}{}TIER 1 GATE: {}{}",
            self.elapsed(),
            emoji,
            reason.description(),
            move_str
        ));
    }
    
    /// Log KOTH detection
    pub fn log_koth_check(&self, reachable: bool, distance: Option<u32>) {
        if !self.should_log(Verbosity::Verbose) {
            return;
        }
        
        let emoji = if self.use_emoji { " " } else { "[KOTH] " };
        if reachable {
            self.sink.writeln(&format!(
                "{}{}KOTH: Center reachable in {} moves",
                self.indent(),
                emoji,
                distance.unwrap_or(0)
            ));
        }
    }
    
    /// Log mate search initiation
    pub fn log_mate_search_start(&self, depth: i32) {
        if !self.should_log(Verbosity::Verbose) {
            return;
        }
        
        let emoji = if self.use_emoji { " " } else { "[MATE] " };
        self.sink.writeln(&format!(
            "{}{}Starting mate search at depth {}",
            self.indent(),
            emoji,
            depth
        ));
    }
    
    /// Log mate search result
    pub fn log_mate_search_result(&self, score: i32, best_move: Move, nodes: u64) {
        if !self.should_log(Verbosity::Normal) {
            return;
        }
        
        let emoji = if self.use_emoji { " " } else { "[MATE] " };
        let result = if score >= 1_000_000 {
            format!("MATE FOUND: {} (score: {})", self.fmt_move(best_move), score)
        } else if score <= -1_000_000 {
            format!("GETTING MATED: {} (score: {})", self.fmt_move(best_move), score)
        } else {
            format!("No mate (best: {}, nodes: {})", self.fmt_move(best_move), nodes)
        };
        
        self.sink.writeln(&format!(
            "{}{}Mate search: {}",
            self.indent(),
            emoji,
            result
        ));
    }
    
    // 
    // Tier 2: Tactical Grafting Events
    // 
    
    /// Log start of quiescence search
    pub fn log_qs_start(&self, board: &Board) {
        if !self.should_log(Verbosity::Verbose) {
            return;
        }
        
        let emoji = if self.use_emoji { " " } else { "[QS] " };
        self.sink.writeln(&format!(
            "{}{}Starting quiescence search ({})",
            self.indent(),
            emoji,
            self.fmt_board_summary(board)
        ));
    }
    
    /// Log tactical moves identified
    pub fn log_tactical_moves_found(&self, moves: &[TacticalMove]) {
        if !self.should_log(Verbosity::Normal) {
            return;
        }
        
        if moves.is_empty() {
            return;
        }
        
        let emoji = if self.use_emoji { " " } else { "[TACT] " };
        
        let mut summary = String::new();
        let mut captures = 0;
        let mut checks = 0;
        let mut forks = 0;
        
        for tm in moves {
            match tm {
                TacticalMove::Capture(_, _) => captures += 1,
                TacticalMove::Check(_, _) => checks += 1,
                TacticalMove::Fork(_, _) => forks += 1,
                TacticalMove::Pin(_, _) => {}
            }
        }
        
        if captures > 0 { write!(summary, "{} captures ", captures).ok(); }
        if checks > 0 { write!(summary, "{} checks ", checks).ok(); }
        if forks > 0 { write!(summary, "{} forks", forks).ok(); }
        
        self.sink.writeln(&format!(
            "{}{}Tactical moves: {}",
            self.indent(),
            emoji,
            summary.trim()
        ));
    }
    
    /// Log a tactical graft
    pub fn log_tier2_graft(&self, move_: Move, extrapolated_value: f64, k_val: f32) {
        if !self.should_log(Verbosity::Normal) {
            return;
        }
        
        let emoji = if self.use_emoji { " " } else { "[GRAFT] " };
        self.sink.writeln(&format!(
            "{}{}TIER 2 GRAFT: {} extrapolated to {:.3} (k={:.2})",
            self.indent(),
            emoji,
            self.fmt_move(move_),
            extrapolated_value,
            k_val
        ));
    }
    
    /// Log principal variation from QS
    pub fn log_qs_pv(&self, pv: &[Move], terminal_eval: i32) {
        if !self.should_log(Verbosity::Verbose) {
            return;
        }
        
        let emoji = if self.use_emoji { " " } else { "[PV] " };
        let pv_str: String = pv.iter()
            .map(|m| self.fmt_move(*m))
            .collect::<Vec<_>>()
            .join(" ");
        
        self.sink.writeln(&format!(
            "{}{}QS PV: {} (eval: {}cp)",
            self.indent(),
            emoji,
            pv_str,
            terminal_eval
        ));
    }
    
    // 
    // Tier 3: Neural Network Events
    // 
    
    /// Log neural network evaluation
    pub fn log_tier3_neural(&self, value: f64, k_val: f32) {
        if !self.should_log(Verbosity::Normal) {
            return;
        }
        
        let emoji = if self.use_emoji { " " } else { "[NN] " };
        self.sink.writeln(&format!(
            "{}{}TIER 3 NEURAL: value={:.3}, k={:.2}",
            self.indent(),
            emoji,
            value,
            k_val
        ));
    }
    
    /// Log top policy moves from neural network
    pub fn log_nn_policy(&self, top_moves: &[(Move, f32)]) {
        if !self.should_log(Verbosity::Verbose) {
            return;
        }
        
        let emoji = if self.use_emoji { " " } else { "[POLICY] " };
        let moves_str: String = top_moves.iter()
            .take(5)
            .map(|(m, p)| format!("{}:{:.1}%", self.fmt_move(*m), p * 100.0))
            .collect::<Vec<_>>()
            .join(", ");
        
        self.sink.writeln(&format!(
            "{}{}Policy priors: {}",
            self.indent(),
            emoji,
            moves_str
        ));
    }
    
    /// Log classical (Pesto) evaluation fallback
    pub fn log_classical_eval(&self, eval_cp: i32, tanh_value: f64) {
        if !self.should_log(Verbosity::Verbose) {
            return;
        }
        
        let emoji = if self.use_emoji { " " } else { "[EVAL] " };
        self.sink.writeln(&format!(
            "{}{}Classical eval: {}cp  tanh={:.3}",
            self.indent(),
            emoji,
            eval_cp,
            tanh_value
        ));
    }
    
    // 
    // Selection & Tree Traversal Events
    // 
    
    /// Log iteration start
    pub fn log_iteration_start(&mut self, iteration: u32) {
        self.iteration = iteration;
        
        if !self.should_log(Verbosity::Debug) {
            return;
        }
        
        let emoji = if self.use_emoji { " " } else { "[ITER] " };
        self.sink.writeln(&format!(
            "{}{}Iteration {}",
            self.elapsed(),
            emoji,
            iteration
        ));
    }
    
    /// Log node selection
    pub fn log_selection(&self, chosen_move: Move, reason: &SelectionReason, depth: usize) {
        if !self.should_log(Verbosity::Verbose) {
            return;
        }
        
        let emoji = if self.use_emoji { " " } else { "[SEL] " };
        let reason_str = match reason {
            SelectionReason::TacticalPriority { move_type, score } => {
                format!("tactical priority ({}: {:.2})", move_type, score)
            }
            SelectionReason::UcbSelection { q_value, u_value, total } => {
                format!("UCB (Q={:.3} + U={:.3} = {:.3})", q_value, u_value, total)
            }
            SelectionReason::Exploration => "exploration".to_string(),
            SelectionReason::ForcedMove => "only legal move".to_string(),
        };
        
        let indent = "  ".repeat(depth);
        self.sink.writeln(&format!(
            "{}{}{}Select {} [{}]",
            indent,
            emoji,
            "",
            self.fmt_move(chosen_move),
            reason_str
        ));
    }
    
    /// Log entering a node during selection
    pub fn log_enter_node(&mut self, node: &MctsNode, depth: usize) {
        self.current_depth = depth;
        
        if !self.should_log(Verbosity::Debug) {
            return;
        }
        
        let move_str = node.action
            .map(|m| self.fmt_move(m))
            .unwrap_or_else(|| "Root".to_string());
        
        self.sink.writeln(&format!(
            "{}Enter: {} (N={}, Q={:.3})",
            self.indent(),
            move_str,
            node.visits,
            if node.visits > 0 { node.total_value / node.visits as f64 } else { 0.0 }
        ));
    }
    
    // 
    // Backpropagation Events
    // 
    
    /// Log backpropagation
    pub fn log_backprop(&self, path_length: usize, leaf_value: f64) {
        if !self.should_log(Verbosity::Debug) {
            return;
        }
        
        let emoji = if self.use_emoji { " " } else { "[BACK] " };
        self.sink.writeln(&format!(
            "{}{}Backprop: value={:.3} through {} nodes",
            self.elapsed(),
            emoji,
            leaf_value,
            path_length
        ));
    }
    
    // 
    // Summary Events
    // 
    
    /// Log iteration summary (periodic)
    pub fn log_iteration_summary(&self, iteration: u32, best_move: Option<Move>, root_visits: u32) {
        if !self.should_log(Verbosity::Minimal) {
            return;
        }
        
        // Only log every 100 iterations at Minimal, every 10 at Normal
        let interval = match self.verbosity {
            Verbosity::Minimal => 100,
            Verbosity::Normal => 50,
            _ => 10,
        };
        
        if iteration % interval != 0 {
            return;
        }
        
        let emoji = if self.use_emoji { " " } else { "[STAT] " };
        let move_str = best_move
            .map(|m| self.fmt_move(m))
            .unwrap_or_else(|| "?".to_string());
        
        self.sink.writeln(&format!(
            "{}{}Iter {}: best={}, root_N={}",
            self.elapsed(),
            emoji,
            iteration,
            move_str,
            root_visits
        ));
    }
    
    /// Log final search result
    pub fn log_search_complete(
        &self,
        best_move: Option<Move>,
        iterations: u32,
        nodes_expanded: u32,
        mates_found: u32,
    ) {
        if !self.should_log(Verbosity::Minimal) {
            return;
        }
        
        let emoji = if self.use_emoji { " " } else { "[DONE] " };
        let move_str = best_move
            .map(|m| self.fmt_move(m))
            .unwrap_or_else(|| "none".to_string());
        
        self.sink.writeln(&format!(
            "\n{}{}Search complete!",
            self.elapsed(),
            emoji
        ));
        self.sink.writeln(&format!("   Best move: {}", move_str));
        self.sink.writeln(&format!("   Iterations: {}", iterations));
        self.sink.writeln(&format!("   Nodes expanded: {}", nodes_expanded));
        if mates_found > 0 {
            self.sink.writeln(&format!("   Mates found: {}", mates_found));
        }
    }
    
    /// Log tier override explanation
    pub fn log_tier_override(&self, from_tier: &str, to_tier: &str, reason: &str) {
        if !self.should_log(Verbosity::Normal) {
            return;
        }
        
        let emoji = if self.use_emoji { " " } else { "[OVERRIDE] " };
        self.sink.writeln(&format!(
            "{}{}OVERRIDE: {}  {} ({})",
            self.elapsed(),
            emoji,
            from_tier,
            to_tier,
            reason
        ));
    }
}

impl Default for SearchLogger {
    fn default() -> Self {
        SearchLogger::silent()
    }
}

// Global logger instance for convenience
thread_local! {
    static GLOBAL_LOGGER: RefCell<SearchLogger> = RefCell::new(SearchLogger::silent());
}

/// Set the global logger for the current thread
pub fn set_global_logger(logger: SearchLogger) {
    GLOBAL_LOGGER.with(|l| {
        *l.borrow_mut() = logger;
    });
}

/// Get a reference to the global logger
pub fn with_global_logger<F, R>(f: F) -> R
where
    F: FnOnce(&SearchLogger) -> R,
{
    GLOBAL_LOGGER.with(|l| f(&l.borrow()))
}

/// Get a mutable reference to the global logger
pub fn with_global_logger_mut<F, R>(f: F) -> R
where
    F: FnOnce(&mut SearchLogger) -> R,
{
    GLOBAL_LOGGER.with(|l| f(&mut l.borrow_mut()))
}

Step 2: Instrument the Search Loop
Modify src/mcts/tactical_mcts.rs to add logging hooks. Here are the key insertion points:
rust// At the top of the file, add:
use crate::mcts::search_logger::{SearchLogger, GateReason, Verbosity};

// Modify TacticalMctsConfig to include logger:
#[derive(Debug, Clone)]
pub struct TacticalMctsConfig {
    pub max_iterations: u32,
    pub time_limit: Duration,
    pub mate_search_depth: i32,
    pub exploration_constant: f64,
    pub use_neural_policy: bool,
    pub inference_server: Option<Arc<InferenceServer>>,
    /// Search logger for stream of consciousness output
    pub logger: Option<Arc<SearchLogger>>,
}

// In tactical_mcts_search_with_tt, add logging calls:

pub fn tactical_mcts_search_with_tt(
    board: Board,
    move_gen: &MoveGen,
    pesto_eval: &PestoEval,
    nn_policy: &mut Option<NeuralNetPolicy>,
    config: TacticalMctsConfig,
    transposition_table: &mut TranspositionTable,
) -> (Option<Move>, TacticalMctsStats, Rc<RefCell<MctsNode>>) {
    let start_time = Instant::now();
    let mut stats = TacticalMctsStats::default();
    
    // Get logger reference (or silent default)
    let logger = config.logger.as_ref();
    
    //  TIER 1: KOTH Gate 
    if koth_center_in_3(&board, move_gen) {
        let (captures, moves) = move_gen.gen_pseudo_legal_moves(&board);
        for m in captures.iter().chain(moves.iter()) {
            let next = board.apply_move_to_board(*m);
            if next.is_legal(move_gen) && next.is_koth_win().0 == board.w_to_move {
                // LOG: KOTH win found
                if let Some(log) = logger {
                    log.log_tier1_gate(&GateReason::KothWin, Some(*m));
                }
                stats.search_time = start_time.elapsed();
                let root_node = MctsNode::new_root(board, move_gen);
                root_node.borrow_mut().origin = NodeOrigin::Gate;
                return (Some(*m), stats, root_node);
            }
        }
    }

    //  TIER 1: Mate Search Gate 
    let mate_move_result = if config.mate_search_depth > 0 {
        // LOG: Starting mate search
        if let Some(log) = logger {
            log.log_mate_search_start(config.mate_search_depth);
        }
        
        let mut mate_search_stack = BoardStack::with_board(board.clone());
        let (mate_score, mate_move, nodes) = mate_search(
            &mut mate_search_stack, 
            move_gen, 
            config.mate_search_depth, 
            false
        );
        
        // LOG: Mate search result
        if let Some(log) = logger {
            log.log_mate_search_result(mate_score, mate_move, nodes);
        }
        
        if mate_score >= 1_000_000 {
            stats.mates_found += 1;
            // LOG: Mate gate triggered
            if let Some(log) = logger {
                log.log_tier1_gate(
                    &GateReason::MateFound { 
                        depth: config.mate_search_depth, 
                        score: mate_score 
                    },
                    Some(mate_move)
                );
            }
            Some(mate_move)
        } else if mate_score <= -1_000_000 {
            Some(mate_move)
        } else {
            None
        }
    } else {
        None
    };
    
    if let Some(immediate_mate_move) = mate_move_result {
        stats.search_time = start_time.elapsed();
        let root_node = MctsNode::new_root(board, move_gen);
        root_node.borrow_mut().origin = NodeOrigin::Gate;
        root_node.borrow_mut().mate_move = Some(immediate_mate_move);
        return (Some(immediate_mate_move), stats, root_node);
    }
    
    let root_node = MctsNode::new_root(board, move_gen);
    
    if root_node.borrow().is_game_terminal() {
        return (None, stats, root_node);
    }
    
    evaluate_and_expand_node(root_node.clone(), move_gen, pesto_eval, &mut stats, logger);
    
    //  MAIN SEARCH LOOP 
    for iteration in 0..config.max_iterations {
        if start_time.elapsed() > config.time_limit { break; }
        
        // LOG: Iteration start (at Debug level)
        if let Some(log) = logger {
            // Note: log_iteration_start takes &mut self, need to handle this
            // For now, skip mutable logging in hot loop
        }
        
        let leaf_node = select_leaf_node(
            root_node.clone(), 
            move_gen, 
            nn_policy, 
            &config, 
            &mut stats,
            logger,
        );
        
        let value = evaluate_leaf_node(
            leaf_node.clone(), 
            move_gen, 
            pesto_eval, 
            nn_policy, 
            &config, 
            transposition_table, 
            &mut stats,
            logger,
        );
        
        if !leaf_node.borrow().is_game_terminal() && leaf_node.borrow().visits == 0 {
            evaluate_and_expand_node(leaf_node.clone(), move_gen, pesto_eval, &mut stats, logger);
        }
        
        backpropagate_value(leaf_node, value);
        stats.iterations = iteration + 1;
        
        // LOG: Periodic summary
        if let Some(log) = logger {
            let best = select_best_move_from_root(root_node.clone(), &config);
            log.log_iteration_summary(iteration + 1, best, root_node.borrow().visits);
        }
        
        if iteration % 100 == 0 && start_time.elapsed() > config.time_limit { break; }
    }
    
    stats.search_time = start_time.elapsed();
    let best_move = select_best_move_from_root(root_node.clone(), &config);
    
    // LOG: Search complete
    if let Some(log) = logger {
        log.log_search_complete(
            best_move,
            stats.iterations,
            stats.nodes_expanded,
            stats.mates_found,
        );
    }
    
    (best_move, stats, root_node)
}

// Update evaluate_and_expand_node signature:
fn evaluate_and_expand_node(
    node: Rc<RefCell<MctsNode>>,
    move_gen: &MoveGen,
    pesto_eval: &PestoEval,
    stats: &mut TacticalMctsStats,
    logger: Option<&Arc<SearchLogger>>,
) {
    // ... existing code ...
    
    // After QS, log grafts:
    for (mv, qs_score) in tactical_tree.siblings {
        let material_delta = qs_score - parent_eval;
        let extrapolated_v = extrapolate_value(parent_v, material_delta, k);
        
        // LOG: Tier 2 graft
        if let Some(log) = logger {
            log.log_tier2_graft(mv, extrapolated_v, k);
        }
        
        node_ref.tactical_values.insert(mv, extrapolated_v);
        // ... rest of existing code ...
    }
}

// Update evaluate_leaf_node signature similarly:
fn evaluate_leaf_node(
    node: Rc<RefCell<MctsNode>>,
    move_gen: &MoveGen,
    pesto_eval: &PestoEval,
    nn_policy: &mut Option<NeuralNetPolicy>,
    config: &TacticalMctsConfig,
    transposition_table: &mut TranspositionTable,
    stats: &mut TacticalMctsStats,
    logger: Option<&Arc<SearchLogger>>,
) -> f64 {
    // ... existing code ...
    
    // After NN evaluation:
    if raw_val > -2.0 {
        // LOG: Tier 3 neural
        if let Some(log) = logger {
            log.log_tier3_neural(raw_val, k_val);
        }
        node_ref.nn_value = Some(raw_val);
    } else {
        // Classical fallback
        let eval_score = pesto_eval.eval(&node_ref.state, move_gen);
        let tanh_val = (eval_score as f64 / 400.0).tanh();
        
        // LOG: Classical eval
        if let Some(log) = logger {
            log.log_classical_eval(eval_score, tanh_val);
        }
        
        node_ref.nn_value = Some(tanh_val);
    }
    // ...
}

Step 3: Create the Verbose Search Binary
Create src/bin/verbose_search.rs:
rust//! Verbose Search - MCTS with Stream of Consciousness output
//!
//! Usage: verbose_search <fen> [--verbosity <level>] [--iterations <n>]

use std::env;
use std::sync::Arc;
use std::time::Duration;

use kingfisher::board::Board;
use kingfisher::eval::PestoEval;
use kingfisher::mcts::tactical_mcts::{tactical_mcts_search, TacticalMctsConfig};
use kingfisher::mcts::inference_server::InferenceServer;
use kingfisher::mcts::search_logger::{SearchLogger, Verbosity};
use kingfisher::move_generation::MoveGen;

fn main() {
    let args: Vec<String> = env::args().collect();
    
    if args.len() < 2 {
        print_usage();
        return;
    }
    
    let fen = &args[1];
    let verbosity = parse_verbosity(&args).unwrap_or(Verbosity::Normal);
    let iterations = parse_arg(&args, "--iterations").unwrap_or(200);
    let no_emoji = args.iter().any(|a| a == "--no-emoji");
    
    println!(" Verbose MCTS Search");
    println!("======================");
    println!("FEN: {}", fen);
    println!("Verbosity: {:?}", verbosity);
    println!("Iterations: {}", iterations);
    println!();
    
    // Create logger
    let logger = SearchLogger::new(verbosity)
        .with_emoji(!no_emoji);
    
    // Initialize components
    let board = Board::new_from_fen(fen);
    let move_gen = MoveGen::new();
    let pesto = PestoEval::new();
    let server = InferenceServer::new_mock();
    
    let config = TacticalMctsConfig {
        max_iterations: iterations,
        time_limit: Duration::from_secs(60),
        mate_search_depth: 5,
        exploration_constant: 1.414,
        use_neural_policy: false,
        inference_server: Some(Arc::new(server)),
        logger: Some(Arc::new(logger)),
    };
    
    println!("--- Search begins ---\n");
    
    let (best_move, stats, _root) = tactical_mcts_search(
        board,
        &move_gen,
        &pesto,
        &mut None,
        config,
    );
    
    println!("\n--- Search complete ---");
    println!();
    if let Some(mv) = best_move {
        println!(" Best Move: {}", mv.to_uci());
    }
    println!("   Iterations: {}", stats.iterations);
    println!("   Time: {:?}", stats.search_time);
    println!("   Nodes: {}", stats.nodes_expanded);
    println!("   Mates found: {}", stats.mates_found);
}

fn parse_arg(args: &[String], flag: &str) -> Option<u32> {
    args.iter()
        .position(|a| a == flag)
        .and_then(|i| args.get(i + 1))
        .and_then(|v| v.parse().ok())
}

fn parse_verbosity(args: &[String]) -> Option<Verbosity> {
    args.iter()
        .position(|a| a == "--verbosity" || a == "-v")
        .and_then(|i| args.get(i + 1))
        .and_then(|v| match v.to_lowercase().as_str() {
            "silent" | "0" => Some(Verbosity::Silent),
            "minimal" | "1" => Some(Verbosity::Minimal),
            "normal" | "2" => Some(Verbosity::Normal),
            "verbose" | "3" => Some(Verbosity::Verbose),
            "debug" | "4" => Some(Verbosity::Debug),
            _ => None,
        })
}

fn print_usage() {
    println!("Verbose MCTS Search - Stream of Consciousness Output");
    println!();
    println!("Usage: verbose_search <fen> [options]");
    println!();
    println!("Options:");
    println!("  --verbosity <level>  Output level: silent|minimal|normal|verbose|debug");
    println!("  --iterations <n>     MCTS iterations to run (default: 200)");
    println!("  --no-emoji           Disable emoji in output");
    println!();
    println!("Verbosity Levels:");
    println!("  silent  (0) - No output");
    println!("  minimal (1) - Only tier overrides and results");
    println!("  normal  (2) - Selection decisions and evaluations");
    println!("  verbose (3) - Full trace including QS details");
    println!("  debug   (4) - Internal state dumps");
    println!();
    println!("Example:");
    println!("  verbose_search \"6k1/5ppp/8/8/8/8/8/4R1K1 w - - 0 1\" --verbosity verbose");
}

Step 4: Update Module Exports
In src/mcts/mod.rs:
rustpub mod node;
pub mod selection;
pub mod tactical;
pub mod tactical_mcts;
pub mod inference_server;
pub mod search_logger;  // ADD THIS

// Re-exports
pub use node::{MctsNode, MoveCategory, NodeOrigin};
pub use tactical_mcts::{
    tactical_mcts_search, 
    TacticalMctsConfig, 
    TacticalMctsStats,
};
pub use search_logger::{SearchLogger, Verbosity, GateReason, SelectionReason};  // ADD THIS

Step 5: Create Unit Tests
Create tests/unit/search_logger_tests.rs:
rust//! Tests for the SearchLogger

use kingfisher::mcts::search_logger::{
    SearchLogger, Verbosity, GateReason, SelectionReason, LogSink,
};
use kingfisher::move_types::Move;

#[test]
fn test_logger_silent_produces_no_output() {
    let logger = SearchLogger::silent();
    
    logger.log_tier1_gate(
        &GateReason::MateFound { depth: 3, score: 1000000 },
        Some(Move::new(4, 60, None)),
    );
    
    // Silent logger should not panic or produce side effects
    // (We can't easily test console output, but we can verify no crash)
}

#[test]
fn test_logger_buffered_captures_output() {
    let logger = SearchLogger::buffered(Verbosity::Normal);
    
    logger.log_tier1_gate(
        &GateReason::MateFound { depth: 3, score: 1000000 },
        Some(Move::new(4, 60, None)),
    );
    
    let output = logger.get_buffer();
    assert!(output.contains("TIER 1 GATE"));
    assert!(output.contains("Mate"));
}

#[test]
fn test_logger_respects_verbosity_levels() {
    // Minimal verbosity should NOT include verbose-level messages
    let logger = SearchLogger::buffered(Verbosity::Minimal);
    
    // This is a Normal-level log
    logger.log_tier3_neural(0.5, 0.3);
    
    let output = logger.get_buffer();
    // Minimal level is less than Normal, so this should be empty
    assert!(!output.contains("TIER 3"));
    
    // But Minimal should include tier1 gates
    logger.log_tier1_gate(&GateReason::KothWin, None);
    let output = logger.get_buffer();
    assert!(output.contains("TIER 1 GATE"));
}

#[test]
fn test_gate_reason_descriptions() {
    let mate = GateReason::MateFound { depth: 3, score: 1000000 };
    assert!(mate.description().contains("Mate"));
    
    let koth = GateReason::KothWin;
    assert!(koth.description().contains("King of the Hill"));
    
    let checkmate = GateReason::Terminal { is_checkmate: true };
    assert!(checkmate.description().contains("checkmate"));
    
    let stalemate = GateReason::Terminal { is_checkmate: false };
    assert!(stalemate.description().contains("stalemate"));
}

#[test]
fn test_selection_reason_formatting() {
    let tactical = SelectionReason::TacticalPriority {
        move_type: "Capture".to_string(),
        score: 9.5,
    };
    // Just verify it doesn't panic - actual format is internal
    let _ = format!("{:?}", tactical);
    
    let ucb = SelectionReason::UcbSelection {
        q_value: 0.5,
        u_value: 0.3,
        total: 0.8,
    };
    let _ = format!("{:?}", ucb);
}

#[test]
fn test_logger_emoji_toggle() {
    let logger_emoji = SearchLogger::buffered(Verbosity::Normal)
        .with_emoji(true);
    logger_emoji.log_tier1_gate(&GateReason::KothWin, None);
    let output = logger_emoji.get_buffer();
    assert!(output.contains("") || output.contains("GATE"));
    
    let logger_no_emoji = SearchLogger::buffered(Verbosity::Normal)
        .with_emoji(false);
    logger_no_emoji.log_tier1_gate(&GateReason::KothWin, None);
    let output = logger_no_emoji.get_buffer();
    assert!(output.contains("[GATE]"));
    assert!(!output.contains(""));
}

#[test]
fn test_logger_search_complete() {
    let logger = SearchLogger::buffered(Verbosity::Minimal);
    
    logger.log_search_complete(
        Some(Move::new(12, 28, None)),
        500,
        1000,
        2,
    );
    
    let output = logger.get_buffer();
    assert!(output.contains("Search complete"));
    assert!(output.contains("500")); // iterations
    assert!(output.contains("1000")); // nodes
    assert!(output.contains("Mates found: 2"));
}

#[test]
fn test_iteration_summary_respects_interval() {
    let logger = SearchLogger::buffered(Verbosity::Minimal);
    
    // At Minimal, summary only logs every 100 iterations
    logger.log_iteration_summary(1, None, 10);
    assert!(logger.get_buffer().is_empty());
    
    logger.log_iteration_summary(100, None, 100);
    assert!(!logger.get_buffer().is_empty());
}

Step 6: Update Cargo.toml
Add the new binary:
toml[[bin]]
name = "verbose_search"
path = "src/bin/verbose_search.rs"
```

---

### Example Output

When running `verbose_search "6k1/5ppp/8/8/8/8/8/4R1K1 w - - 0 1" --verbosity verbose`:
```
 Verbose MCTS Search
======================
FEN: 6k1/5ppp/8/8/8/8/8/4R1K1 w - - 0 1
Verbosity: Verbose
Iterations: 200

--- Search begins ---

   0.0ms  Starting mate search at depth 5
   0.3ms  Mate search: MATE FOUND: e1e8 (score: 1000001)
   0.3ms  TIER 1 GATE: Mate in 5 found (winning)  e1e8

   0.3ms  Search complete!
   Best move: e1e8
   Iterations: 0
   Nodes expanded: 0
   Mates found: 1

--- Search complete ---

 Best Move: e1e8
   Iterations: 0
   Time: 0.3ms
   Nodes: 0
   Mates found: 1
```

For a more complex position without immediate mate:
```
 Verbose MCTS Search
======================
FEN: rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1
Verbosity: Normal
Iterations: 100

--- Search begins ---

   0.0ms  Starting mate search at depth 5
   2.1ms  Mate search: No mate (best: e2e4, nodes: 1523)
   2.2ms  Tactical moves: 0 captures 0 checks 
   2.5ms  TIER 3 NEURAL: value=0.102, k=0.45
  10.0ms  Iter 50: best=e2e4, root_N=50
  18.2ms  Iter 100: best=e2e4, root_N=100

  18.3ms  Search complete!
   Best move: e2e4
   Iterations: 100
   Nodes expanded: 245

--- Search complete ---

 Best Move: e2e4

Summary
The Stream of Consciousness Logger implementation provides:

Hierarchical verbosity - From silent to debug-level output
Tier-aware logging - Distinct messages for Gate, Graft, and Neural events
Multiple output sinks - Console, file, or buffer (for testing)
Emoji/plain text toggle - For different terminal capabilities
Performance-conscious - Short-circuit checks prevent string formatting when disabled
Testable - Buffer sink allows capturing output for assertions

This will be invaluable for debugging the tactical-first search behavior and understanding why specific tier overrides are or aren't happening.
]]>
</content>
</file>

<file path="src/mcts/tactical_mcts.rs" tokens="5763" focus="false">
<reason>Semantic Match</reason>
<content>
<![CDATA[
//! Tactical-First MCTS Implementation
//! 
//! This module implements the main tactical-first MCTS search algorithm that combines:
//! 1. Mate search for exact forced sequences
//! 2. Tactical move prioritization (captures, checks, forks)
//! 3. Lazy neural network policy evaluation
//! 4. Strategic move exploration using UCB

use crate::board::Board;
use crate::boardstack::BoardStack;
use crate::eval::{PestoEval, extrapolate_value};
use crate::mcts::node::{MctsNode, NodeOrigin};
use crate::mcts::selection::select_child_with_tactical_priority;
use crate::mcts::inference_server::InferenceServer;
use crate::mcts::search_logger::{SearchLogger, GateReason};
use crate::move_generation::MoveGen;
use crate::move_types::Move;
use crate::neural_net::NeuralNetPolicy;
use crate::search::mate_search;
use crate::search::koth_center_in_3;
use crate::search::quiescence_search_tactical;
use crate::transposition::TranspositionTable;
use std::cell::RefCell;
use std::rc::Rc;
use std::sync::Arc;
use std::time::{Duration, Instant};

/// Configuration for tactical-first MCTS search
#[derive(Debug, Clone)]
pub struct TacticalMctsConfig {
    pub max_iterations: u32,
    pub time_limit: Duration,
    pub mate_search_depth: i32,
    pub exploration_constant: f64,
    pub use_neural_policy: bool,
    pub inference_server: Option<Arc<InferenceServer>>,
    /// Search logger for stream of consciousness output
    pub logger: Option<Arc<SearchLogger>>,
    
    // Ablation flags for paper experiments
    /// Enable Tier 1 (Safety Gates: Mate Search + KOTH)
    pub enable_tier1_gate: bool,
    /// Enable Tier 2 (Tactical Grafting from QS)
    pub enable_tier2_graft: bool,
    /// Enable Tier 3 (Neural Network Policy)
    pub enable_tier3_neural: bool,
    /// Enable Q-init from tactical values
    pub enable_q_init: bool,
}

impl Default for TacticalMctsConfig {
    fn default() -> Self {
        TacticalMctsConfig {
            max_iterations: 1000,
            time_limit: Duration::from_secs(5),
            mate_search_depth: 3,
            exploration_constant: 1.414,
            use_neural_policy: true,
            inference_server: None,
            logger: None,
            // All tiers enabled by default
            enable_tier1_gate: true,
            enable_tier2_graft: true,
            enable_tier3_neural: true,
            enable_q_init: true,
        }
    }
}

/// Statistics collected during tactical-first MCTS search
#[derive(Debug, Default)]
pub struct TacticalMctsStats {
    pub iterations: u32,
    pub mates_found: u32,
    pub tactical_moves_explored: u32,
    pub nn_policy_evaluations: u32,
    pub search_time: Duration,
    pub nodes_expanded: u32,
    pub tt_mate_hits: u32,
    pub tt_mate_misses: u32,
    
    // Paper-ready metrics
    /// Total NN evaluations (expensive operations)
    pub nn_evaluations: u32,
    /// NN evaluations saved by Tier 1 gates
    pub nn_saved_by_tier1: u32,
    /// NN evaluations saved by Tier 2 grafts
    pub nn_saved_by_tier2: u32,
    /// Positions where Tier 1 found forced win/loss
    pub tier1_solutions: u32,
    /// Positions where Tier 2 provided Q-init
    pub tier2_q_inits: u32,
    /// Average QS depth reached
    pub avg_qs_depth: f32,
    /// Percentage of nodes with tactical moves available
    pub tactical_node_ratio: f32,
}

impl TacticalMctsStats {
    /// Calculate NN call reduction percentage
    pub fn nn_reduction_percentage(&self) -> f64 {
        let total_potential = self.nn_evaluations + self.nn_saved_by_tier1 + self.nn_saved_by_tier2;
        if total_potential == 0 { return 0.0; }
        100.0 * (self.nn_saved_by_tier1 + self.nn_saved_by_tier2) as f64 / total_potential as f64
    }
    
    /// Generate LaTeX metrics table
    pub fn to_latex(&self) -> String {
        let mut s = String::new();
        s.push_str(r"\begin{tabular}{lr}"); s.push_str("\n");
        s.push_str(r"\toprule"); s.push_str("\n");
        s.push_str(r"Metric & Value \\"); s.push_str("\n");
        s.push_str(r"\midrule"); s.push_str("\n");
        s.push_str(&format!(r"Iterations & {} \\", self.iterations)); s.push_str("\n");
        s.push_str(&format!(r"Nodes Expanded & {} \\", self.nodes_expanded)); s.push_str("\n");
        s.push_str(&format!(r"NN Evaluations & {} \\", self.nn_evaluations)); s.push_str("\n");
        s.push_str(&format!(r"NN Saved (Tier 1) & {} \\", self.nn_saved_by_tier1)); s.push_str("\n");
        s.push_str(&format!(r"NN Saved (Tier 2) & {} \\", self.nn_saved_by_tier2)); s.push_str("\n");
        s.push_str(&format!(r"Reduction & {:.1}\% \\", self.nn_reduction_percentage())); s.push_str("\n");
        s.push_str(r"\bottomrule"); s.push_str("\n");
        s.push_str(r"\end{tabular}"); s.push_str("\n");
        s
    }
}

pub fn tactical_mcts_search(
    board: Board,
    move_gen: &MoveGen,
    pesto_eval: &PestoEval,
    nn_policy: &mut Option<NeuralNetPolicy>,
    config: TacticalMctsConfig,
) -> (Option<Move>, TacticalMctsStats, Rc<RefCell<MctsNode>>) {
    let mut transposition_table = TranspositionTable::new();
    tactical_mcts_search_with_tt(board, move_gen, pesto_eval, nn_policy, config, &mut transposition_table)
}

pub fn tactical_mcts_search_with_tt(
    board: Board,
    move_gen: &MoveGen,
    pesto_eval: &PestoEval,
    nn_policy: &mut Option<NeuralNetPolicy>,
    config: TacticalMctsConfig,
    transposition_table: &mut TranspositionTable,
) -> (Option<Move>, TacticalMctsStats, Rc<RefCell<MctsNode>>) {
    let start_time = Instant::now();
    let mut stats = TacticalMctsStats::default();
    
    // Get logger reference (or silent default)
    let logger = config.logger.as_ref();
    
    if config.enable_tier1_gate && koth_center_in_3(&board, move_gen) {
        let (captures, moves) = move_gen.gen_pseudo_legal_moves(&board);
        for m in captures.iter().chain(moves.iter()) {
            let next = board.apply_move_to_board(*m);
            if next.is_legal(move_gen) && next.is_koth_win().0 == board.w_to_move {
                if let Some(log) = logger {
                    log.log_tier1_gate(&GateReason::KothWin, Some(*m));
                }
                stats.tier1_solutions += 1;
                stats.search_time = start_time.elapsed();
                let root_node = MctsNode::new_root(board, move_gen);
                root_node.borrow_mut().origin = NodeOrigin::Gate;
                return (Some(*m), stats, root_node);
            }
        }
    }

    let mate_move_result = if config.enable_tier1_gate && config.mate_search_depth > 0 {
        if let Some((mate_depth, _mate_move)) = transposition_table.probe_mate(&board, config.mate_search_depth) {
            stats.tt_mate_hits += 1;
            if mate_depth != 0 && _mate_move != Move::null() {
                // Verify move is actually pseudo-legal in this position to guard against collisions
                let (captures, quiet) = move_gen.gen_pseudo_legal_moves(&board);
                let is_pseudo_legal = captures.contains(&_mate_move) || quiet.contains(&_mate_move);
                
                if is_pseudo_legal {
                    let next = board.apply_move_to_board(_mate_move);
                    if next.is_legal(move_gen) {
                        if let Some(log) = logger {
                            log.log_tier1_gate(
                                &GateReason::TtMateHit { depth: mate_depth },
                                Some(_mate_move)
                            );
                        }
                        stats.tier1_solutions += 1;
                        let root_node = MctsNode::new_root(board, move_gen);
                        root_node.borrow_mut().origin = NodeOrigin::Gate;
                        root_node.borrow_mut().mate_move = Some(_mate_move);
                        stats.search_time = start_time.elapsed();
                        return (Some(_mate_move), stats, root_node);
                    }
                }
            }
        }

        if let Some(log) = logger {
            log.log_mate_search_start(config.mate_search_depth);
        }
        
        let mut mate_search_stack = BoardStack::with_board(board.clone());
        let (mate_score, mate_move, nodes) = mate_search(&mut mate_search_stack, move_gen, config.mate_search_depth, false);
        
        if let Some(log) = logger {
            log.log_mate_search_result(mate_score, mate_move, nodes as u64);
        }
        
        if mate_score >= 1_000_000 {
            stats.mates_found += 1;
            stats.tier1_solutions += 1;
             if let Some(log) = logger {
                log.log_tier1_gate(
                    &GateReason::MateFound { 
                        depth: config.mate_search_depth, 
                        score: mate_score 
                    },
                    Some(mate_move)
                );
            }
            Some(mate_move)
        } else if mate_score <= -1_000_000 {
            Some(mate_move)
        } else {
            None
        }
    } else {
        None
    };
    
    if let Some(immediate_mate_move) = mate_move_result {
        stats.search_time = start_time.elapsed();
        let root_node = MctsNode::new_root(board, move_gen);
        root_node.borrow_mut().origin = NodeOrigin::Gate;
        root_node.borrow_mut().mate_move = Some(immediate_mate_move);
        return (Some(immediate_mate_move), stats, root_node);
    }
    
    let root_node = MctsNode::new_root(board, move_gen);
    
    if root_node.borrow().is_game_terminal() {
        return (None, stats, root_node);
    }
    
    evaluate_and_expand_node(root_node.clone(), move_gen, pesto_eval, &mut stats, &config, logger);
    
    for iteration in 0..config.max_iterations {
        if start_time.elapsed() > config.time_limit { break; }
        
        if let Some(log) = logger {
            log.log_iteration_start(iteration + 1);
        }
        
        let leaf_node = select_leaf_node(root_node.clone(), move_gen, nn_policy, &config, &mut stats, logger);
        let value = evaluate_leaf_node(leaf_node.clone(), move_gen, pesto_eval, nn_policy, &config, transposition_table, &mut stats, logger);
        
        if !leaf_node.borrow().is_game_terminal() && leaf_node.borrow().visits == 0 {
            evaluate_and_expand_node(leaf_node.clone(), move_gen, pesto_eval, &mut stats, &config, logger);
        }
        
        MctsNode::backpropagate(leaf_node, value);
        stats.iterations = iteration + 1;
        
        if let Some(log) = logger {
            let best = select_best_move_from_root(root_node.clone(), move_gen);
            log.log_iteration_summary(iteration + 1, best, root_node.borrow().visits);
        }
        
        if iteration % 100 == 0 && start_time.elapsed() > config.time_limit { break; }
    }
    
    stats.search_time = start_time.elapsed();
    let best_move = select_best_move_from_root(root_node.clone(), move_gen);
    
    if let Some(log) = logger {
        log.log_search_complete(
            best_move,
            stats.iterations,
            stats.nodes_expanded,
            stats.mates_found,
        );
    }
    
    (best_move, stats, root_node)
}

fn select_leaf_node(
    mut current: Rc<RefCell<MctsNode>>,
    move_gen: &MoveGen,
    nn_policy: &mut Option<NeuralNetPolicy>,
    config: &TacticalMctsConfig,
    stats: &mut TacticalMctsStats,
    logger: Option<&Arc<SearchLogger>>,
) -> Rc<RefCell<MctsNode>> {
    let mut depth = 0;
    loop {
        if let Some(log) = logger {
            log.log_enter_node(&current.borrow(), depth);
        }
        
        let is_terminal = current.borrow().is_game_terminal();
        let has_children = !current.borrow().children.is_empty();
        
        if is_terminal || !has_children {
            return current;
        }
        
        if let Some(child) = select_child_with_tactical_priority(
            current.clone(),
            &config,
            move_gen,
            nn_policy,
            stats,
            logger,
            depth,
        ) {
            if !current.borrow().policy_evaluated && config.use_neural_policy {
                stats.nn_policy_evaluations += 1;
            }
            current = child;
            depth += 1;
        } else {
            return current;
        }
    }
}

fn evaluate_leaf_node(
    node: Rc<RefCell<MctsNode>>,
    move_gen: &MoveGen,
    pesto_eval: &PestoEval,
    nn_policy: &mut Option<NeuralNetPolicy>,
    config: &TacticalMctsConfig,
    transposition_table: &mut TranspositionTable,
    stats: &mut TacticalMctsStats,
    logger: Option<&Arc<SearchLogger>>,
) -> f64 {
    let mut node_ref = node.borrow_mut();
    let board = &node_ref.state;
    
    if let Some(cached_value) = node_ref.terminal_or_mate_value {
        if cached_value >= -1.0 { 
            stats.nn_saved_by_tier1 += 1;
            return cached_value; 
        }
    }

    if config.enable_tier1_gate && koth_center_in_3(board, move_gen) {
        let win_val = 1.0; // StM wins
        if let Some(log) = logger {
            log.log_koth_check(true, Some(0)); 
        }
        node_ref.terminal_or_mate_value = Some(win_val);
        stats.nn_saved_by_tier1 += 1;
        return win_val;
    }

    if config.enable_tier1_gate && config.mate_search_depth > 0 {
        if let Some((mate_depth, _mate_move)) = transposition_table.probe_mate(board, config.mate_search_depth) {
            stats.tt_mate_hits += 1;
            if mate_depth != 0 {
                // Validate move legality if present to guard against collisions
                let is_valid = if _mate_move != Move::null() {
                    let (captures, quiet) = move_gen.gen_pseudo_legal_moves(board);
                    let is_pseudo_legal = captures.contains(&_mate_move) || quiet.contains(&_mate_move);
                    is_pseudo_legal && board.apply_move_to_board(_mate_move).is_legal(move_gen)
                } else {
                    true
                };

                if is_valid {
                    if let Some(log) = logger {
                        log.log_tier1_gate(
                            &GateReason::TtMateHit { depth: mate_depth },
                            None
                        );
                    }
                    let mate_value = if mate_depth > 0 { 1.0 } else { -1.0 };
                    node_ref.terminal_or_mate_value = Some(mate_value);
                    node_ref.origin = NodeOrigin::Gate;
                    stats.nn_saved_by_tier1 += 1;
                    return mate_value;
                }
            }
        } else {
            stats.tt_mate_misses += 1;
            let mut board_stack = BoardStack::with_board(board.clone());
            let mate_result = mate_search(&mut board_stack, move_gen, config.mate_search_depth, false);
            transposition_table.store_mate_result(board, mate_result.0.abs(), mate_result.1, config.mate_search_depth);
            
            if mate_result.0 != 0 {
                if let Some(log) = logger {
                    log.log_mate_search_result(mate_result.0, mate_result.1, 0);
                 }
                let mate_value = if mate_result.0 > 0 { 1.0 } else { -1.0 };
                node_ref.terminal_or_mate_value = Some(mate_value);
                stats.nn_saved_by_tier1 += 1;
                return mate_value;
            }
        }
    }
    
    if node_ref.nn_value.is_none() {
        let mut k_val = 0.5;
        let mut raw_val = -999.0;

        // 1. Batched Inference
        if config.enable_tier3_neural {
            if let Some(server) = &config.inference_server {
                if config.use_neural_policy {
                    let receiver = server.predict_async(node_ref.state.clone());
                    if let Ok(Some((_policy, value, k))) = receiver.recv() {
                        raw_val = value as f64;
                        k_val = k;
                    }
                }
            }
        } 
        
        // Direct Inference or Batched Response Handling
        if raw_val > -2.0 {
            // Assert NN values are in range [-1, 1] to catch issues with model heads immediately.
            if raw_val < -1.01 || raw_val > 1.01 {
                panic!("Neural Network produced value out of range [-1, 1]: {}. issues must be caught immediately.", raw_val);
            }
            if let Some(log) = logger {
                log.log_tier3_neural(raw_val, k_val);
            }
            node_ref.nn_value = Some(raw_val);
            if node_ref.origin == NodeOrigin::Unknown {
                node_ref.origin = NodeOrigin::Neural;
            }
            stats.nn_evaluations += 1;
        } else {
            // Classical path: Use Pesto evaluation mapped to tanh domain for search consistency.
            let eval_score = pesto_eval.eval(&node_ref.state, move_gen);
            let tanh_val = (eval_score as f64 / 400.0).tanh();
            if let Some(log) = logger {
                log.log_classical_eval(eval_score, tanh_val);
            }
            node_ref.nn_value = Some(tanh_val);
        }
        node_ref.k_val = k_val;
    } else {
        if node_ref.origin == NodeOrigin::Grafted {
            stats.nn_saved_by_tier2 += 1;
        }
    }
    
    node_ref.nn_value.unwrap()
}

fn evaluate_and_expand_node(
    node: Rc<RefCell<MctsNode>>,
    move_gen: &MoveGen,
    pesto_eval: &PestoEval,
    stats: &mut TacticalMctsStats,
    config: &TacticalMctsConfig,
    logger: Option<&Arc<SearchLogger>>,
) {
    let mut node_ref = node.borrow_mut();
    
    if !node_ref.children.is_empty() || node_ref.is_game_terminal() {
        return;
    }

    if config.enable_tier2_graft {
        if let Some(log) = logger {
            log.log_qs_start(&node_ref.state);
        }
        let mut board_stack = BoardStack::with_board(node_ref.state.clone());
        let tactical_tree = quiescence_search_tactical(&mut board_stack, move_gen, pesto_eval);

        if !tactical_tree.siblings.is_empty() {
            stats.tier2_q_inits += 1;
            stats.tactical_node_ratio = (stats.tactical_node_ratio * 0.9) + 0.1;
            
            if let Some(log) = logger {
                 log.log_qs_pv(&tactical_tree.principal_variation, tactical_tree.leaf_score);
            }
            let parent_eval = pesto_eval.eval(&node_ref.state, move_gen);
            let parent_v = node_ref.nn_value.unwrap_or(0.0); // Neutral is 0.0 in [-1, 1]
            let k = node_ref.k_val;

            for (mv, qs_score) in tactical_tree.siblings {
                let material_delta = qs_score - parent_eval;
                let extrapolated_v = extrapolate_value(parent_v, material_delta, k);
                
                if let Some(log) = logger {
                    log.log_tier2_graft(mv, extrapolated_v, k);
                }
                
                node_ref.tactical_values.insert(mv, extrapolated_v);
                
                if tactical_tree.principal_variation.contains(&mv) {
                    let next_board = node_ref.state.apply_move_to_board(mv);
                    let child = MctsNode::new_child(Rc::downgrade(&node), mv, next_board, move_gen);
                    // extrapolated_v is relative to Parent (Side to Move at Parent).
                    // child.nn_value must be relative to Child (Side to Move at Child).
                    // These are opposite sides, so we negate.
                    child.borrow_mut().nn_value = Some(-extrapolated_v);
                    child.borrow_mut().k_val = k; 
                    child.borrow_mut().is_tactical_node = true;
                    child.borrow_mut().origin = NodeOrigin::Grafted;
                    node_ref.children.push(child);
                    stats.nodes_expanded += 1;
                }
            }
            node_ref.tactical_resolution_done = true;
        } else {
            stats.tactical_node_ratio = stats.tactical_node_ratio * 0.9;
        }
    }

    let (captures, non_captures) = move_gen.gen_pseudo_legal_moves(&node_ref.state);
    for mv in captures.iter().chain(non_captures.iter()) {
        if node_ref.children.iter().any(|c| c.borrow().action == Some(*mv)) {
            continue;
        }

        let new_board = node_ref.state.apply_move_to_board(*mv);
        if new_board.is_legal(move_gen) {
            let child_node = MctsNode::new_child(Rc::downgrade(&node), *mv, new_board, move_gen);
            node_ref.children.push(child_node);
            stats.nodes_expanded += 1;
        }
    }
}

fn backpropagate_value(node: Rc<RefCell<MctsNode>>, value: f64) {
    MctsNode::backpropagate(node, value);
}

fn select_best_move_from_root(
    root: Rc<RefCell<MctsNode>>,
    move_gen: &MoveGen,
) -> Option<Move> {
    let root_ref = root.borrow();
    if let Some(mate_move) = root_ref.mate_move { 
        // Validation check
        let (captures, quiet) = move_gen.gen_pseudo_legal_moves(&root_ref.state);
        let is_pseudo_legal = captures.contains(&mate_move) || quiet.contains(&mate_move);
        if is_pseudo_legal && root_ref.state.apply_move_to_board(mate_move).is_legal(move_gen) {
            return Some(mate_move);
        }
    }
    
    let mut best_move = None;
    let mut best_visits = 0;
    
    for child in &root_ref.children {
        let child_ref = child.borrow();
        if child_ref.visits > best_visits {
            best_visits = child_ref.visits;
            best_move = child_ref.action;
        }
    }
    best_move
}

pub struct MctsTrainingResult {
    pub best_move: Option<Move>,
    pub root_policy: Vec<(Move, u32)> ,
    pub root_value_prediction: f64,
    pub stats: TacticalMctsStats,
}

pub fn tactical_mcts_search_for_training(
    board: Board,
    move_gen: &MoveGen,
    pesto_eval: &PestoEval,
    nn_policy: &mut Option<NeuralNetPolicy>,
    config: TacticalMctsConfig,
) -> MctsTrainingResult {
    let start_time = Instant::now();
    let mut stats = TacticalMctsStats::default();
    let root_node = MctsNode::new_root(board, move_gen);
    
    if root_node.borrow().is_game_terminal() {
        return MctsTrainingResult { best_move: None, root_policy: vec![], root_value_prediction: 0.0, stats };
    }
    
    evaluate_and_expand_node(root_node.clone(), move_gen, pesto_eval, &mut stats, &config, None);
    let mut transposition_table = TranspositionTable::new();
    for iteration in 0..config.max_iterations {
        if start_time.elapsed() > config.time_limit { break; }
        let leaf = select_leaf_node(root_node.clone(), move_gen, nn_policy, &config, &mut stats, None);
        let value = evaluate_leaf_node(leaf.clone(), move_gen, pesto_eval, nn_policy, &config, &mut transposition_table, &mut stats, None);
        if !leaf.borrow().is_game_terminal() && leaf.borrow().visits == 0 {
            evaluate_and_expand_node(leaf.clone(), move_gen, pesto_eval, &mut stats, &config, None);
        }
        MctsNode::backpropagate(leaf, value);
        stats.iterations = iteration + 1;
    }
    
    let root = root_node.borrow();
    let mut policy = Vec::new();
    for child in &root.children {
        if let Some(mv) = child.borrow().action {
            policy.push((mv, child.borrow().visits));
        }
    }
    
    let best_move = select_best_move_from_root(root_node.clone(), move_gen);
    // root.total_value stores rewards relative to side that just moved (parent's parent).
    // For root, this is the opponent of the side to move.
    // So we negate it to get the side to move's perspective.
    let root_val = if root.visits > 0 { -(root.total_value / root.visits as f64) } else { 0.0 };
    
    MctsTrainingResult { best_move, root_policy: policy, root_value_prediction: root_val, stats }
}

pub fn print_search_stats(stats: &TacticalMctsStats, best_move: Option<Move>) {
    println!(" Tactical-First MCTS Search Complete");
    println!("   Iterations: {}", stats.iterations);
    println!("   Time: {}ms", stats.search_time.as_millis());
    println!("   Nodes expanded: {}", stats.nodes_expanded);
    println!("   Mates found: {}", stats.mates_found);
    if let Some(mv) = best_move {
        println!("   Best move: {}", mv.to_uci());
    }
}]]>
</content>
</file>

<file path="Dockerfile" tokens="156" focus="false">
<reason>Hybrid Retrieval</reason>
<content>
<![CDATA[
FROM rust:1.75-bookworm

# Install Python for training
RUN apt-get update && apt-get install -y \
    python3 python3-pip python3-venv \
    graphviz \
    && rm -rf /var/lib/apt/lists/*

# Create virtual environment
RUN python3 -m venv /opt/venv
ENV PATH="/opt/venv/bin:$PATH"

# Install Python dependencies
COPY requirements.txt /app/
RUN pip install --no-cache-dir -r /app/requirements.txt

# Copy Rust project
WORKDIR /app
COPY . .

# Build Rust project
RUN cargo build --release

# Default command: run tournament
CMD ["./target/release/elo_tournament", "--games", "100"]
]]>
</content>
</file>

<file path="src/egtb.rs" tokens="1632" focus="false">
<reason>Semantic Match</reason>
<content>
<![CDATA[
// src/egtb.rs

// Use internal project types
use crate::board::Board;
use crate::move_types::Move;
 // Needed for piece count calculation

// Use the Syzygy library
use shakmaty::Board as ShakmatyBoard;
use shakmaty_syzygy::{Wdl, Dtz};

// Define the error type for EGTB operations
#[derive(Debug, Clone)]
pub enum EgtbError {
    LoadError(String), // Error loading tablebases
    ProbeError(String), // Error during probing
    ConversionError(String), // Error converting board representation
}

impl std::fmt::Display for EgtbError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            EgtbError::LoadError(s) => write!(f, "EGTB Load Error: {}", s),
            EgtbError::ProbeError(s) => write!(f, "EGTB Probe Error: {}", s),
            EgtbError::ConversionError(s) => write!(f, "Board Conversion Error: {}", s),
        }
    }
}

impl std::error::Error for EgtbError {}


/// Information obtained from probing the endgame tablebases.
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct EgtbInfo {
    /// Win/Draw/Loss status from the perspective of the side to move.
    pub wdl: Wdl,
    /// Distance to Zeroing move (often related to Distance to Mate).
    pub dtz: Option<Dtz>,
    /// The best move according to the tablebase, if available. (Currently always None)
    pub best_move: Option<Move>, // Use crate::move_types::Move
}

/// Structure to handle Syzygy endgame tablebase probing.
#[derive(Clone)]
pub struct EgtbProber {
    // tablebases: Tablebase<ShakmatyBoard>, // Temporarily commented out to fix compilation
    pub max_pieces: u8, // Store the max pieces supported by loaded tables
}

impl EgtbProber {
    /// Creates a new EgtbProber by loading tablebases from the specified path.
    pub fn new(path_str: &str) -> Result<Self, EgtbError> {
        // Check if path exists and is valid for testing
        if !std::path::Path::new(path_str).exists() {
            return Err(EgtbError::LoadError(format!("Path does not exist: {}", path_str)));
        }
        
        // Temporarily simplified implementation to focus on MCTS
        let max_pieces = 7;
        Ok(EgtbProber { max_pieces })
    }

    /// Probes the endgame tablebases for the given board position.
    pub fn probe(&self, _board: &Board) -> Result<Option<EgtbInfo>, EgtbError> {
        // Temporarily disabled to focus on MCTS functionality
        // TODO: Implement proper EGTB integration after MCTS is working
        Ok(None)
    }

    /// Helper function to convert `crate::board::Board` to `shakmaty::Board`.
    #[allow(dead_code)]
    fn convert_board(&self, _board: &Board) -> Result<ShakmatyBoard, EgtbError> {
        // Temporarily disabled to focus on MCTS functionality
        // TODO: Implement proper board conversion after MCTS is working
        Err(EgtbError::ConversionError("EGTB temporarily disabled".to_string()))
    }
}

// Optional: Basic unit tests (updated for internal Board)
#[cfg(test)]
mod tests {
    use super::*;
    use crate::board::Board; // Use internal Board
    use shakmaty::Chess; // Use shakmaty's Chess board for creating positions

    // Mock structure specifically for testing the piece count check logic
    // within the probe function, without needing actual tablebases.
    struct PieceCountCheckProber {
        max_pieces: u8,
    }

    impl PieceCountCheckProber {
        fn new(max_pieces: u8) -> Self {
            PieceCountCheckProber { max_pieces }
        }

        // Mimics the initial piece count check of the real EgtbProber::probe
        fn probe(&self, board: &Board) -> Result<Option<()>, EgtbError> {
            let piece_count = board.get_all_occupancy().count_ones() as u8;
            if piece_count > self.max_pieces {
                Ok(None) // Too many pieces, real probe would return here
            } else {
                // In a real probe, conversion and actual probing would happen here.
                // For this mock, we just indicate the piece count was acceptable.
                Ok(Some(()))
            }
        }
    }

    #[test]
    fn test_new_invalid_path() {
        // Use a path that is highly unlikely to exist or be valid EGTB dir
        let result = EgtbProber::new("/tmp/non_existent_egtb_path_for_testing");
        assert!(result.is_err());
        match result.err().unwrap() {
            EgtbError::LoadError(_) => {} // Expected error type
            _ => panic!("Expected LoadError for invalid path"),
        }
    }


    #[test]
    fn test_probe_piece_count_within_limit() {
        // Use the mock that only checks piece count
        let prober = PieceCountCheckProber::new(7);

        // 7 pieces - should pass piece count check (returns Some in mock)
        let board = Board::new_from_fen("8/8/8/8/k7/p7/P7/K7 w - - 0 1");
        assert!(prober.probe(&board).unwrap().is_some());

        // 3 pieces - should pass piece count check
        let board = Board::new_from_fen("8/8/8/8/8/8/k7/K1N5 w - - 0 1");
        assert!(prober.probe(&board).unwrap().is_some());
    }

    #[test]
    fn test_probe_piece_count_exceeds_limit() {
        // Use the mock that only checks piece count
        let prober = PieceCountCheckProber::new(7);

        // Starting pos (32 pieces) - should fail piece count check (returns None)
        let board = Board::new_from_fen("rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1");
        assert!(prober.probe(&board).unwrap().is_none());

        // 8 pieces exactly - should fail piece count check
        let board = Board::new_from_fen("8/8/8/8/k7/p1p5/P1P5/KBN5 w - - 0 1");
        assert!(prober.probe(&board).unwrap().is_none());
    }

    // Note: Testing actual probing still requires real EGTB files.
    // #[test]
    // #[ignore]
    // fn test_real_probe_known_position() {
    //     let prober = EgtbProber::new("../egtb_files").expect("Failed to load test EGTBs");
    //     let board = Board::new_from_fen("8/8/8/8/8/k7/P7/K7 w - - 0 1"); // K vs K+P endgame
    //     let result = prober.probe(&board).unwrap();
    //     assert!(result.is_some());
    //     // Add assertions based on expected WDL/DTZ
    // }
}]]>
</content>
</file>

<file path="HUMANLIKE_AGENT.md" tokens="998" focus="false">
<reason>Hybrid Retrieval</reason>
<content>
<![CDATA[
# HumanlikeAgent Implementation Documentation

## Overview
The HumanlikeAgent is a chess engine that combines classical chess techniques with Monte Carlo Tree Search (MCTS). While designed with future extensions for neural networks and human-like play in mind, the current implementation uses a three-phase decision process:

1. Optional EGTB (Endgame Tablebase) lookup
2. Mate Search
3. MCTS with Pesto evaluation

## Components

### 1. Agent Structure
```rust
pub struct HumanlikeAgent<'a> {
    pub move_gen: &'a MoveGen,
    pub pesto: &'a PestoEval,
    pub egtb_prober: Option<EgtbProber>,
    pub mate_search_depth: i32,
    pub mcts_iterations: u32,
    pub mcts_time_limit_ms: u64,
}
```

### 2. Decision Flow

#### Phase 1: EGTB (Optional)
- If `egtb_prober` is Some and position has  max_pieces:
  - Probes EGTB for perfect play information
  - Currently only logs results without using them for move selection
  - Future: Will use EGTB moves when available

#### Phase 2: Mate Search
- Performs classical mate search up to specified depth
- If mate is found, immediately returns the mating move
- Uses standard alpha-beta mate search algorithm

#### Phase 3: MCTS
If no mate is found, performs MCTS with the following characteristics:

##### A. Node Selection
- Uses PUCT (Polynomial Upper Confidence Trees) for tree traversal
- Exploration constant: 2 (1.414)
- Selection formula: Q + U where:
  - Q = average value for selector
  - U = c * P * (N_parent) / (1 + N_child)
  - P = 1/num_legal_moves (uniform prior)

##### B. Move Prioritization
Moves are categorized and explored in strict priority order:

1. **Checks** (Highest Priority)
   - Detected by applying move and checking if opponent king is in check
   - Explored in generation order

2. **Captures** (Medium Priority)
   - Includes both captures and promotions
   - Sorted by MVV-LVA (Most Valuable Victim - Least Valuable Aggressor)
   - Includes en passant captures

3. **Quiet Moves** (Lowest Priority)
   - All other legal moves
   - Explored in generation order

##### C. Position Evaluation
Uses the Pesto evaluation function, which includes:
- Material and piece-square tables
- Pawn structure evaluation
  - Passed pawns
  - Isolated pawns
  - Pawn chains
  - Pawn duos
  - Backward pawns
- King safety
  - Pawn shield
  - King attack score
  - Castling rights
- Piece mobility
- Two bishops bonus
- Rook positioning
  - Open/half-open files
  - Rooks on 7th rank
  - Rooks behind passed pawns

The raw evaluation in centipawns is converted to a probability using a sigmoid function:
```rust
value = 1.0 / (1.0 + (-score_cp as f64 / 400.0).exp())
```

##### D. Backpropagation
- Updates visit counts and total values
- Maintains squared values for variance calculation
- Values always stored from White's perspective [0.0, 1.0]

##### E. Final Move Selection
Uses a pessimistic value selection strategy:
- Calculates Q - k*std_err for each move
- k = 1.0 (configurable pessimism factor)
- Helps avoid moves with high uncertainty
- For White: maximizes lower confidence bound
- For Black: minimizes upper confidence bound

### 3. Termination Conditions
MCTS search stops when either:
- Specified number of iterations reached
- Time limit exceeded (checked every 64 iterations)

## Current Limitations
1. EGTB integration exists but doesn't influence move selection
2. No neural network policy/evaluation
3. No rating band-specific behavior
4. Move ordering within Check and Quiet categories is not randomized
5. MVV-LVA scoring implementation needs completion

## Future Extensions
1. Complete EGTB move selection
2. Add neural network policy and value functions
3. Implement rating band-specific behavior
4. Add opening book integration
5. Randomize move selection within categories
6. Complete MVV-LVA implementation for captures

## Performance Considerations
- Mate search depth and MCTS parameters are configurable
- MCTS time management checks every 64 iterations
- Move legality checking during categorization could be optimized
- Check detection requires temporary move application ]]>
</content>
</file>

<file path="src/mcts/policy.rs" tokens="1141" focus="false">
<reason>Semantic Match</reason>
<content>
<![CDATA[
//! Policy network interface for MCTS.
//!
//! This module defines interfaces for policy networks used in MCTS.
//! It allows for different implementations of policy networks.

use crate::board::Board;
use crate::move_types::Move;
use std::collections::HashMap;

/// Trait for policy networks used in MCTS.
///
/// A policy network evaluates a position and returns:
/// 1. A prior probability distribution over legal moves
/// 2. A value estimate for the current position
pub trait PolicyNetwork {
    /// Evaluates a position given the legal moves and returns (policy, value).
    ///
    /// # Arguments
    /// * `board` - The chess position to evaluate.
    /// * `legal_moves` - A slice containing the legal moves for the current position.
    ///
    /// # Returns
    /// * `HashMap<Move, f64>` - Prior probabilities for each legal move provided.
    /// * `f64` - Value estimate for the position from the perspective of the player to move.
    ///           Should be in range [0.0, 1.0] where 1.0 means certain win for current player.
    fn evaluate(&self, board: &Board, legal_moves: &[Move]) -> (HashMap<Move, f64>, f64);
}

/// A simple random policy network for testing.
/// Returns uniform prior probabilities and random value.
pub struct RandomPolicy;

impl PolicyNetwork for RandomPolicy {
    fn evaluate(&self, _board: &Board, legal_moves: &[Move]) -> (HashMap<Move, f64>, f64) {
        let mut policy = HashMap::new();
        let num_moves = legal_moves.len();
        if num_moves > 0 {
            let uniform_prob = 1.0 / num_moves as f64;
            for mv in legal_moves {
                policy.insert(*mv, uniform_prob);
            }
        }
        (policy, 0.5) // Return uniform policy and neutral value
    }
}

/// A simple material-based policy network.
/// Returns uniform prior probabilities but evaluates position based on material.
pub struct MaterialPolicy;

impl PolicyNetwork for MaterialPolicy {
    fn evaluate(&self, board: &Board, legal_moves: &[Move]) -> (HashMap<Move, f64>, f64) {
        // Assign uniform priors for policy part
        let mut policy = HashMap::new();
        let num_moves = legal_moves.len();
        if num_moves > 0 {
            let uniform_prob = 1.0 / num_moves as f64;
            for mv in legal_moves {
                policy.insert(*mv, uniform_prob);
            }
        }

        // Simple material evaluation for value part
        use crate::piece_types::*;

        // Use common piece values (in centipawns)
        let piece_values = [100, 320, 330, 500, 900, 0]; // P, N, B, R, Q, K

        let mut white_material = 0;
        let mut black_material = 0;

        // Count white material
        for piece_type in 0..6 {
            let pieces = board.get_piece_bitboard(WHITE, piece_type);
            let count = pieces.count_ones();
            white_material += count as i32 * piece_values[piece_type];
        }

        // Count black material
        for piece_type in 0..6 {
            let pieces = board.get_piece_bitboard(BLACK, piece_type);
            let count = pieces.count_ones();
            black_material += count as i32 * piece_values[piece_type];
        }

        // Calculate advantage from perspective of player to move
        let advantage = if board.w_to_move {
            white_material - black_material
        } else {
            black_material - white_material
        };

        // Convert material advantage to probability with sigmoid
        // Map advantage from centipawns to [0.0, 1.0] range
        let value = 1.0 / (1.0 + (-advantage as f64 / 400.0).exp());

        (policy, value)
    }
}

/// Placeholder for a policy network loaded from an ONNX model.
pub struct OnnxPolicyNetwork {
    // Placeholder for model path, runtime session, etc.
    // model_path: String,
    // session: Option<onnxruntime::session::Session<'static>>, // Example using onnxruntime crate
}

impl OnnxPolicyNetwork {
    pub fn new(_model_path: &str) -> Self {
        // TODO: Implement model loading logic here
        OnnxPolicyNetwork {
            // model_path: model_path.to_string(),
            // session: None, // Load session here
        }
    }
}

impl PolicyNetwork for OnnxPolicyNetwork {
    fn evaluate(&self, _board: &Board, _legal_moves: &[Move]) -> (HashMap<Move, f64>, f64) {
        // TODO: Implement actual model inference here
        // 1. Convert board state to model input tensor
        // 2. Run inference using the ONNX session
        // 3. Convert model output (policy logits, value) back to HashMap<Move, f64> and f64
        // 4. Ensure policy probabilities are normalized and only include legal moves

        // Placeholder implementation:
        eprintln!("Warning: OnnxPolicyNetwork::evaluate is not implemented yet.");
        (HashMap::new(), 0.5) // Return empty policy and neutral value
    }
}
]]>
</content>
</file>

<file path=".cargo/config.toml" tokens="17" focus="false">
<reason>Hybrid Retrieval</reason>
<content>
<![CDATA[
[build]
rustflags = ["-C", "target-cpu=native"]
]]>
</content>
</file>

<file path="src/search/alpha_beta.rs" tokens="2223" focus="false">
<reason>Semantic Match</reason>
<content>
<![CDATA[
use super::history::HistoryTable;
use super::history::MAX_PLY;
use super::quiescence::quiescence_search;
use crate::board::Board;
use crate::boardstack::BoardStack;
use crate::eval::PestoEval;
use crate::move_generation::MoveGen;
use crate::move_types::{Move, NULL_MOVE};
use crate::transposition::TranspositionTable;
use std::time::{Duration, Instant};

/// Perform alpha-beta search from the given position
///
/// This function performs an exhaustive search to the given depth, using alpha-beta pruning
/// to optimize the search process. Includes NMP, Killers, History Heuristic, LMR.
///
/// # Arguments
///
/// * `board` - A mutable reference to the current board state
/// * `move_gen` - A reference to the move generator
/// * `pesto` - A reference to the Pesto evaluation function
/// * `tt` - Transposition Table
/// * `killers` - Killer move table
/// * `history` - History heuristic table
/// * `depth` - Remaining depth to search
/// * `alpha` - Alpha bound
/// * `beta` - Beta bound
/// * `q_search_max_depth` - Max depth for quiescence search
/// * `verbose` - Verbosity flag
/// * `start_time` - Start time for time limit checks
/// * `time_limit` - Optional time limit duration
///
/// # Returns
///
/// A tuple containing: (score, best_move, nodes_searched, terminated_early)
pub fn alpha_beta_search(
    board: &mut BoardStack,
    move_gen: &MoveGen,
    pesto: &PestoEval,
    tt: &mut TranspositionTable,
    killers: &mut [[Move; 2]; MAX_PLY],
    history: &mut HistoryTable,
    depth: i32,
    alpha_init: i32,
    beta_init: i32,
    q_search_max_depth: i32,
    verbose: bool,
    start_time: Option<Instant>,
    time_limit: Option<Duration>,
) -> (i32, Move, i32, bool) {
    let mut best_move: Move = NULL_MOVE;
    let mut alpha: i32 = alpha_init;
    let beta: i32 = beta_init;
    let mut n: i32 = 0;
    let mut eval: i32 = 0;

    // Check for checkmate and stalemate
    if verbose {
        println!("Checking for checkmate and stalemate");
    }
    let (checkmate, stalemate) = board.current_state().is_checkmate_or_stalemate(move_gen);
    if verbose {
        println!("Checkmate and stalemate checked");
        println!("Checkmate: {} Stalemate: {}", checkmate, stalemate);
    }

    // Handle checkmate and stalemate cases
    if checkmate {
        if verbose {
            println!("AB search: Checkmate!");
        }
        return (1000000, best_move, 1, true);
    } else if stalemate {
        if verbose {
            println!("AB search: Stalemate!");
        }
        return (0, best_move, 1, true);
    }

    // Generate and combine captures and regular moves
    let (mut captures, moves) = move_gen.gen_pseudo_legal_moves_with_evals(
        &mut board.current_state(),
        pesto,
        Some(history),
    );
    captures.extend(moves);

    // Print the list of captures
    if verbose {
        println!("Generated {} moves", captures.len());
        for m in &captures {
            println!("Move: {}", m);
        }
    }

    for m in captures {
        if verbose {
            println!("Considering move {} at root of search tree", m);
        }
        board.make_move(m);
        if !board.current_state().is_legal(move_gen) {
            board.undo_move();
            continue;
        }
        let (search_eval, nodes, _terminated) = alpha_beta_recursive(
            board,
            move_gen,
            pesto,
            tt,
            killers,
            history,
            depth - 1,
            -beta,
            -alpha,
            q_search_max_depth,
            verbose,
            None, // start_time
            None, // time_limit
        );
        eval = -search_eval;
        n += nodes;
        if eval > alpha {
            alpha = eval;
            best_move = m;
        }

        if verbose {
            println!(
                "Just checked move {}, current best move is {}",
                m, best_move
            );
            if let Some(start_time) = start_time {
                println!(
                    "Current time: {:?}, time limit: {:?}",
                    start_time.elapsed(),
                    time_limit
                );
            }
        }

        // Check time limit
        if let Some(start_time) = start_time {
            if let Some(time_limit) = time_limit {
                if start_time.elapsed() > time_limit {
                    board.undo_move();
                    if verbose {
                        println!("Time limit reached. Stopping search.");
                    }
                    return (alpha, best_move, nodes, true);
                }
            }
        }

        // Undo the move
        board.undo_move();

        // Prune if necessary
        if alpha >= beta {
            // Update history table for the cutoff move
            if !is_capture(&board.current_state(), &best_move) {
                history.update(&best_move, depth);
            }
            break;
        }
    }

    if verbose {
        println!(
            "Alpha beta search at depth {} searched {} nodes. Best eval and move are {} {}",
            depth, n, alpha, best_move
        );
    }

    // Store the result in the transposition table
    tt.store(board.current_state(), depth, eval, best_move);

    (alpha, best_move, n, false)
}

/// Recursive helper function for alpha-beta search
/// Returns (score, nodes_searched, terminated_early)
fn alpha_beta_recursive(
    board: &mut BoardStack,
    move_gen: &MoveGen,
    pesto: &PestoEval,
    tt: &mut TranspositionTable,
    killers: &mut [[Move; 2]; MAX_PLY],
    history: &mut HistoryTable,
    depth: i32,
    mut alpha: i32,
    beta: i32,
    q_search_max_depth: i32,
    verbose: bool,
    start_time: Option<Instant>, // Added
    time_limit: Option<Duration>, // Added
) -> (i32, i32, bool) { // Added bool for termination flag
    // --- Time Check (Periodic) ---
    // Check every N nodes (e.g., 2048) to balance overhead and responsiveness
    // Note: 'n' is the node count for *this* call, not total. Need total node count passed down or a shared counter.
    // Let's simplify: Check time at the start of each recursive call for now. Less efficient but simpler.
    if let (Some(start), Some(limit)) = (start_time, time_limit) {
        if start.elapsed() >= limit {
            return (0, 0, true); // Return 0 score, 0 nodes, terminated=true
        }
    }
    // --- Depth Check ---
    if depth <= 0 {
        let (score, nodes) = quiescence_search(
            board,
            move_gen,
            pesto,
            alpha,
            beta,
            q_search_max_depth,
            verbose,
            start_time, // Pass time info down
            time_limit, // Pass time info down
        );
        // Check if quiescence search terminated due to time
        let terminated = if let (Some(start), Some(limit)) = (start_time, time_limit) {
             start.elapsed() >= limit
        } else { false };
        return (score, nodes, terminated);
    }

    let mut best_eval: i32 = -1000000;
    let mut n: i32 = 1; // Count current node

    // Generate and combine captures and regular moves
    let (mut captures, moves) = move_gen.gen_pseudo_legal_moves_with_evals(
        &mut board.current_state(),
        pesto,
        Some(history),
    );
    captures.extend(moves);

    // Iterate through all moves
    for m in captures {
        board.make_move(m);
        if !board.current_state().is_legal(move_gen) {
            board.undo_move();
            continue;
        }

        // --- Check Extension ---
        // Extend search if the move 'm' results in check for the opponent
        let mut extension = 0;
        if board.is_check(move_gen) {
            extension = 1;
            // Optional: Limit extension depth or based on move type (e.g., only for non-quiet moves?)
        }
        let new_depth = depth - 1 + extension;

        let (mut eval, nodes, terminated) = alpha_beta_recursive(
            board,
            move_gen,
            pesto,
            tt,
            killers,
            history,
            new_depth,
            -beta,
            -alpha,
            q_search_max_depth,
            verbose,
            start_time, // Pass down
            time_limit, // Pass down
        );
        n += nodes; // Accumulate nodes searched

        // If a sub-search terminated due to time, propagate the termination upwards
        if terminated {
            board.undo_move();
            return (0, n, true); // Return dummy score, accumulated nodes, terminated=true
        }

        eval = -eval;
        // n += nodes; // Moved up

        // Update best evaluation
        best_eval = best_eval.max(eval);
        if eval > alpha {
            alpha = eval;
            if alpha >= beta {
                // Update history table for the cutoff move
                if !is_capture(&board.current_state(), &m) {
                    history.update(&m, depth);
                }
                board.undo_move();
                return (beta, n, false); // Not terminated here
            }
        }

        // Undo the move
        board.undo_move();
    }

    (best_eval, n, false) // Not terminated if loop completes normally
}

/// Helper function to check if a move is a capture
fn is_capture(board: &Board, mv: &Move) -> bool {
    let target_square_bb = 1u64 << mv.to;
    let opponent_color = !board.w_to_move as usize;

    // Check if the target square is occupied by an opponent's piece
    (board.pieces_occ[opponent_color] & target_square_bb) != 0
}
]]>
</content>
</file>

<file path="README.md" tokens="2801" focus="false">
<reason>Semantic Match, Architecturally Significant</reason>
<content>
<![CDATA[
# Caissawary Chess Engine (formerly Kingfisher)
## A Tactics-Enhanced Hybrid MCTS Engine with State-Dependent Search Logic

Caissawary is a chess engine that combines the strategic guidance of a modern Monte Carlo Tree Search (MCTS) with the ruthless tactical precision of classical search. Its unique, state-dependent search algorithm prioritizes forcing moves and minimizes expensive neural network computations to create a brutally efficient and tactically sharp engine.

![Caissawary Logo](Caissawary.png)

[![Rust](https://img.shields.io/badge/rust-1.70+-orange)](https://rustup.rs/)
[![License](https://img.shields.io/badge/license-MIT-blue)](LICENSE)

## The Name: Caissawary
Like the engine itself, the name Caissawary is also a hybrid:

- **Cassa**: The mythical goddess of chess, representing the engine's strategic intelligence and artistry.
- **Cassowary**: A large, formidable, and famously aggressive bird, representing the engine's raw tactical power and speed.

## Core Architecture
Caissawary's intelligence stems from how it handles each node during an MCTS traversal. Instead of a single, uniform approach, its behavior adapts based on the node's state, ensuring that cheap, powerful analysis is always performed before expensive strategic evaluation.

### The MCTS Node Handling Flow
When the MCTS search selects a node, its state determines the next action:

#### 1. Safety Gates (Tier 1):
Before any expansion, the engine runs ultra-fast "Safety Gates" to detect immediate win/loss conditions:
- **Checks-Only Mate Search:** A depth-limited DFS that only considers checking moves. It instantly spots forced mate sequences (like Mate-in-2) that standard MCTS might miss due to low visit counts.
- **KOTH Geometric Gate:** A geometric pruning algorithm that detects if a King can reach the center (King of the Hill win) within 3 moves faster than the opponent.

#### 2. Tactical Integration (Tier 2):
If the node is not a terminal state, the engine performs a "Tactical Graft":
- **Quiescence Search (QS):** An integer-based tactical search runs on the CPU to resolve captures and checks using hard-coded piece values (1, 3, 3, 5, 9).
- **Grafting:** The best tactical move found by QS is "grafted" into the MCTS tree immediately.
- **Dynamic Value Extrapolation:** The engine uses the **Symbolic Residual Formula** to price the material won by the CPU:
  $$V_{final} = \tanh\left(\text{arctanh}(V_{parent}) + k \cdot \Delta M\right)$$
  Where $k$ is a **position-specific confidence scalar** predicted by the neural network. This allows the engine to determine if a material advantage is decisive or irrelevant in the current strategic context.

#### 3. Strategic Evaluation (Tier 3):
If no tactical resolution is sufficient, the engine engages the **LogosNet** (if enabled):
- **Dual Value Heads:** The network predicts both a deep strategic logit ($V_{net}$) and a material confidence logit ($K_{net}$).
- **Lazy Evaluation:** The network is queried only when necessary, and its predictions guide the selection of "Quiet" moves via PUCT.

## Tier 2: Tactical Grafting
Instead of treating all new nodes as equal, Caissawary injects tactical knowledge directly into the tree structure. This "Neurosymbolic" approach separates **Logical Truth** from **Contextual Interpretation**.

- **The CPU (Logical Truth):** Runs minimax on captures using raw integers. It is blazing fast and ignores strategic "noise."
- **The Neural Net (Contextual Interpretation):** Predicts $k$, the "price" of material.
- **Symbolic Recombination:** By combining these, the engine "grafts" tactical sequences into the MCTS tree with highly accurate initial values, solving the "cold start" problem for sharp positions.

## Tier 3: LogosNet Architecture (Optional)
The engine supports a **Neurosymbolic** mode using the LogosNet architecture.

- **Architecture:** A 10-block ResNet backbone with a standard Policy head and a **Symbolic Residual Value Head**.
- **Dynamic K:** The network learns how much to trust material imbalance. At initialization ($K_{net} = 0$), $k$ is exactly $0.5$. During training, the network adjusts $k$ to prioritize material or strategic compensation.
- **Inference:** Uses **tch-rs** (LibTorch) for high-performance inference. The forward pass accepts both the board features and the raw material scalar.

### Final Layer Details
The value head splits into two paths to predict the final evaluation:

1.  **Deep Value Logit ($V_{net}$):** Represents the network's intuition about the position's value in logit space.
2.  **Confidence Logit ($K_{net}$):** Represents the network's confidence in the material imbalance.

These are combined using the **Dynamic Symbolic Residual Formula**:

$$k = \frac{\text{Softplus}(K_{net})}{2 \ln 2}$$

$$V_{final} = \tanh(V_{net} + k \cdot \Delta M)$$

Where $\Delta M$ is the material imbalance. This architecture allows the network to learn a residual correction to the material advantage, effectively "pricing" the material in the current strategic context.

> **Note:** Neural network support is optional. Compile with `cargo build --features neural` to enable it. You must have a compatible LibTorch installed or let `tch-rs` download one.

## Training Philosophy
Caissawary is designed for high learning efficiency, making it feasible to train without nation-state-level resources.

- **Supervised Pre-training**: The recommended approach is to begin with supervised learning. The ResNet policy and the fast evaluation function should be pre-trained on a large corpus of high-quality human games. This bootstraps the engine with a strong foundation of strategic and positional knowledge.

- **Efficient Reinforcement Learning**: During subsequent self-play (RL), the engine's learning is accelerated. The built-in tactical search (Tiers 1 and 2) acts as a powerful "inductive bias," preventing the engine from making simple tactical blunders. This provides a cleaner, more focused training signal to the neural networks, allowing them to learn high-level strategy far more effectively than a "blank slate" MCTS architecture.

## Configuration
The node budgets for the tactical searches and other key parameters are designed to be configurable.

```rust
pub struct CaissawaryConfig {
    pub max_iterations: u32,
    pub time_limit: Duration,
    pub exploration_constant: f64,
    
    // Node budget for the parallel mate search at each node
    pub mate_search_nodes: u32,
    
    // Node budget for the quiescence search at each leaf
    pub quiescence_nodes: u32,
}
```

## Technical Stack
- **Core Logic**: Rust, for its performance, memory safety, and concurrency.
- **Parallelism**: **Rayon** for data parallelism in the mate search portfolio.
- **Neural Networks**: **PyTorch** (in Python) for training; **tch-rs** (LibTorch) for Rust inference.
- **Board Representation**: Bitboards, for highly efficient move generation and position manipulation.

## Building and Running

### Prerequisites
First, ensure you have the Rust toolchain installed.

```bash
# Install Rust and Cargo
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
```

For the neural network components (optional), you will also need Python and PyTorch.

```bash
# Install Python dependencies
pip install torch numpy python-chess
```

### Build
Clone the repository and build the optimized release binary:

```bash
git clone https://github.com/aaholmes/caissawary.git
cd caissawary

# Standard Build (Tactical MCTS only)
cargo build --release

# Hybrid Build (With Neural Network support)
# Requires LibTorch. Automatic download may happen.
cargo build --release --features neural
```

### Usage
The primary binary is a UCI-compliant engine, suitable for use in any standard chess GUI like Arena, Cute Chess, or BanksiaGUI.

```bash
# Run the engine in UCI mode
./target/release/kingfisher
```
(Type `uci` to verify connection)

### Self-Play Data Generation
To generate training data for the neural network, use the `self_play` binary. This runs parallel games where the engine plays against itself.

```bash
# Generate 100 games with 800 simulations per move, saving to 'data/'
cargo run --release --bin self_play -- 100 800 data
```

## Testing and Benchmarking
The project includes a comprehensive suite of tests and benchmarks to validate functionality and performance. For detailed documentation, see [TESTING.md](TESTING.md).

```bash
# Run the full test suite (Unit, Integration, Property, Regression)
./scripts/test.sh

# Run standard cargo tests
cargo test

# Run perft tests (Move Generation Correctness)
cargo test --test perft_tests
```

## Visualization & Debugging
Caissawary includes a powerful **MCTS Inspector** tool to visualize the search tree and debug its state-dependent logic. This tool generates Graphviz DOT files that color-code nodes based on their origin (Tier 1, 2, or 3).

### Using the MCTS Inspector
Run the inspector on any FEN position to generate a search tree visualization:

```bash
# Analyze a position (defaults to depth 4, 500 iterations)
cargo run --release --bin mcts_inspector -- "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1"

# Customize depth and iteration count
cargo run --release --bin mcts_inspector -- "6k1/5ppp/8/8/8/8/8/4R1K1 w - - 0 1" --depth 6 --iterations 1000 --output mate_search.dot
```

### Rendering the Output
The tool produces a `.dot` file. You can render this to an image using Graphviz:

```bash
# Render to PNG
dot -Tpng mcts_tree.dot -o tree.png

# Render to interactive SVG
dot -Tsvg mcts_tree.dot -o tree.svg
```

### Interpreting the Tree
Nodes are color-coded to reveal how the engine solved or evaluated them:
- ** Red (Tier 1 Gate):** Solved immediately by "Safety Gates" (Mate Search or KOTH logic) without expansion.
- ** Gold (Tier 2 Graft):** A tactical move found by Quiescence Search and "grafted" into the tree.
- ** Blue (Tier 3 Neural):** A standard node evaluated by the neural network (or Pesto in classical mode).
- ** Grey (Shadow Prior):** A tactical move that was considered but refuted/pruned by the engine.

### Stream of Consciousness Logger
For real-time insight into the engine's "thought process," use the **Stream of Consciousness Logger**. This tool narrates the search as it happens, explaining why specific moves are being prioritized.

#### Using the Verbose Search
Run the `verbose_search` binary on any position:

```bash
# Narrate the search for a specific position with verbose output
cargo run --release --bin verbose_search -- "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1" --verbosity verbose
```

For more details on verbosity levels and configuration, see [STREAM_OF_CONSCIOUSNESS_LOGGER.md](STREAM_OF_CONSCIOUSNESS_LOGGER.md).

## Binary Targets
The crate is organized to produce several distinct binaries for different tasks:

- **caissawary**: The main UCI chess engine.
- **benchmark**: A suite for performance testing, measuring nodes-per-second and puzzle-solving speed.
- **mcts_inspector**: A tool for visualizing and debugging the MCTS search tree.
- **verbose_search**: A real-time search narration tool with customizable verbosity.
- **self_play**: A high-throughput data generation tool that plays games against itself to create training datasets for the neural network.

## References
The architecture of Caissawary is inspired by decades of research in computer chess and artificial intelligence. Key influences include:

- Silver, D. et al. (2017). "Mastering Chess and Shogi by Self-Play with a General Reinforcement Learning Algorithm"
- Campbell, M. et al. (2002). "Deep Blue"
- The Stockfish Engine and the NNUE architecture.

## License
This project is licensed under the terms of the MIT License. Please see the LICENSE file for details.
]]>
</content>
</file>

<file path="TESTING.md" tokens="525" focus="false">
<reason>Hybrid Retrieval</reason>
<content>
<![CDATA[
# Testing Guide for Caissawary

Caissawary employs a comprehensive testing strategy ensuring correctness, stability, and performance. The test suite is divided into several categories targeting different layers of the engine.

## Quick Start

To run the full test suite (Unit, Integration, Property, and Regression):

```bash
./scripts/test.sh
```

To run only standard Cargo tests:

```bash
cargo test
```

## Test Categories

### 1. Unit Tests (`tests/unit/`)
Focus on individual components in isolation.
- **Board:** FEN parsing, state representation, castling rights.
- **Move Generation:** Validity of moves, pseudo-legal vs legal generation.
- **Node:** MCTS node value logic, terminal state handling.
- **Selection:** UCB/PUCT calculations.

### 2. Integration Tests (`tests/integration/`)
Test the interaction between subsystems, particularly the MCTS search pipeline.
- **Mate Search:** Verifies the engine finds mates in complex positions.
- **Tactical Priority:** Ensures tactical moves (captures, checks) are prioritized.
- **Neural Integration:** Tests the flow between the search tree and (mocked) inference server.

### 3. Property Tests (`tests/property/`)
Uses `proptest` to generate random inputs and verify invariants.
- **Legal Moves:** Random positions are generated to ensure `generate_legal_moves` never produces illegal states.
- **Value Domains:** Verifies evaluations stay within valid bounds (e.g., tanh domain [-1, 1]).

### 4. Regression Tests (`tests/regression/`)
Target specific bugs found during development to ensure they do not reoccur.
- **Stack Overflow:** Verifies fix for `BoardStack` history handling.
- **Castling Rules:** Ensures castling is correctly blocked when traversing check.

### 5. Perft Tests (`tests/perft_tests.rs`)
Performance and correctness tests for move generation. These walk the game tree to a fixed depth and compare the leaf node count against known correct values.

```bash
cargo test --test perft_tests
```

## Running Specific Tests

To run a specific test file or test case:

```bash
# Run only regression tests
cargo test --test regression_tests

# Run a specific test case
cargo test test_castling_blocked_by_check
```

## Continuous Integration
The `scripts/test.sh` script is the entry point for CI pipelines. It executes tests in a specific order (Unit -> Integration -> Property) to fail fast on fundamental errors.
]]>
</content>
</file>

<file path="src/mcts/neural_mcts.rs" tokens="320" focus="false">
<reason>Semantic Match</reason>
<content>
<![CDATA[
//! Neural Network enhanced MCTS implementation
//!
//! This module provides MCTS search with neural network policy and value guidance,
//! combining the mate-search-first innovation with modern neural network evaluation.

use crate::board::Board;
use crate::eval::PestoEval;
use crate::move_generation::MoveGen;
use crate::move_types::Move;
use crate::neural_net::NeuralNetPolicy;
use crate::mcts::tactical_mcts::{tactical_mcts_search, TacticalMctsConfig};
use std::time::Duration;

/// Enhanced MCTS search with neural network policy guidance
pub fn neural_mcts_search(
    root_state: Board,
    move_gen: &MoveGen,
    pesto_eval: &PestoEval,
    nn_policy: &mut Option<NeuralNetPolicy>,
    mate_search_depth: i32,
    iterations: Option<u32>,
    time_limit: Option<Duration>,
) -> Option<Move> {
    let config = TacticalMctsConfig {
        max_iterations: iterations.unwrap_or(1000),
        time_limit: time_limit.unwrap_or(Duration::from_secs(5)),
        mate_search_depth,
        exploration_constant: 1.414,
        use_neural_policy: nn_policy.is_some(),
        inference_server: None,
        logger: None,
        ..Default::default()
    };

    let (best_move, _stats, _root) = tactical_mcts_search(
        root_state,
        move_gen,
        pesto_eval,
        nn_policy,
        config
    );

    best_move
}
]]>
</content>
</file>

<file path="src/mcts/unit_tests/mcts_integration_tests.rs" tokens="3032" focus="false">
<reason>Semantic Match</reason>
<content>
<![CDATA[
//! Integration tests for the complete tactical-enhanced MCTS system
//!
//! Tests cover full search functionality, statistics accuracy, 
//! mate detection integration, and system behavior.

use crate::board::Board;
use crate::eval::PestoEval;
use crate::move_generation::MoveGen;
use crate::move_types::Move;
use crate::mcts::{tactical_mcts_search, TacticalMctsConfig};
use std::time::Duration;

fn setup_test_env() -> (MoveGen, PestoEval) {
    (MoveGen::new(), PestoEval::new())
}

fn get_test_config() -> TacticalMctsConfig {
    TacticalMctsConfig {
        max_iterations: 100,
        time_limit: Duration::from_millis(1000),
        mate_search_depth: 3,
        exploration_constant: 1.414,
        use_neural_policy: false,
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_basic_search_functionality() {
        let (move_gen, pesto_eval) = setup_test_env();
        let config = get_test_config();
        let mut nn_policy = None;
        
        let board = Board::new_from_fen("rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1");
        
        let (best_move, stats) = tactical_mcts_search(
            board.clone(),
            &move_gen,
            &pesto_eval,
            &mut nn_policy,
            config,
        );
        
        // Should return a valid move
        assert!(best_move.is_some(), "Should return a move from starting position");
        
        // Statistics should be reasonable
        assert!(stats.iterations > 0, "Should have performed iterations");
        assert!(stats.nodes_expanded > 0, "Should have expanded nodes");
        assert!(stats.search_time > Duration::from_millis(0), "Should have taken some time");
        
        // Verify returned move is legal
        if let Some(mv) = best_move {
            let legal_moves = {
                let (captures, non_captures) = move_gen.gen_pseudo_legal_moves(&board);
                let mut all_moves = captures;
                all_moves.extend(non_captures);
                all_moves.into_iter()
                    .filter(|&m| board.apply_move_to_board(m).is_legal(&move_gen))
                    .collect::<Vec<_>>()
            };
            
            assert!(legal_moves.contains(&mv), "Returned move {:?} should be legal", mv);
        }
    }

    #[test]
    fn test_tactical_position_search() {
        let (move_gen, pesto_eval) = setup_test_env();
        let config = get_test_config();
        let mut nn_policy = None;
        
        // Position with tactical opportunities
        let board = Board::new_from_fen("rnbqkb1r/pppp1ppp/5n2/4p3/2B1P3/8/PPPP1PPP/RNBQK1NR w KQkq - 2 3");
        
        let (best_move, stats) = tactical_mcts_search(
            board,
            &move_gen,
            &pesto_eval,
            &mut nn_policy,
            config,
        );
        
        // Should find a move
        assert!(best_move.is_some(), "Should find move in tactical position");
        
        // Should explore tactical moves OR find a mate immediately
        assert!(stats.tactical_moves_explored > 0 || stats.mates_found > 0,
                "Should explore tactical moves or find mate, found: {} tact, {} mates", 
                stats.tactical_moves_explored, stats.mates_found);
        
        // Should be efficient (more tactical moves than NN calls)
        assert!(stats.tactical_moves_explored >= stats.nn_policy_evaluations,
                "Should explore tactical moves before NN evaluation");
    }

    #[test]
    fn test_mate_detection_integration() {
        let (move_gen, pesto_eval) = setup_test_env();
        let config = TacticalMctsConfig {
            max_iterations: 50,
            time_limit: Duration::from_millis(500),
            mate_search_depth: 3, // Enable mate search
            exploration_constant: 1.414,
            use_neural_policy: false,
        };
        let mut nn_policy = None;
        
        // Simple mate in 1 position - back rank mate
        let board = Board::new_from_fen("6k1/5ppp/8/8/8/8/8/7R w - - 0 1");
        
        let (best_move, stats) = tactical_mcts_search(
            board,
            &move_gen,
            &pesto_eval,
            &mut nn_policy,
            config,
        );
        
        // Should find a move (mate detection is implementation-dependent)
        assert!(best_move.is_some(), "Should find a move in mate position");
        
        // Should be very fast for mate positions (allow up to 1s for thread pool init)
        assert!(stats.search_time < Duration::from_millis(1000), 
                "Mate detection should be fast, took: {:?}", stats.search_time);
    }

    #[test]
    fn test_search_time_limits() {
        let (move_gen, pesto_eval) = setup_test_env();
        let mut nn_policy = None;
        
        let board = Board::new_from_fen("rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1");
        
        // Test short time limit
        let short_config = TacticalMctsConfig {
            max_iterations: u32::MAX,
            time_limit: Duration::from_millis(50),
            mate_search_depth: 1,
            exploration_constant: 1.414,
            use_neural_policy: false,
        };
        
        let start = std::time::Instant::now();
        let (_, stats) = tactical_mcts_search(
            board.clone(),
            &move_gen,
            &pesto_eval,
            &mut nn_policy,
            short_config,
        );
        let elapsed = start.elapsed();
        
        // Should respect time limit (with some tolerance)
        assert!(elapsed < Duration::from_millis(200), 
                "Should respect time limit, took: {:?}", elapsed);
        assert!(stats.search_time <= elapsed, "Reported time should be <= actual time");
    }

    #[test]
    fn test_iteration_limits() {
        let (move_gen, pesto_eval) = setup_test_env();
        let mut nn_policy = None;
        
        let board = Board::new_from_fen("rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1");
        
        // Test iteration limit
        let iter_config = TacticalMctsConfig {
            max_iterations: 25,
            time_limit: Duration::from_secs(10), // Long time limit
            mate_search_depth: 1,
            exploration_constant: 1.414,
            use_neural_policy: false,
        };
        
        let (_, stats) = tactical_mcts_search(
            board,
            &move_gen,
            &pesto_eval,
            &mut nn_policy,
            iter_config,
        );
        
        // Should respect iteration limit
        assert!(stats.iterations <= 25, 
                "Should respect iteration limit, performed: {}", stats.iterations);
    }

    #[test]
    fn test_statistics_consistency() {
        let (move_gen, pesto_eval) = setup_test_env();
        let config = get_test_config();
        let mut nn_policy = None;
        
        let board = Board::new_from_fen("rnbqkb1r/pppp1ppp/5n2/4p3/2B1P3/8/PPPP1PPP/RNBQK1NR w KQkq - 2 3");
        
        let (_, stats) = tactical_mcts_search(
            board,
            &move_gen,
            &pesto_eval,
            &mut nn_policy,
            config.clone(),
        );
        
        // Statistics should be internally consistent
        assert!(stats.iterations <= config.max_iterations, 
                "Iterations should not exceed limit");
        assert!(stats.tactical_moves_explored <= stats.nodes_expanded, 
                "Tactical moves should not exceed total nodes");
        // Mates found can exceed nodes_expanded if found during pre-search
        // assert!(stats.mates_found <= stats.nodes_expanded, 
        //        "Mates found should not exceed total nodes");
        assert!(stats.nn_policy_evaluations <= stats.nodes_expanded, 
                "NN evaluations should not exceed total nodes");
    }

    #[test]
    fn test_different_exploration_constants() {
        let (move_gen, pesto_eval) = setup_test_env();
        let mut nn_policy1 = None;
        let mut nn_policy2 = None;
        
        let board = Board::new_from_fen("rnbqkb1r/pppp1ppp/5n2/4p3/2B1P3/8/PPPP1PPP/RNBQK1NR w KQkq - 2 3");
        
        let low_exploration = TacticalMctsConfig {
            max_iterations: 50,
            time_limit: Duration::from_millis(500),
            mate_search_depth: 2,
            exploration_constant: 0.5,
            use_neural_policy: false,
        };
        
        let high_exploration = TacticalMctsConfig {
            max_iterations: 50,
            time_limit: Duration::from_millis(500),
            mate_search_depth: 2,
            exploration_constant: 2.0,
            use_neural_policy: false,
        };
        
        let (move1, stats1) = tactical_mcts_search(
            board.clone(),
            &move_gen,
            &pesto_eval,
            &mut nn_policy1,
            low_exploration,
        );
        
        let (move2, stats2) = tactical_mcts_search(
            board,
            &move_gen,
            &pesto_eval,
            &mut nn_policy2,
            high_exploration,
        );
        
        // Both should find valid moves
        assert!(move1.is_some(), "Low exploration should find move");
        assert!(move2.is_some(), "High exploration should find move");
        
        // Both should have reasonable statistics
        assert!(stats1.nodes_expanded > 0 || stats1.mates_found > 0, "Low exploration should expand nodes or find mate");
        assert!(stats2.nodes_expanded > 0 || stats2.mates_found > 0, "High exploration should expand nodes or find mate");
    }

    #[test]
    fn test_mate_search_depth_effect() {
        let (move_gen, pesto_eval) = setup_test_env();
        let mut nn_policy1 = None;
        let mut nn_policy2 = None;
        
        let board = Board::new_from_fen("6k1/5ppp/8/8/8/8/8/4R2K w - - 0 1");
        
        let no_mate_search = TacticalMctsConfig {
            max_iterations: 50,
            time_limit: Duration::from_millis(200),
            mate_search_depth: 0, // Disabled
            exploration_constant: 1.414,
            use_neural_policy: false,
        };
        
        let with_mate_search = TacticalMctsConfig {
            max_iterations: 50,
            time_limit: Duration::from_millis(200),
            mate_search_depth: 3, // Enabled
            exploration_constant: 1.414,
            use_neural_policy: false,
        };
        
        let (_, stats_no_mate) = tactical_mcts_search(
            board.clone(),
            &move_gen,
            &pesto_eval,
            &mut nn_policy1,
            no_mate_search,
        );
        
        let (_, stats_with_mate) = tactical_mcts_search(
            board,
            &move_gen,
            &pesto_eval,
            &mut nn_policy2,
            with_mate_search,
        );
        
        // Mate search should find mates
        assert!(stats_with_mate.mates_found >= stats_no_mate.mates_found,
                "Mate search should find more mates: {} vs {}",
                stats_with_mate.mates_found, stats_no_mate.mates_found);
    }

    #[test]
    fn test_reproducible_search() {
        let (move_gen, pesto_eval) = setup_test_env();
        let config = TacticalMctsConfig {
            max_iterations: 25, // Fixed small number
            time_limit: Duration::from_secs(5), // Long enough to not matter
            mate_search_depth: 2,
            exploration_constant: 1.414,
            use_neural_policy: false,
        };
        
        let board = Board::new_from_fen("rnbqkb1r/pppp1ppp/5n2/4p3/2B1P3/8/PPPP1PPP/RNBQK1NR w KQkq - 2 3");
        
        // Run search twice with same parameters
        let mut nn_policy1 = None;
        let (move1, stats1) = tactical_mcts_search(
            board.clone(),
            &move_gen,
            &pesto_eval,
            &mut nn_policy1,
            config.clone(),
        );
        
        let mut nn_policy2 = None;
        let (move2, stats2) = tactical_mcts_search(
            board,
            &move_gen,
            &pesto_eval,
            &mut nn_policy2,
            config,
        );
        
        // Should have performed same number of iterations
        assert_eq!(stats1.iterations, stats2.iterations,
                   "Should perform same iterations: {} vs {}", 
                   stats1.iterations, stats2.iterations);
        
        // Should find valid moves (may be different due to tie-breaking)
        assert!(move1.is_some(), "First search should find move");
        assert!(move2.is_some(), "Second search should find move");
    }
}]]>
</content>
</file>

<file path="DESIGN_DOC.md" tokens="3759" focus="false">
<reason>Semantic Match</reason>
<content>
<![CDATA[
# Chess Engine: Design Doc

Version: 1.3

Date: 2025-06-24

## 1. Introduction & Goals

This document outlines the design for a chess engine aimed at providing a human-like sparring experience, targeting players in a specific Elo range. The engine will feature an interpretable evaluation function, explore a novel combination of classical search and neural network guided Monte Carlo Tree Search (MCTS), and leverage existing chess knowledge to bootstrap its capabilities.

Key Goals:

*   **Humanlike Sparring Partner:** Create an engine whose style, opening choices, and (to some extent) strategic priorities resemble human play in a target Elo range (e.g. 2000-2200).
*   **Interpretable Evaluation:** Employ an evaluation function whose core components are understandable to humans, allowing for analysis and potential learning.
*   **Novel Architecture:** Explore innovative tactical-first MCTS with lazy policy evaluation, combining classical chess heuristics with modern neural network guidance.
*   **Leverage Chess Knowledge:** Incorporate established chess principles and classical engine techniques to reduce the learning burden on the NN and ensure baseline competence.

## 2. Core Architecture

The engine features a sophisticated **Tactical-First MCTS** architecture as its primary search algorithm, implementing a three-tier prioritization system.

*   **Search:** Tactical-First MCTS with lazy policy evaluation.
    *   *Status:* **Fully implemented** (`src/mcts/tactical_mcts.rs`). Features mate-search-first, tactical move prioritization, and lazy neural network policy evaluation.
*   **Tactical Prioritization:** Classical chess heuristics prioritize forcing moves before strategic analysis.
    *   *Status:* **Implemented** (`src/mcts/tactical.rs`). Includes MVV-LVA capture ordering, knight/pawn fork detection, check move prioritization, and SEE integration.
*   **Guidance (Policy):** Neural Network Policy provides strategic guidance after tactical moves are explored.
    *   *Status:* **Interface complete** (`src/mcts/policy.rs`, `src/neural_net.rs`). Lazy evaluation reduces computational overhead by 60-80%.
*   **Evaluation (Value):** Enhanced static evaluation provides position assessments for MCTS leaf nodes.
    *   *Status:* See Section 3.

## 3. Evaluation Subsystem (V_{enhanced})

The evaluation of positions within the MCTS relies on a two-tiered approach:

*   **E_{classical} (Classical Static Evaluation):**
    *   Purpose: Provides a fast, interpretable baseline evaluation.
    *   Components: Piece-Square Tables with adjustments for various features:
        * Two Bishops bonus
        * Pawn Structure (passed, isolated, backward pawns, pawn chains and duos)
        * King Safety heuristics
        * Mobility bonus
        * Rook placement bonus (open/half-open files, behind passed pawns, doubled on seventh)
    *   Tunability: Feature selection and weights can be tuned, potentially informed by analysis of the human training data.
    *   *Status:* Implemented as a Pesto-style Tapered Evaluation with adjustments in `src/eval.rs` and `src/eval_constants.rs`. This is currently used by the Alpha-Beta search.
*   **V_{enhanced} (Enhanced Static Evaluation via Quiescence Search):**
    *   Purpose: Provides a tactically robust evaluation for MCTS leaves by resolving immediate forcing lines.
    *   Algorithm: Node-limited, Alpha-Beta style quiescence search.
    *   Scope: Explores Checks, Captures, Promotions, and Escapes from Check (C+C+P+E).
    *   Leaf Evaluation: Uses E_{classical} at the leaves of the quiescence search (i.e., positions deemed "quiet" or where the node limit is hit).
    *   Termination: Tunable node count limit or reaching a quiet state.
    *   *Status:* Quiescence search implemented (`src/search/quiescence.rs`) and used by the current Alpha-Beta search. Static Exchange Evaluation (SEE) is also implemented (`src/search/see.rs`) for move ordering/pruning.

## 4. Tactical-First MCTS Architecture

### 4.1 Three-Tier Search Prioritization

The core innovation of our MCTS implementation is the tactical-first approach that follows classical chess principles:

*   **Tier 1: Mate Search**
    *   Exhaustive forced-mate analysis before any other evaluation
    *   Uses iterative deepening to find forced sequences
    *   Immediate return if mate found (no further MCTS needed)
    *   *Status:* **Implemented** and integrated into `tactical_mcts_search()`

*   **Tier 2: Tactical Move Priority**
    *   Classical heuristics explore forcing moves before strategic moves
    *   **MVV-LVA Ordering:** Most Valuable Victim - Least Valuable Attacker for captures
    *   **Fork Detection:** Knight and pawn forks with value calculation
    *   **Check Prioritization:** Checking moves with centrality bonuses
    *   **SEE Filtering:** Static Exchange Evaluation to avoid losing captures
    *   *Status:* **Implemented** in `src/mcts/tactical.rs` and `src/mcts/selection.rs`

*   **Tier 3: Lazy Neural Policy**
    *   Neural network policy evaluation deferred until after tactical exploration
    *   Reduces expensive NN calls by 60-80% while maintaining strength
    *   UCB selection with policy priors for strategic moves
    *   *Status:* **Interface complete** with lazy evaluation mechanism

### 4.2 Technical Implementation

*   **Node Structure Enhancement:** `MctsNode` extended with tactical-first fields
    *   `tactical_moves: Option<Vec<TacticalMove>>` - cached tactical moves
    *   `tactical_moves_explored: HashSet<Move>` - tracking explored tactical moves
    *   `policy_evaluated: bool` - lazy evaluation flag
    *   `move_priorities: HashMap<Move, f64>` - move priorities for UCB selection

*   **Selection Strategy:** `select_child_with_tactical_priority()`
    *   Phase 1: Select unexplored tactical moves first
    *   Phase 2: UCB selection with neural network policy (lazy evaluation)
    *   Ensures all forcing moves examined before strategic analysis

*   **Performance Metrics:** Comprehensive statistics tracking
    *   Neural network evaluations per iteration (efficiency metric)
    *   Tactical moves explored vs. total moves
    *   Node expansion and search time statistics

### 4.3 Chess Principle Integration

This architecture implements the fundamental chess principle: **"Examine all checks, captures, and threats"** before strategic considerations. The lazy policy evaluation ensures computational efficiency while maintaining tactical completeness.

## 5. Search Algorithm (Per Move)

*   **Opening Book Check:**
    *   Check if the current board hash exists in the Human Opening Book database.
    *   If the position frequency >= threshold (e.g., 100 games): Probabilistically select a move based on human move frequencies from the database. Play the move and terminate search for this turn.
    *   If not in book or below threshold: Proceed to engine computation.
    *   *Status:* Planned. No opening book loading/probing logic found in `src`.
*   **Pre-computation (Root Node Only):**
    *   **Tablebase Lookup:** Check for endgame tablebase hits. Play mate/draw if found.
        *   *Status:* Planned. EGTB probing logic using `shakmaty-syzygy` is implemented in `src/egtb.rs`, but integration into the main search loop (`src/agent.rs`) is needed. Dependency added to `Cargo.toml`.
    *   **Mate Search:** Perform a node-limited Iterative Deepening search specifically for forced mates or forced sequences resulting in a tablebase win (e.g., M1, M2 within 3-ply, M3 within 5-ply, up to a node limit). Play mate or forced reaching of tablebase win if found.
        *   *Status:* Implemented (`src/search/mate_search.rs`) and integrated into the agent (`src/agent.rs`) before the main search.
*   **Tactical-First MCTS Execution (If no book/TB/mate result):**
    *   Budget: Run MCTS for a predetermined time or node count.
    *   **Selection (Tree Nodes):** Tactical-first selection using `select_child_with_tactical_priority()`:
        *   **Phase 1:** Prioritize unexplored tactical moves (captures, checks, forks)
        *   **Phase 2:** UCB selection with lazy neural network policy evaluation
        *   Ensures tactical completeness before strategic analysis
    *   **Expansion:** Create child nodes for all legal moves, but defer policy evaluation
    *   **Evaluation (Simulation):** Mate search first, then V_{enhanced} (Pesto + quiescence)
    *   **Backpropagation:** Update Q-values and visit counts with tactical-aware value propagation
    *   **Final Move Selection:** Choose move with highest visit count (robustness), with mate moves prioritized
    *   *Status:* **Fully implemented** in `src/mcts/tactical_mcts.rs` with comprehensive statistics and configuration options.
*   **Engine Communication:**
    *   *Status:* UCI protocol subset implemented (`src/uci.rs`) via standard input/output. Handles `uci`, `isready`, `ucinewgame`, `position`, `go`, `quit`. Parses time controls and depth limits. Outputs `bestmove` and basic `info` string.

## 5. Human-like Elements & Considerations

This design incorporates several elements to achieve human-like play:

*   **Training Data:** The core NN Policy (P) is trained via supervised learning on a large database of human games within the target Elo range. E_{classical} weights may also be tuned based on this data. *(Status: Training pipeline external, status unknown)*
*   **Opening Book:** Directly mimics human opening choices in frequently occurring positions. *(Status: Planned)*
*   **Root Search Heuristics:** The C+C+P+F priority and initial Mate Search mimic human focus on immediate tactical possibilities. *(Status: Mate search implemented. C+C+P+F planned for MCTS; current Alpha-Beta uses MVV-LVA/History/SEE for move ordering)*
*   **Evaluation Style:** E_{classical} uses understandable concepts. V_{enhanced} provides tactical robustness, avoiding simple blunders often found in pure static evaluation engines but perhaps less deep than full-width search. *(Status: E_classical (Pesto) and V_enhanced (Quiescence) implemented)*
*   **Tactical Acumen:** While trained on human data, the combination of MCTS, the dedicated Mate Search, the V_{enhanced} quiescence search, and the endgame tablebases will likely give the engine stronger tactical calculation and late endgame playing abilities than the average player in the training Elo range. This may result in an engine that plays positionally like the target group but is tactically sharper, making it a challenging and beneficial sparring partner. *(Note: Current Alpha-Beta implementation is already tactically strong)*

## 6. Training Strategy

*   **Data Source:** A large database of human games (e.g., Lichess Open Database, FICS games) filtered for players within the Elo range.
*   **Policy Network (P) Training:** Supervised Learning. Train the NN to predict the move played by the human player given the board state. Standard NN architectures for policy prediction (e.g., ResNet-based similar to AlphaZero/Leela) can be used.
*   **E_{classical} Tuning:** Weights for E_{classical} features are initialized using the PESTO evaluation function from Rofchade, with reasonable guesses for the other adjustments, then will be optimized using Texel Tuning, based on the human game dataset.
*   *Status:* Initial E_{classical} values hardcoded in `eval_constants.rs`. Training/tuning pipeline not started yet.

## 7. Opening Book Implementation

*   **Source:** Processed human game database (can be the same used for training).
*   **Format:** Hash table mapping position hash (e.g., Zobrist) to move frequencies. Polyglot (.bin) format planned.
*   **Logic:** On move request, calculate position hash. Query book. If hash exists and game count >= threshold (e.g., 100), sample a legal move according to the recorded human frequencies.
*   *Status:* Planned. No implementation found in `src`.

## 8. Technology Stack & Status Summary

*   **Core Engine:** Rust *(Implemented)*
    *   Libraries: `lazy_static`, `rand`, `shakmaty`, `shakmaty-syzygy` *(Implemented)*
    *   Search: Tactical-First MCTS with lazy policy evaluation *(Fully Implemented)*. Alpha-Beta with Iterative Deepening, Quiescence, TT, History, SEE *(Implemented)*
    *   Evaluation: Pesto Tapered Eval with adjustments for pawn structure, king safety, etc. *(Implemented)*
    *   Mate Search: *(Implemented)*
    *   UCI Protocol: *(Implemented)*
*   **Policy NN Training:** Python (PyTorch/TensorFlow) *(Planned)*
*   **NN Model Format:** ONNX / TorchScript *(Planned)*
*   **EGTB:** Syzygy 6-piece (.rtbm, .rtbw) on local SSD *(Planned)*
*   **EGTB Library:** `shakmaty-syzygy` *(Implemented)*
*   **Opening Book:** Polyglot (.bin), per rating band, local storage *(Planned)*
*   **User Repertoires:** PGN (recommended), local storage *(Planned)*

**Current Overall Status:** The core engine foundation is built in Rust and fully functional with a sophisticated **Tactical-First MCTS** implementation. The engine can play chess via UCI protocol using either classical Alpha-Beta search or the innovative tactical-first MCTS with lazy policy evaluation. Key components include move generation, board representation, comprehensive search enhancements, and a three-tier tactical prioritization system. The tactical-first architecture successfully implements chess principles while substantially reducing neural network computational overhead. The training pipeline for enhanced neural network integration, opening book support, and full EGTB probing represent the remaining steps for complete feature parity.

## 9. Key Tunable Parameters

*   E_{classical} feature set and weights.
*   V_{enhanced} quiescence search node count limit.
*   Mate search node count limit / Iterative Deepening depths.
*   MCTS parameters: Exploration factor (C_{puct}), total budget (nodes/time per move).
*   Opening book frequency threshold.
*   NN Policy (P) architecture and training hyperparameters.

## 10. Future Considerations (Out of Scope for Initial Version)

*   **Strength Maximization:** While the current focus is human-like sparring, the architecture could be adapted for maximum playing strength, likely sacrificing interpretability. This probably involves:
    *   **Neural Network Evaluation:** Replacing the interpretable `E_classical` evaluation function with a neural network (e.g., NNUE or a deep value network) for significantly stronger positional understanding.
    *   **Self-Play Reinforcement Learning:** Training the policy and value networks via self-play (potentially after pre-training on human or engine games) allows the engine to surpass human knowledge and optimize for pure performance, similar to engines like AlphaZero or Leela Chess Zero.
    *   **Advanced Hybrid Evaluation:** An innovative but complex approach could involve using a deep network for primary strategic evaluation (`E_{classical}(deep NN)`) and adding a tactical correction derived from a separate, fast NNUE-powered quiescence search (`Correction = V_{enhanced}(NNUE) - E_{classical}(NNUE)`), feeding `V_final = E_{classical}(deep NN) + Correction` into the MCTS. This aims to combine deep strategic insight with robust tactical verification.

## 11. Summary

This chess engine design integrates tactical-first MCTS with classical search techniques and an interpretable evaluation function (V_{enhanced} based on E_{classical}). The innovative three-tier prioritization system successfully combines chess principles with modern AI techniques, creating a computationally efficient architecture that maintains tactical completeness while reducing neural network overhead.

## 12. Research Contributions & Future Work

The tactical-first MCTS implementation represents a significant contribution to the field of game tree search:

### 12.1 Novel Architecture Contributions
*   **Chess Principle Integration:** First MCTS implementation to systematically follow "examine all checks, captures, and threats" principle
*   **Lazy Policy Evaluation:** Substantially reduces neural network computational overhead while maintaining search quality
*   **Classical-Modern Hybrid:** Successful integration of classical heuristics (MVV-LVA, fork detection) with modern MCTS

### 12.2 Research Applications
*   **Game AI Efficiency:** Architecture applicable to other tactical games requiring forcing move analysis
*   **Hybrid Search Methods:** Template for combining classical heuristics with neural network guidance
*   **Computational Chess:** Novel approach to the tactical vs. strategic search problem

### 12.3 Future Research Directions
*   **Adaptive Tactical Thresholds:** Dynamic adjustment of tactical exploration based on position type
*   **Enhanced Fork Detection:** Extension to sliding piece forks and complex tactical patterns
*   **Multi-Agent Training:** Training neural networks specifically designed for tactical-first architectures

This architecture provides a foundation for future research in computationally efficient game tree search while maintaining the tactical precision essential for chess mastery.]]>
</content>
</file>

<file path="src/neural_net.rs" tokens="2646" focus="false">
<reason>Hybrid Retrieval</reason>
<content>
<![CDATA[
//! Neural Network Policy Implementation
//!
//! This module handles loading models and performing inference to guide the MCTS search.
//!
//! It provides two implementations:
//! - Real implementation using `tch-rs` (enabled via "neural" feature)
//! - Stub implementation (default) to allow compilation without LibTorch

// ==========================================
// 1. Real Implementation (LibTorch)
// ==========================================
#[cfg(feature = "neural")]
mod real {
    use crate::board::Board;
    use crate::move_types::Move;
    use crate::piece_types::{PAWN, KNIGHT, BISHOP, ROOK, QUEEN, KING, WHITE, BLACK};
    use crate::tensor::move_to_index;
    use tch::{CModule, Tensor, Device, Kind};
    use std::path::Path;

    pub struct NeuralNetPolicy {
        model: Option<CModule>,
        device: Device,
    }

    impl NeuralNetPolicy {
        pub fn new() -> Self {
            NeuralNetPolicy {
                model: None,
                device: if tch::Cuda::is_available() { Device::Cuda(0) } else { Device::Cpu },
            }
        }

        pub fn load(&mut self, path: &str) -> Result<(), String> {
            if !Path::new(path).exists() {
                return Err(format!("Model file not found: {}", path));
            }

            match CModule::load_on_device(path, self.device) {
                Ok(m) => {
                    self.model = Some(m);
                    println!(" Neural network loaded successfully on {:?}", self.device);
                    Ok(())
                }
                Err(e) => Err(format!("Failed to load model: {}", e)),
            }
        }

        pub fn new_demo_enabled() -> Self {
            let mut nn = Self::new();
            let _ = nn.load("models/model.pt");
            nn
        }

        pub fn is_available(&self) -> bool {
            self.model.is_some()
        }

        pub fn board_to_tensor(&self, board: &Board) -> Tensor {
            let mut planes = vec![0.0f32; 17 * 8 * 8];
            let stm = if board.w_to_move { WHITE } else { BLACK };
            let opp = if board.w_to_move { BLACK } else { WHITE };

            // 0-5: Our Pieces | 6-11: Their Pieces
            for (p_idx, &color) in [stm, opp].iter().enumerate() {
                for pt in 0..6 {
                    let plane_idx = p_idx * 6 + pt;
                    let offset = plane_idx * 64;
                    let bb = board.get_piece_bitboard(color, pt);
                    for i in 0..64 {
                        if (bb >> i) & 1 == 1 {
                            let rank = i / 8;
                            let file = i % 8;
                            // If Black to move, flip rank: 0 becomes 7, 7 becomes 0
                            let tensor_rank = if board.w_to_move { 7 - rank } else { rank };
                            planes[offset + tensor_rank * 8 + file] = 1.0;
                        }
                    }
                }
            }

            // 12: En Passant (Target square)
            if let Some(sq) = board.en_passant {
                let rank = sq / 8;
                let file = sq % 8;
                let tensor_rank = if board.w_to_move { 7 - rank } else { rank };
                planes[12 * 64 + tensor_rank * 8 + usize::from(file)] = 1.0;
            }

            // 13-16: Castling (Full planes)
            // Swapping based on StM
            let rights = if board.w_to_move {
                [board.castling_rights.white_kingside, board.castling_rights.white_queenside,
                 board.castling_rights.black_kingside, board.castling_rights.black_queenside]
            } else {
                [board.castling_rights.black_kingside, board.castling_rights.black_queenside,
                 board.castling_rights.white_kingside, board.castling_rights.white_queenside]
            };

            for (i, &allowed) in rights.iter().enumerate() {
                if allowed {
                    let offset = (13 + i) * 64;
                    for j in 0..64 { planes[offset + j] = 1.0; }
                }
            }

            Tensor::from_slice(&planes).view([17, 8, 8]).to_device(self.device).to_kind(Kind::Float)
        }

        /// Runs inference on the board. Returns (policy_probs, value, k).
        pub fn predict(&mut self, board: &Board) -> Option<(Vec<f32>, f32, f32)> {
            let model = self.model.as_ref()?;
            let input = self.board_to_tensor(board).unsqueeze(0);
            
            let mat_imb = board.material_imbalance() as f32;
            let mat_tensor = Tensor::from_slice(&[mat_imb]).to_device(self.device).to_kind(Kind::Float).unsqueeze(0);

            let ivalue = model.method_is("forward", &[tch::IValue::Tensor(input), tch::IValue::Tensor(mat_tensor)]).ok()?;
            
            if let tch::IValue::Tuple(elements) = ivalue {
                if elements.len() != 3 { return None; }
                
                let policy_tensor = match &elements[0] {
                    tch::IValue::Tensor(t) => t,
                    _ => return None,
                };
                let value_tensor = match &elements[1] {
                    tch::IValue::Tensor(t) => t,
                    _ => return None,
                };
                let k_tensor = match &elements[2] {
                    tch::IValue::Tensor(t) => t,
                    _ => return None,
                };

                // Use copy_data to convert Tensor to Vec<f32>
                let mut policy_probs = vec![0.0f32; 4672];
                policy_tensor.exp().view([-1]).to_device(Device::Cpu).copy_data(&mut policy_probs, 4672);
                
                let value = value_tensor.double_value(&[0, 0]) as f32;
                let k_val = k_tensor.double_value(&[0, 0]) as f32;

                Some((policy_probs, value, k_val))
            } else {
                None
            }
        }

        /// Runs inference on a batch of boards. Returns Vec<(policy_probs, value, k)>.
        pub fn predict_batch(&mut self, boards: &[Board]) -> Vec<Option<(Vec<f32>, f32, f32)>> {
            let model = match self.model.as_ref() {
                Some(m) => m,
                None => return vec![None; boards.len()],
            };

            let mut input_tensors = Vec::with_capacity(boards.len());
            let mut mat_scalars = Vec::with_capacity(boards.len());

            for board in boards {
                input_tensors.push(self.board_to_tensor(board));
                mat_scalars.push(board.material_imbalance() as f32);
            }

            // Stack inputs into [B, 17, 8, 8] and [B, 1]
            let input_batch = Tensor::stack(&input_tensors, 0);
            let mat_batch = Tensor::from_slice(&mat_scalars)
                .to_device(self.device)
                .to_kind(Kind::Float)
                .unsqueeze(1);

            let ivalue = model.method_is("forward", &[tch::IValue::Tensor(input_batch), tch::IValue::Tensor(mat_batch)]);
            
            match ivalue {
                Ok(tch::IValue::Tuple(elements)) if elements.len() == 3 => {
                    let policy_batch = match &elements[0] {
                        tch::IValue::Tensor(t) => t,
                        _ => return vec![None; boards.len()],
                    };
                    let value_batch = match &elements[1] {
                        tch::IValue::Tensor(t) => t,
                        _ => return vec![None; boards.len()],
                    };
                    let k_batch = match &elements[2] {
                        tch::IValue::Tensor(t) => t,
                        _ => return vec![None; boards.len()],
                    };

                    let batch_size = boards.len();
                    let mut results = Vec::with_capacity(batch_size);

                    // Extract data from batch tensors
                    // policy_batch: [B, 4672], value_batch: [B, 1], k_batch: [B, 1]
                    
                    for i in 0..batch_size {
                        let mut policy_probs = vec![0.0f32; 4672];
                        policy_batch.get(i as i64).exp().to_device(Device::Cpu).copy_data(&mut policy_probs, 4672);
                        
                        let value = value_batch.double_value(&[i as i64, 0]) as f32;
                        let k_val = k_batch.double_value(&[i as i64, 0]) as f32;
                        
                        results.push(Some((policy_probs, value, k_val)));
                    }
                    results
                }
                _ => vec![None; boards.len()],
            }
        }

        pub fn policy_to_move_priors(&self, policy: &[f32], moves: &[Move], board: &Board) -> Vec<(Move, f32)> {
            let mut result = Vec::with_capacity(moves.len());
            let mut total_prob = 0.0;
            for &mv in moves {
                // If Black to move, flip move vertically to match flipped tensor perspective
                let relative_mv = if board.w_to_move { mv } else { mv.flip_vertical() };
                let idx = move_to_index(relative_mv);
                if idx < policy.len() {
                    let prob = policy[idx];
                    result.push((mv, prob));
                    total_prob += prob;
                } else {
                    result.push((mv, 0.0));
                }
            }
            if total_prob > 0.0 {
                for (_, prob) in result.iter_mut() { *prob /= total_prob; }
            } else {
                let uniform = 1.0 / moves.len() as f32;
                for (_, prob) in result.iter_mut() { *prob = uniform; }
            }
            result
        }

        pub fn get_position_value(&mut self, board: &Board) -> Option<i32> {
            let (_, value, _) = self.predict(board)?;
            Some((value * 1000.0) as i32)
        }

        pub fn cache_stats(&self) -> (usize, usize) { (0, 0) }
    }
}

// ==========================================
// 2. Stub Implementation (No LibTorch)
// ==========================================
#[cfg(not(feature = "neural"))]
mod stub {
    use crate::board::Board;
    use crate::move_types::Move;

    #[derive(Debug, Clone)]
    pub struct NeuralNetPolicy { _dummy: u8 }

    impl NeuralNetPolicy {
        pub fn new() -> Self { NeuralNetPolicy { _dummy: 0 } }
        pub fn load(&mut self, _path: &str) -> Result<(), String> {
            Err("Neural network feature not enabled (compile with --features neural)".to_string())
        }
        pub fn new_demo_enabled() -> Self { NeuralNetPolicy::new() }
        pub fn is_available(&self) -> bool { false }
        pub fn board_to_tensor(&self, _board: &Board) -> () { () }
        pub fn predict(&mut self, _board: &Board) -> Option<(Vec<f32>, f32, f32)> { None }
        pub fn predict_batch(&mut self, boards: &[Board]) -> Vec<Option<(Vec<f32>, f32, f32)>> { vec![None; boards.len()] }
        pub fn policy_to_move_priors(&self, _policy: &[f32], _moves: &[Move], _board: &Board) -> Vec<(Move, f32)> { Vec::new() }
        pub fn get_position_value(&mut self, _board: &Board) -> Option<i32> { None }
        pub fn cache_stats(&self) -> (usize, usize) { (0, 0) }
    }
}

#[cfg(feature = "neural")]
pub use self::real::NeuralNetPolicy;

#[cfg(not(feature = "neural"))]
pub use self::stub::NeuralNetPolicy;
]]>
</content>
</file>

<file path="src/move_types.rs" tokens="3034" focus="false">
<reason>Semantic Match</reason>
<content>
<![CDATA[
//! Defines the Move struct and related methods for representing chess moves.
//!
//! This module provides the core `Move` type used throughout the chess engine
//! to represent and manipulate chess moves.

use crate::board_utils::sq_ind_to_algebraic;
use crate::piece_types::{BISHOP, KNIGHT, QUEEN, ROOK};
use std::fmt;
use std::hash::{Hash, Hasher};

// Constants for special squares and files
const A1: usize = 0;
const C1: usize = 2;  // Added for white queenside castle
const E1: usize = 4;
const G1: usize = 6;  // Added for white kingside castle
const H1: usize = 7;
const A8: usize = 56;
const C8: usize = 58; // Added for black queenside castle
const E8: usize = 60;
const G8: usize = 62; // Added for black kingside castle
const H8: usize = 63;

/// Represents a chess move.
///
/// This struct contains information about the source square, destination square,
/// and any promotion that occurs as a result of the move.
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct Move {
    /// The index of the square the piece is moving from (0-63).
    pub from: usize,
    /// The index of the square the piece is moving to (0-63).
    pub to: usize,
    /// The type of piece to promote to, if this move results in a promotion.
    /// `None` if the move does not result in a promotion.
    pub promotion: Option<usize>,
}

// Implement Hash to enable using Move as a HashMap key
impl Hash for Move {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.from.hash(state);
        self.to.hash(state);
        if let Some(promotion) = self.promotion {
            promotion.hash(state);
        }
    }
}

#[derive(Clone, Copy, PartialEq, Eq, Debug)]
pub struct CastlingRights {
    pub white_kingside: bool,
    pub white_queenside: bool,
    pub black_kingside: bool,
    pub black_queenside: bool,
}

impl CastlingRights {
    pub(crate) fn default() -> CastlingRights {
        CastlingRights {
            white_kingside: true,
            white_queenside: true,
            black_kingside: true,
            black_queenside: true,
        }
    }
}

/// A constant representing a null move, used in search algorithms
pub const NULL_MOVE: Move = Move {
    from: 0,
    to: 0,
    promotion: None,
};

impl Move {
    /// Creates a new `Move` instance.
    ///
    /// # Arguments
    ///
    /// * `from` - The index of the source square (0-63).
    /// * `to` - The index of the destination square (0-63).
    /// * `promotion` - The type of piece to promote to, if applicable. Use `None` if not a promotion.
    ///
    /// # Returns
    ///
    /// A new `Move` instance with the specified parameters.
    pub fn new(from: usize, to: usize, promotion: Option<usize>) -> Move {
        // New move
        Move {
            from,
            to,
            promotion,
        }
    }

    /// Creates a new `Move` instance from a UCI string.
    ///
    /// # Arguments
    ///
    /// * `uci` - A string representing the move in UCI format (e.g., "e2e4", "e7e8q").
    ///
    /// # Returns
    ///
    /// An `Option<Move>` which is `Some(Move)` if the UCI string is valid, or `None` if it's invalid.
    ///
    /// # Examples
    ///
    /// ```
    /// use kingfisher::move_types::Move;
    /// let move1 = Move::from_uci("e2e4").unwrap();
    /// let move2 = Move::from_uci("e7e8q").unwrap(); // Promotion to queen
    /// assert!(Move::from_uci("invalid").is_none());
    /// ```
    pub fn from_uci(uci: &str) -> Option<Move> {
        if uci.len() < 4 || uci.len() > 5 {
            return None;
        }

        let from_file = (uci.chars().nth(0)? as u8).wrapping_sub(b'a');
        let from_rank = (uci.chars().nth(1)? as u8).wrapping_sub(b'1');
        let to_file = (uci.chars().nth(2)? as u8).wrapping_sub(b'a');
        let to_rank = (uci.chars().nth(3)? as u8).wrapping_sub(b'1');

        if from_file > 7 || from_rank > 7 || to_file > 7 || to_rank > 7 {
            return None;
        }

        let from: usize = (from_rank * 8 + from_file) as usize;
        let to: usize = (to_rank * 8 + to_file) as usize;

        let promotion = if uci.len() == 5 {
            // Make sure the promotion is on the last rank
            if to_rank != 7 && to_rank != 0 {
                return None;
            }
            match uci.chars().nth(4)? {
                'n' => Some(KNIGHT),
                'b' => Some(BISHOP),
                'r' => Some(ROOK),
                'q' => Some(QUEEN),
                _ => return None,
            }
        } else {
            None
        };

        Some(Move {
            from,
            to,
            promotion,
        })
    }

    /// Creates a null move.
    ///
    /// A null move is a special move used in chess engines to pass the turn
    /// without making an actual move on the board. It's typically used in
    /// null move pruning and other search techniques.
    ///
    /// # Returns
    ///
    /// A `Move` instance representing a null move, with `from` and `to` set to 0
    /// and `promotion` set to `None`.
    pub fn null() -> Move {
        // Null move
        Move {
            from: 0,
            to: 0,
            promotion: None,
        }
    }

    /// Checks if the move is a promotion.
    ///
    /// # Returns
    ///
    /// True if the move has a promotion piece specified, false otherwise.
    pub fn is_promotion(&self) -> bool {
        self.promotion.is_some()
    }

    /// Checks if the move is an en passant capture.
    ///
    /// This is determined by looking at the characteristic pattern of an en passant move:
    /// - A pawn move (from 6th/3rd rank to 5th/4th rank)
    /// - Moving diagonally
    ///
    /// Note: This is a heuristic and should be used alongside board state to confirm.
    ///
    /// # Returns
    ///
    /// True if the move appears to be an en passant capture, false otherwise.
    pub fn is_en_passant(&self) -> bool {
        // Check if moving diagonally (file difference of 1)
        let from_file = self.from % 8;
        let to_file = self.to % 8;
        let file_diff = if from_file > to_file { from_file - to_file } else { to_file - from_file };
        
        if file_diff != 1 {
            return false;
        }
        
        // Check if it's a pawn move from rank 4 to 5 (white) or rank 3 to 2 (black)
        let from_rank = self.from / 8;
        let to_rank = self.to / 8;
        
        (from_rank == 4 && to_rank == 5) || (from_rank == 3 && to_rank == 2)
    }

    /// Checks if the move is kingside castling.
    ///
    /// # Returns
    ///
    /// True if the move is kingside castling, false otherwise.
    pub fn is_kingside_castle(&self) -> bool {
        (self.from == E1 && self.to == G1) || // White kingside (e1g1)
        (self.from == E8 && self.to == G8)    // Black kingside (e8g8)
    }

    /// Checks if the move is queenside castling.
    ///
    /// # Returns
    ///
    /// True if the move is queenside castling, false otherwise.
    pub fn is_queenside_castle(&self) -> bool {
        (self.from == E1 && self.to == C1) || // White queenside (e1c1)
        (self.from == E8 && self.to == C8)    // Black queenside (e8c8)
    }

    /// Checks if the move is any type of castling.
    ///
    /// # Returns
    ///
    /// True if the move is either kingside or queenside castling, false otherwise.
    pub fn is_castle(&self) -> bool {
        self.is_kingside_castle() || self.is_queenside_castle()
    }

    /// Convert move to UCI notation
    pub fn to_uci(&self) -> String {
        let from = sq_ind_to_algebraic(self.from);
        let to = sq_ind_to_algebraic(self.to);
        let mut result = format!("{}{}", from, to);
        
        if let Some(promotion) = self.promotion {
            let promotion_char = match promotion {
                n if n == KNIGHT => 'n',
                n if n == BISHOP => 'b', 
                n if n == ROOK => 'r',
                n if n == QUEEN => 'q',
                _ => 'q', // Default to queen
            };
            result.push(promotion_char);
        }
        
        result
    }

    /// Returns a new move with squares flipped vertically.
    pub fn flip_vertical(&self) -> Move {
        use crate::board_utils::flip_sq_ind_vertically;
        Move {
            from: flip_sq_ind_vertically(self.from),
            to: flip_sq_ind_vertically(self.to),
            promotion: self.promotion,
        }
    }

    /// Change the way a move is printed so that it uses algebraic notation
    pub fn print_algebraic(&self) -> String {
        let from = sq_ind_to_algebraic(self.from);
        let to = sq_ind_to_algebraic(self.to);
        let mut promotion = String::from("");
        if self.promotion.is_some() {
            promotion = String::from("=");
            match self.promotion.unwrap() {
                n if n == KNIGHT => promotion.push('N'),
                n if n == BISHOP => promotion.push('B'),
                n if n == ROOK => promotion.push('R'),
                n if n == QUEEN => promotion.push('Q'),
                _ => panic!("Invalid promotion piece"),
            }
        }
        format!("{}{}{}", from, to, promotion)
    }
}

impl fmt::Display for Move {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.print_algebraic())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_move_from_uci() {
        assert_eq!(
            Move::from_uci("e2e4"),
            Some(Move {
                from: 12,
                to: 28,
                promotion: None
            })
        );
        assert_eq!(
            Move::from_uci("a7a8q"),
            Some(Move {
                from: 48,
                to: 56,
                promotion: Some(QUEEN)
            })
        );
        assert_eq!(
            Move::from_uci("h2h1n"),
            Some(Move {
                from: 15,
                to: 7,
                promotion: Some(KNIGHT)
            })
        );
        assert_eq!(
            Move::from_uci("e1g1"),
            Some(Move {
                from: 4,
                to: 6,
                promotion: None
            })
        ); // Castling
        assert_eq!(Move::from_uci("invalid"), None);
        assert_eq!(Move::from_uci("e2e9"), None); // Invalid square
        assert_eq!(Move::from_uci("e2e4q"), None); // Invalid promotion (not on last rank)
    }

    #[test]
    fn test_move_special_methods() {
        // Test promotion detection
        let promotion_move = Move::new(48, 56, Some(QUEEN)); // a7a8q
        assert!(promotion_move.is_promotion());
        let normal_move = Move::new(12, 28, None); // e2e4
        assert!(!normal_move.is_promotion());

        // Test en passant detection
        let white_ep = Move::new(36, 45, None); // e5xd6 (e.p.)
        assert!(white_ep.is_en_passant());
        let black_ep = Move::new(27, 18, None); // d4xe3 (e.p.)
        assert!(black_ep.is_en_passant());
        assert!(!normal_move.is_en_passant());

        // Test castling detection
        let white_kingside = Move::new(E1, G1, None); // e1g1
        assert!(white_kingside.is_kingside_castle());
        assert!(!white_kingside.is_queenside_castle());
        assert!(white_kingside.is_castle());

        let black_queenside = Move::new(E8, C8, None); // e8c8
        assert!(black_queenside.is_queenside_castle());
        assert!(!black_queenside.is_kingside_castle());
        assert!(black_queenside.is_castle());

        assert!(!normal_move.is_castle());
    }
}
]]>
</content>
</file>

<file path="src/tuning/data_loader.rs" tokens="2841" focus="false">
<reason>Hybrid Retrieval</reason>
<content>
<![CDATA[
//! Data loading utilities for Texel tuning

use super::*;
use std::fs::File;
use std::io::{BufRead, BufReader, Write};
use std::path::Path;

pub struct DataLoader;

impl DataLoader {
    /// Load positions from a simple format: FEN,result,description
    pub fn load_from_csv<P: AsRef<Path>>(path: P) -> Result<Vec<TexelPosition>, Box<dyn std::error::Error>> {
        let file = File::open(path)?;
        let reader = BufReader::new(file);
        let mut positions = Vec::new();
        
        for (line_num, line) in reader.lines().enumerate() {
            let line = line?;
            if line.trim().is_empty() || line.starts_with('#') {
                continue; // Skip empty lines and comments
            }
            
            let parts: Vec<&str> = line.split(',').collect();
            if parts.len() >= 2 {
                let fen = parts[0].trim();
                let result_str = parts[1].trim();
                let description = if parts.len() > 2 {
                    parts[2].trim().to_string()
                } else {
                    format!("Position {}", line_num + 1)
                };
                
                // Parse result (can be numeric 0.0/0.5/1.0 or PGN format 1-0/1/2-1/2/0-1)
                let result = if let Ok(numeric_result) = result_str.parse::<f64>() {
                    numeric_result
                } else {
                    match result_str {
                        "1-0" => 1.0,
                        "0-1" => 0.0,
                        "1/2-1/2" => 0.5,
                        _ => {
                            eprintln!("Warning: Unknown result format '{}' on line {}", result_str, line_num + 1);
                            continue;
                        }
                    }
                };
                
                if let Some(position) = TexelPosition::new(fen, result, description) {
                    positions.push(position);
                } else {
                    eprintln!("Warning: Invalid FEN '{}' on line {}", fen, line_num + 1);
                }
            }
        }
        
        println!(" Loaded {} positions from file", positions.len());
        Ok(positions)
    }
    
    /// Load positions from EPD format (Extended Position Description)
    pub fn load_from_epd<P: AsRef<Path>>(path: P) -> Result<Vec<TexelPosition>, Box<dyn std::error::Error>> {
        let file = File::open(path)?;
        let reader = BufReader::new(file);
        let mut positions = Vec::new();
        
        for (line_num, line) in reader.lines().enumerate() {
            let line = line?;
            if line.trim().is_empty() || line.starts_with('#') {
                continue;
            }
            
            // EPD format: FEN + additional operations
            // Example: "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - c0 \"Starting position\"; result \"1/2-1/2\";"
            
            let parts: Vec<&str> = line.splitn(2, ';').collect();
            let fen_part = parts[0].trim();
            
            // Extract FEN (first 4-6 components)
            let fen_components: Vec<&str> = fen_part.split_whitespace().collect();
            if fen_components.len() >= 4 {
                let fen = fen_components[0..6.min(fen_components.len())].join(" ");
                
                // Look for result in operations
                let mut result = 0.5; // Default to draw
                let mut description = format!("EPD Position {}", line_num + 1);
                
                if parts.len() > 1 {
                    let operations = parts[1];
                    
                    // Parse result operation
                    if let Some(result_start) = operations.find("result") {
                        if let Some(quote_start) = operations[result_start..].find('"') {
                            if let Some(quote_end) = operations[result_start + quote_start + 1..].find('"') {
                                let result_str = &operations[result_start + quote_start + 1..result_start + quote_start + 1 + quote_end];
                                result = match result_str {
                                    "1-0" => 1.0,
                                    "0-1" => 0.0, 
                                    "1/2-1/2" => 0.5,
                                    _ => 0.5,
                                };
                            }
                        }
                    }
                    
                    // Parse description/comment
                    if let Some(desc_start) = operations.find("c0") {
                        if let Some(quote_start) = operations[desc_start..].find('"') {
                            if let Some(quote_end) = operations[desc_start + quote_start + 1..].find('"') {
                                description = operations[desc_start + quote_start + 1..desc_start + quote_start + 1 + quote_end].to_string();
                            }
                        }
                    }
                }
                
                if let Some(position) = TexelPosition::new(&fen, result, description) {
                    positions.push(position);
                }
            }
        }
        
        println!(" Loaded {} positions from EPD file", positions.len());
        Ok(positions)
    }
    
    /// Generate synthetic training data based on common chess patterns
    pub fn generate_synthetic_data(num_positions: usize) -> Vec<TexelPosition> {
        use rand::seq::SliceRandom;
        let mut rng = rand::thread_rng();
        let mut positions = Vec::new();
        
        // Generate various types of positions
        for i in 0..num_positions {
            let position_type = i % 4;
            
            let (fen, result, description) = match position_type {
                0 => {
                    // Endgame positions (clearer evaluations)
                    let endgames = [
                        ("8/8/8/4k3/4P3/4K3/8/8 w - - 0 1", 0.8, "KP vs K"),
                        ("8/8/8/8/8/4k3/4p3/4K3 b - - 0 1", 0.2, "KP vs K (Black)"),
                        ("8/8/8/8/4k3/8/4P3/4K3 w - - 0 1", 0.9, "Advanced Pawn"),
                        ("8/8/8/3k4/8/3K4/8/8 w - - 0 1", 0.5, "K vs K Draw"),
                    ];
                    let &(fen, result, desc) = endgames.choose(&mut rng).unwrap();
                    (fen.to_string(), result, desc.to_string())
                },
                1 => {
                    // Opening positions (roughly equal)
                    let openings = [
                        ("rnbqkbnr/pppppppp/8/8/4P3/8/PPPP1PPP/RNBQKBNR b KQkq e3 0 1", 0.55, "e4"),
                        ("rnbqkbnr/pppp1ppp/8/4p3/4P3/8/PPPP1PPP/RNBQKBNR w KQkq e6 0 2", 0.5, "e4 e5"),
                        ("rnbqkbnr/ppp1pppp/8/3p4/2PP4/8/PP2PPPP/RNBQKBNR b KQkq c3 0 2", 0.45, "d4 d5 c4"),
                    ];
                    let &(fen, result, desc) = openings.choose(&mut rng).unwrap();
                    (fen.to_string(), result, desc.to_string())
                },
                2 => {
                    // Tactical positions (clear advantage)
                    let tactical = [
                        ("r1bqkb1r/pppp1Qpp/2n2n2/4p3/2B1P3/8/PPPP1PPP/RNB1K1NR b KQkq - 0 4", 0.0, "Scholar's Mate"),
                        ("6k1/5ppp/8/8/8/8/8/4R2K w - - 0 1", 1.0, "Back Rank Mate"),
                        ("rnb1kbnr/pppp1ppp/8/4p3/5PPq/8/PPPPP2P/RNBQKBNR w KQkq - 1 3", 0.0, "Early Queen Attack"),
                    ];
                    let &(fen, result, desc) = tactical.choose(&mut rng).unwrap();
                    (fen.to_string(), result, desc.to_string())
                },
                _ => {
                    // Middlegame positions (varied evaluations)
                    let middlegame = [
                        ("r1bqk2r/pppp1ppp/2n2n2/2b1p3/2B1P3/3P1N2/PPP2PPP/RNBQK2R w KQkq - 0 5", 0.5, "Italian Game"),
                        ("rnbqkb1r/ppp2ppp/4pn2/3p4/2PP4/5N2/PP2PPPP/RNBQKB1R w KQkq - 0 4", 0.45, "QGD"),
                        ("r1bqkbnr/pppp1ppp/2n5/4p3/4P3/5N2/PPPP1PPP/RNBQKB1R w KQkq - 2 3", 0.55, "Knight Development"),
                    ];
                    let &(fen, result, desc) = middlegame.choose(&mut rng).unwrap();
                    (fen.to_string(), result, desc.to_string())
                }
            };
            
            if let Some(position) = TexelPosition::new(&fen, result, format!("{} ({})", description, i)) {
                positions.push(position);
            }
        }
        
        println!(" Generated {} synthetic positions", positions.len());
        positions
    }
    
    /// Save positions to CSV format for later use
    pub fn save_to_csv<P: AsRef<Path>>(positions: &[TexelPosition], path: P) -> Result<(), Box<dyn std::error::Error>> {
        let mut file = File::create(path)?;
        
        writeln!(file, "# FEN,Result,Description")?;
        for position in positions {
            // Note: Board doesn't have to_fen() method, would need to implement or skip this feature
            writeln!(file, "[FEN_NOT_IMPLEMENTED],{},\"{}\"", 
                    position.game_result,
                    position.description)?;
        }
        
        println!(" Saved {} positions to file", positions.len());
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::io::Write;
    use tempfile::NamedTempFile;
    
    #[test]
    fn test_synthetic_data_generation() {
        let positions = DataLoader::generate_synthetic_data(10);
        assert_eq!(positions.len(), 10);
        
        // Check that we have variety in results
        let results: Vec<f64> = positions.iter().map(|p| p.game_result).collect();
        let mut unique_results: Vec<f64> = Vec::new();
        for &result in &results {
            if !unique_results.iter().any(|&x: &f64| (x - result).abs() < 0.001) {
                unique_results.push(result);
            }
        }
        assert!(unique_results.len() > 1, "Should have variety in game results");
    }
    
    #[test] 
    fn test_csv_loading() -> Result<(), Box<dyn std::error::Error>> {
        let mut temp_file = NamedTempFile::new()?;
        
        // Write test data
        writeln!(temp_file, "# Test CSV file")?;
        writeln!(temp_file, "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1,0.5,Starting position")?;
        writeln!(temp_file, "6k1/5ppp/8/8/8/8/8/4R2K w - - 0 1,1.0,Back rank mate")?;
        writeln!(temp_file, "8/8/8/4k3/4P3/4K3/8/8 w - - 0 1,1-0,KP vs K")?;
        
        let positions = DataLoader::load_from_csv(temp_file.path())?;
        
        assert_eq!(positions.len(), 3);
        assert_eq!(positions[0].game_result, 0.5);
        assert_eq!(positions[1].game_result, 1.0);
        assert_eq!(positions[2].game_result, 1.0); // 1-0 should convert to 1.0
        
        Ok(())
    }
}]]>
</content>
</file>

<file path="STREAM_OF_CONSCIOUSNESS_LOGGER.md" tokens="934" focus="false">
<reason>Semantic Match</reason>
<content>
<![CDATA[
# Caissawary Stream of Consciousness Logger

The **Stream of Consciousness Logger** is a real-time narration system for Caissawary's search process. It provides a human-readable "thought process" of the engine as it navigates the search tree, explaining why specific moves are prioritized and how different tiers of the hybrid search architecture interact.

##  Purpose

- **Explainable Search:** Understand the "why" behind the engine's move choices.
- **Debugging Tier Transitions:** Verify that Tier 1 gates and Tier 2 grafts are firing correctly in sharp positions.
- **Educational Tool:** Learn how MCTS and PUCT selection work through real-time examples.
- **Performance Analysis:** Identify where the engine is spending time (e.g., mate search vs. neural inference).

##  Verbosity Levels

The logger supports five hierarchical verbosity levels:

| Level | Description | Key Events Logged |
|-------|-------------|-------------------|
| **Silent (0)** | No output | None |
| **Minimal (1)** | Crucial events only | Tier 1 Gate triggers, Search completion, 100-iteration summaries |
| **Normal (2)** | Standard narration | Tier 2 Grafts, Tier 3 NN values, Tactical move counts, 50-iteration summaries |
| **Verbose (3)** | Detailed trace | Mate search starts, QS PVs, Selection decisions (UCB components), Policy priors |
| **Debug (4)** | Full internal state | Iteration starts, Node entry/exit, Backpropagation, Raw state dumps |

##  The `verbose_search` Tool

Caissawary includes a dedicated CLI tool to run searches with the logger enabled.

### Basic Usage
```bash
cargo run --release --bin verbose_search -- "FEN_STRING" [options]
```

### Options
- `--verbosity <level>`: Set output level (`silent`, `minimal`, `normal`, `verbose`, `debug`). Defaults to `normal`.
- `--iterations <n>`: Number of MCTS iterations to run. Defaults to 200.
- `--no-emoji`: Disable emoji icons in the output for better compatibility with some terminals.

### Example: Analyzing a Mate-in-1
```bash
cargo run --release --bin verbose_search -- "4r1k1/8/8/8/8/8/5PPP/6K1 b - - 0 1" --verbosity verbose
```

**Example Output:**
```
 Verbose MCTS Search
======================
FEN: 4r1k1/8/8/8/8/8/5PPP/6K1 b - - 0 1
Verbosity: Verbose
Iterations: 200

--- Search begins ---

   0.0ms  Starting mate search at depth 5
   0.3ms  Mate search: MATE FOUND: e8e1 (score: 1000001)
   0.3ms  TIER 1 GATE: Mate in 5 found (winning)  e8e1

   0.3ms  Search complete!
   Best move: e8e1
   Iterations: 0
   Nodes expanded: 0
   Mates found: 1

--- Search complete ---
 Best Move: e8e1
```

##  Technical Implementation

### Thread-Safe Design
The logger is designed to be shared across threads using `Arc<SearchLogger>`. It uses internal mutability with `Mutex` and `Atomic` types to ensure that logging from different search threads (if enabled) or asynchronous inference callbacks is safe and consistent.

### Output Sinks
The system supports multiple output destinations:
- **Console:** Direct output to stdout.
- **File:** Log search traces to a specific file for later analysis.
- **Buffer:** Accumulate logs in memory (primarily used for unit testing).
- **Multi:** Broadcast logs to multiple sinks simultaneously.

### Performance Conscious
When logging is disabled or set to a lower verbosity than a specific message, the logger uses short-circuit checks to prevent expensive string formatting or I/O operations, ensuring minimal impact on search speed during standard play.

##  Testing the Logger
You can run the dedicated test suite to verify logger behavior and verbosity filtering:
```bash
cargo test --test unit_tests search_logger
```
]]>
</content>
</file>

<file path="src/uci.rs" tokens="5278" focus="false">
<reason>Semantic Match</reason>
<content>
<![CDATA[
//! UCI interface module for the chess engine
//!
//! This module implements the UCI interface for the chess engine. It allows the user to interact with the engine using UCI commands.

use crate::agent::{Agent, HumanlikeAgent, SimpleAgent}; // Import agents and trait
use crate::boardstack::BoardStack;
use crate::egtb::EgtbProber; // Import EGTB Prober
use crate::eval::PestoEval;
use crate::move_generation::MoveGen;
use lazy_static::lazy_static;
use crate::move_types::Move;
// Removed unused search imports, agent will handle search
// use crate::search::iterative_deepening_ab_search;
// use crate::transposition::TranspositionTable;
use std::io::{self, BufRead, Write};
use std::time::{Duration, Instant};

// Static instances to avoid lifetime issues
lazy_static! {
    static ref GLOBAL_MOVE_GEN: MoveGen = MoveGen::new();
    static ref GLOBAL_PESTO_EVAL: PestoEval = PestoEval::new();
}

pub struct UCIEngine {
    board: BoardStack,
    move_gen: MoveGen,
    pesto: PestoEval, // Keep pesto for agent creation
    egtb_prober: Option<EgtbProber>, // Add EGTB prober
    time_left: Duration,
    increment: Duration,
    moves_to_go: Option<u32>,
    depth: Option<i32>, // UCI depth limit (may or may not be used by agent)
    nodes: Option<u64>, // UCI node limit (may or may not be used by agent)
    mate: Option<i32>,  // UCI mate search depth (may or may not be used by agent)
    movetime: Option<Duration>, // UCI move time limit
    agent_type: String,
    agent: Box<dyn Agent + 'static>, // Store the selected agent

    // Agent configuration (using defaults for now, UCI options needed later)
    mate_search_depth: i32,
    ab_search_depth: i32,
    q_search_max_depth: i32,
    mcts_iterations: u32,
    mcts_time_limit_ms: u64,
    // placeholder_ab_depth: i32, // Included in HumanlikeAgent::new
    // placeholder_q_depth: i32, // Included in HumanlikeAgent::new
}

impl UCIEngine {
    pub fn new() -> Self {
        let move_gen = MoveGen::new();
        let pesto = PestoEval::new();
        // Initialize EGTB prober - requires path, set to None for now
        // TODO: Add UCI option for EGTB path
        let egtb_prober: Option<EgtbProber> = None;
        // match EgtbProber::load("/path/to/egtb") {
        //     Ok(prober) => Some(prober),
        //     Err(e) => {
        //         println!("info string Failed to load EGTB: {}", e);
        //         None
        //     }
        // };

        let agent_type = "Humanlike".to_string(); // Default agent type

        // Default configurations
        let mate_search_depth = 4; // Example default
        let ab_search_depth = 6;   // Example default
        let q_search_max_depth = 4; // Example default
        let mcts_iterations = 10000; // Example default
        let mcts_time_limit_ms = 5000; // Example default

        let mut engine = UCIEngine {
            board: BoardStack::new(),
            move_gen, // Store initialized move_gen
            pesto,    // Store initialized pesto
            egtb_prober, // Store initialized egtb_prober
            time_left: Duration::from_secs(0),
            increment: Duration::from_secs(0),
            moves_to_go: None,
            depth: None,
            nodes: None,
            mate: None,
            movetime: None,
            agent_type, // Store default agent type string
            // Placeholder agent, will be replaced by update_agent
            agent: Box::new(SimpleAgent::new(0, 0, 0, false, &*GLOBAL_MOVE_GEN, &*GLOBAL_PESTO_EVAL)), // Temporary dummy
            mate_search_depth,
            ab_search_depth,
            q_search_max_depth,
            mcts_iterations,
            mcts_time_limit_ms,
        };
        engine.update_agent(); // Create the actual agent based on agent_type
        engine
    }

    /// Creates and updates the `agent` field based on the current `agent_type`.
    fn update_agent(&mut self) {
        // Use static instances to avoid lifetime issues
        let temp_egtb_prober = self.egtb_prober.clone();

        let agent: Box<dyn Agent + 'static> = match self.agent_type.as_str() {
            "AlphaBeta" => Box::new(SimpleAgent::new(
                self.mate_search_depth,
                self.ab_search_depth,
                self.q_search_max_depth,
                false, // verbose - could be another UCI option
                &*GLOBAL_MOVE_GEN, // Use static instance
                &*GLOBAL_PESTO_EVAL,    // Use static instance
            )),
            "Humanlike" | _ => {
                // Default to Humanlike if type is unknown
                if self.agent_type != "Humanlike" {
                    println!(
                        "info string Unknown AgentType '{}', defaulting to Humanlike",
                        self.agent_type
                    );
                    self.agent_type = "Humanlike".to_string(); // Correct the stored type
                }
                Box::new(HumanlikeAgent::new(
                    &*GLOBAL_MOVE_GEN, // Use static instance
                    &*GLOBAL_PESTO_EVAL,    // Use static instance
                    temp_egtb_prober, // Use cloned Option<EgtbProber>
                    self.mate_search_depth,
                    self.mcts_iterations,
                    self.mcts_time_limit_ms,
                    self.ab_search_depth, // Using ab_search_depth for placeholder
                    self.q_search_max_depth, // Using q_search_max_depth for placeholder
                ))
            }
        };
        self.agent = agent; // Assign the newly created agent
        println!("info string Agent set to {}", self.agent_type); // Debug info
    }


    pub fn run(&mut self) {
        let stdin = io::stdin();
        for line in stdin.lock().lines() {
            let input = line.unwrap();
            let tokens: Vec<&str> = input.split_whitespace().collect();

            if tokens.is_empty() {
                continue;
            }

            match tokens[0] {
                "uci" => {
                    println!("id name Caissawary");
                    println!("id author Adam Holmes");
                    // Define the AgentType option
                    println!("option name AgentType type combo default Humanlike var AlphaBeta var Humanlike");
                    println!("uciok");
                }
                "isready" => println!("readyok"),
                "ucinewgame" => self.handle_ucinewgame(), // Changed to handle potential agent re-init
                "position" => self.handle_position(&tokens[1..]),
                "setoption" => self.handle_setoption(&tokens[1..]), // Added handler for setoption
                "go" => self.handle_go(&tokens[1..]),
                "debug" => {
                    if tokens.len() >= 2 && tokens[1] == "viz" {
                        let filename = if tokens.len() >= 3 { tokens[2] } else { "debug.dot" };
                        if let Some(root) = self.agent.get_last_search_tree() {
                            let dot = root.borrow().export_dot(10, 0);
                            match std::fs::write(filename, dot) {
                                Ok(_) => println!("info string Tree dumped to {}. Use xdot or edotor.net to view.", filename),
                                Err(e) => println!("info string Failed to write viz file: {}", e),
                            }
                        } else {
                            println!("info string No search tree available. Run a search first!");
                        }
                    }
                }
                "quit" => break,
                _ => println!("Unknown command: {}", tokens[0]),
            }

            io::stdout().flush().unwrap();
        }
    }

    fn handle_position(&mut self, args: &[&str]) {
        if args.is_empty() {
            return;
        }

        if args[0] == "startpos" {
            self.board = BoardStack::new();
            let moves_idx = 2;

            if args.len() > 1 && args[1] == "moves" {
                for move_str in &args[moves_idx..] {
                    if let Some(chess_move) = Move::from_uci(move_str) {
                        self.board.make_move(chess_move);
                    }
                }
            }
        } else if args[0] == "fen" {
            // Find the index where "moves" starts, if present
            let moves_idx = args
                .iter()
                .position(|&x| x == "moves")
                .unwrap_or(args.len());

            // Join the FEN parts
            let fen = args[1..moves_idx].join(" ");

            // Create a new board from the FEN
            self.board = BoardStack::new_from_fen(&fen);

            // Apply moves if present
            if moves_idx < args.len() {
                for move_str in &args[moves_idx + 1..] {
                    if let Some(chess_move) = Move::from_uci(move_str) {
                        self.board.make_move(chess_move);
                    }
                }
            }
        } else {
            println!("info string Invalid position command");
        }
    }

    fn handle_go(&mut self, args: &[&str]) {
        self.parse_go_command(args); // Parses time controls, depth, nodes etc. into self

        // Note: The current Agent trait doesn't pass time controls.
        // The agents use their internal logic or fixed depths/iterations for now.
        // TODO: Enhance Agent trait or agent implementations to use UCI time controls.
        let _allocated_time = self.calculate_allocated_time(); // Calculate but not used directly by agent.get_move yet
        let start_time = Instant::now();

        // Get the move from the currently selected agent
        // The agent's get_move implementation handles the search (AB, MCTS, etc.)
        // We pass a mutable reference to the board stack.
        let best_move = self.agent.get_move(&mut self.board);

        let elapsed = start_time.elapsed();

        // Print info - We don't get depth, score, nodes back from the generic agent easily.
        // We could modify the Agent trait to return this info, or have agents print UCI info internally.
        // For now, just print the best move and time.
        // Agents might print their own info during search.
        println!(
            "info time {}", // Basic info from UCI loop
            elapsed.as_millis()
            // Example if agent printed info: info depth 10 score cp 150 nodes 12345 time 1500 pv e2e4 e7e5 ...
        );

        println!("bestmove {}", &best_move.print_algebraic());
    }

    fn parse_go_command(&mut self, args: &[&str]) {
        self.time_left = Duration::from_secs(0);
        self.increment = Duration::from_secs(0);
        self.moves_to_go = None;
        self.depth = None;
        self.nodes = None;
        self.mate = None;
        self.movetime = None;

        let mut i = 0;
        while i < args.len() {
            match args[i] {
                "wtime" | "btime" => {
                    if (args[i] == "wtime" && self.board.current_state().w_to_move)
                        || (args[i] == "btime" && !self.board.current_state().w_to_move)
                    {
                        self.time_left = Duration::from_millis(args[i + 1].parse().unwrap_or(0));
                    }
                    i += 2;
                }
                "winc" | "binc" => {
                    if (args[i] == "winc" && self.board.current_state().w_to_move)
                        || (args[i] == "binc" && !self.board.current_state().w_to_move)
                    {
                        self.increment = Duration::from_millis(args[i + 1].parse().unwrap_or(0));
                    }
                    i += 2;
                }
                "movestogo" => {
                    self.moves_to_go = Some(args[i + 1].parse().unwrap_or(30));
                    i += 2;
                }
                "depth" => {
                    self.depth = Some(args[i + 1].parse().unwrap_or(100));
                    i += 2;
                }
                "nodes" => {
                    self.nodes = Some(args[i + 1].parse().unwrap_or(0));
                    i += 2;
                }
                "mate" => {
                    self.mate = Some(args[i + 1].parse().unwrap_or(0));
                    i += 2;
                }
                "movetime" => {
                    self.movetime = Some(Duration::from_millis(args[i + 1].parse().unwrap_or(0)));
                    i += 2;
                }
                _ => i += 1,
            }
        }
    }
    
    // Renamed from direct assignment in the match arm to potentially handle agent re-initialization
    fn handle_ucinewgame(&mut self) {
            self.board = BoardStack::new();
            // Potentially re-initialize agent state here if needed based on self.agent_type
        }
    
    fn handle_setoption(&mut self, args: &[&str]) {
            if args.len() >= 4 && args[0] == "name" && args[2] == "value" {
                let name = args[1];
                let value = args[3];
                match name {
                    "AgentType" => {
                        if value == "AlphaBeta" || value == "Humanlike" {
                            if self.agent_type != value { // Only update if changed
                                self.agent_type = value.to_string();
                                self.update_agent(); // Re-create the agent instance
                            }
                        } else {
                            println!("info string Invalid value for AgentType: {}", value);
                        }
                    }
                    "ModelPath" => {
                        // This would need to be passed to the agent.
                        // For now, let's just log it, as we need to thread this path 
                        // through update_agent -> HumanlikeAgent -> NeuralNetPolicy
                        println!("info string Setting ModelPath to {} (Not fully wired yet)", value);
                        // TODO: Store this path in UCIEngine struct and pass to HumanlikeAgent::new
                    }
                    _ => {
                        // println!("info string Unknown option: {}", name);
                    }
                }
            } else {
                println!("info string Invalid setoption command format");
            }
        }

    /// This function calculates the allocated time for a chess move based on the time control settings.
    ///
    /// Formula: time left per move until time control is reached (or 5% of time left if no time
    /// control is specified) + 50% of increment
    /// Defaults to 5 seconds if no time control is specified.
    fn calculate_allocated_time(&self) -> Duration {
        if let Some(movetime) = self.movetime {
            return movetime;
        }

        if self.time_left.as_millis() == 0 {
            return Duration::from_secs(5); // Default to 5 seconds if no time control is specified
        }

        let moves_left = self.moves_to_go.unwrap_or(20) as f32;
        let base_time = self.time_left.as_secs_f32() / moves_left;
        let bonus_time = self.increment.as_secs_f32();

        Duration::from_secs_f32(base_time + bonus_time * 0.5)
    }

    // Make internal handlers public for testing

    #[cfg(test)]
    pub fn get_board(&self) -> &BoardStack {
        &self.board
    }

    #[cfg(test)]
    pub fn get_agent_type(&self) -> &str {
        &self.agent_type
    }

    #[cfg(test)]
    pub fn get_time_limits(&self) -> (Duration, Duration, Option<Duration>) {
        (self.time_left, self.increment, self.movetime)
    }

    #[cfg(test)]
    pub fn get_search_limits(&self) -> (Option<i32>, Option<u64>, Option<i32>) {
        (self.depth, self.nodes, self.mate)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::board::Board; // Assuming Board is needed for state checks

    #[test]
    fn test_handle_position_startpos() {
        let mut engine = UCIEngine::new();
        engine.handle_position(&["startpos"]);
        // Check if the board is in the initial state
        assert_eq!(engine.get_board().current_state().to_fen(), Some("rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1".to_string()));
    }

    #[test]
    fn test_handle_position_startpos_moves() {
        let mut engine = UCIEngine::new();
        engine.handle_position(&["startpos", "moves", "e2e4", "e7e5"]);
        // Check if the board is in the correct state after moves
        assert_eq!(engine.get_board().current_state().to_fen(), Some("rnbqkbnr/pppp1ppp/8/4p3/4P3/8/PPPP1PPP/RNBQKBNR w KQkq e6 0 2".to_string()));
    }

    #[test]
    fn test_handle_position_fen() {
        let mut engine = UCIEngine::new();
        let fen = "r3k2r/p1ppqpbp/bnNppnp1/8/4P3/2N2Q2/PPP2PPP/R3K2R w KQkq - 0 1";
        engine.handle_position(&["fen", "r3k2r/p1ppqpbp/bnNppnp1/8/4P3/2N2Q2/PPP2PPP/R3K2R", "w", "KkQq", "-", "0", "1"]);
        // Check if the board is in the state specified by the FEN
        assert_eq!(engine.get_board().current_state().to_fen(), Some(fen.to_string()));
    }

    #[test]
    fn test_handle_position_fen_moves() {
        let mut engine = UCIEngine::new();
        let fen = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1";
        engine.handle_position(&["fen", fen, "moves", "e2e4", "e7e5", "g1f3"]);
        // Check if the board is in the correct state after FEN and moves
        assert_eq!(engine.get_board().current_state().to_fen(), Some("rnbqkbnr/pppp1ppp/8/4p3/4P3/5N2/PPPP1PPP/RNBQKB1R b KQkq - 1 2".to_string()));
    }

    #[test]
    fn test_parse_go_movetime() {
        let mut engine = UCIEngine::new();
        engine.parse_go_command(&["go", "movetime", "1000"]);
        let (time_left, increment, movetime) = engine.get_time_limits();
        assert_eq!(movetime, Some(Duration::from_millis(1000)));
        assert_eq!(time_left, Duration::from_secs(0));
        assert_eq!(increment, Duration::from_secs(0));
    }

    #[test]
    fn test_parse_go_wtime_btime_winc_binc() {
        let mut engine = UCIEngine::new();
        // Test for white to move
        engine.handle_position(&["startpos"]); // White to move
        engine.parse_go_command(&["go", "wtime", "60000", "btime", "50000", "winc", "1000", "binc", "500"]);
        let (time_left, increment, movetime) = engine.get_time_limits();
        assert_eq!(time_left, Duration::from_millis(60000));
        assert_eq!(increment, Duration::from_millis(1000));
        assert_eq!(movetime, None);

        // Test for black to move
        engine.handle_position(&["startpos", "moves", "e2e4"]); // Black to move
        engine.parse_go_command(&["go", "wtime", "59000", "btime", "49000", "winc", "1000", "binc", "500"]);
        let (time_left, increment, movetime) = engine.get_time_limits();
        assert_eq!(time_left, Duration::from_millis(49000));
        assert_eq!(increment, Duration::from_millis(500));
        assert_eq!(movetime, None);
    }

    #[test]
    fn test_parse_go_depth() {
        let mut engine = UCIEngine::new();
        engine.parse_go_command(&["go", "depth", "10"]);
        let (depth, nodes, mate) = engine.get_search_limits();
        assert_eq!(depth, Some(10));
        assert_eq!(nodes, None);
        assert_eq!(mate, None);
    }

    #[test]
    fn test_parse_go_nodes() {
        let mut engine = UCIEngine::new();
        engine.parse_go_command(&["go", "nodes", "100000"]);
        let (depth, nodes, mate) = engine.get_search_limits();
        assert_eq!(depth, None);
        assert_eq!(nodes, Some(100000));
        assert_eq!(mate, None);
    }

    #[test]
    fn test_parse_go_mate() {
        let mut engine = UCIEngine::new();
        engine.parse_go_command(&["go", "mate", "5"]);
        let (depth, nodes, mate) = engine.get_search_limits();
        assert_eq!(depth, None);
        assert_eq!(nodes, None);
        assert_eq!(mate, Some(5));
    }

    #[test]
    fn test_parse_go_infinite() {
        let mut engine = UCIEngine::new();
        engine.parse_go_command(&["go", "infinite"]);
        let (time_left, increment, movetime) = engine.get_time_limits();
        assert_eq!(time_left, Duration::from_secs(0));
        assert_eq!(increment, Duration::from_secs(0));
        assert_eq!(movetime, None); // infinite doesn't set movetime
        let (depth, nodes, mate) = engine.get_search_limits();
        assert_eq!(depth, None);
        assert_eq!(nodes, None);
        assert_eq!(mate, None);
    }

    #[test]
    fn test_handle_setoption_agenttype() {
        let mut engine = UCIEngine::new();
        // Default is Humanlike
        assert_eq!(engine.get_agent_type(), "Humanlike");

        // Set to AlphaBeta
        engine.handle_setoption(&["name", "AgentType", "value", "AlphaBeta"]);
        assert_eq!(engine.get_agent_type(), "AlphaBeta");

        // Set back to Humanlike
        engine.handle_setoption(&["name", "AgentType", "value", "Humanlike"]);
        assert_eq!(engine.get_agent_type(), "Humanlike");

        // Try setting an invalid value (should remain Humanlike)
        engine.handle_setoption(&["name", "AgentType", "value", "InvalidAgent"]);
        assert_eq!(engine.get_agent_type(), "Humanlike");
    }

    #[test]
    fn test_handle_setoption_unknown() {
        let mut engine = UCIEngine::new();
        // Setting an unknown option should not change the agent type
        engine.handle_setoption(&["name", "UnknownOption", "value", "SomeValue"]);
        assert_eq!(engine.get_agent_type(), "Humanlike"); // Default agent type should remain
    }

    #[test]
    fn test_handle_setoption_invalid_format() {
        let mut engine = UCIEngine::new();
        // Invalid format should not change the agent type
        engine.handle_setoption(&["name", "AgentType", "InvalidValue"]);
        assert_eq!(engine.get_agent_type(), "Humanlike"); // Default agent type should remain

        engine.handle_setoption(&["AgentType", "value", "Humanlike"]);
        assert_eq!(engine.get_agent_type(), "Humanlike"); // Default agent type should remain
    }
}
]]>
</content>
</file>

<file path="src/agent.rs" tokens="1187" focus="false">
<reason>Semantic Match</reason>
<content>
<![CDATA[
//! This module specifies various agents, which can use any combination of search and eval routines.

use crate::boardstack::BoardStack;
use crate::eval::PestoEval;
use crate::move_generation::MoveGen;
use crate::move_types::Move;
use crate::mcts::tactical_mcts::{tactical_mcts_search, TacticalMctsConfig};
use crate::mcts::node::MctsNode;
use crate::search::mate_search;
use crate::egtb::EgtbProber;
use std::cell::RefCell;
use std::rc::Rc;
use std::time::Duration;

// Test tracking flags (only compiled in test mode)
#[cfg(test)]
thread_local! {
    static MATE_SEARCH_CALLED: RefCell<bool> = RefCell::new(false);
    static MCTS_SEARCH_CALLED: RefCell<bool> = RefCell::new(false);
    static MATE_SEARCH_RETURN_VALUE: RefCell<(i32, Move, u64)> = RefCell::new((0, Move::null(), 0));
    static MCTS_SEARCH_RETURN_VALUE: RefCell<Option<Move>> = RefCell::new(None);
}

/// Trait defining the interface for chess agents.
pub trait Agent {
    /// Get the best move for the current board position.
    fn get_move(&mut self, board: &mut BoardStack) -> Move;

    /// Returns the root of the search tree from the last search, if applicable.
    fn get_last_search_tree(&self) -> Option<Rc<RefCell<MctsNode>>> {
        None
    }
}

/// A simple agent that uses mate search followed by aspiration window quiescence search.
pub struct SimpleAgent<'a> {
    pub mate_search_depth: i32,
    pub ab_search_depth: i32,
    pub q_search_max_depth: i32,
    pub verbose: bool,
    pub move_gen: &'a MoveGen,
    pub pesto: &'a PestoEval,
}

impl SimpleAgent<'_> {
    pub fn new<'a>(
        mate_search_depth: i32,
        ab_search_depth: i32,
        q_search_max_depth: i32,
        verbose: bool,
        move_gen: &'a MoveGen,
        pesto: &'a PestoEval,
    ) -> SimpleAgent<'a> {
        SimpleAgent {
            mate_search_depth,
            ab_search_depth,
            q_search_max_depth,
            verbose,
            move_gen,
            pesto,
        }
    }
}

/// An agent designed to mimic human-like decision making, using EGTB, Mate Search, and MCTS.
pub struct HumanlikeAgent<'a> {
    pub move_gen: &'a MoveGen,
    pub pesto: &'a PestoEval,
    pub egtb_prober: Option<EgtbProber>,
    pub mate_search_depth: i32,
    pub mcts_iterations: u32,
    pub mcts_time_limit_ms: u64,
    pub placeholder_ab_depth: i32,
    pub placeholder_q_depth: i32,
    /// Stores the root of the last MCTS search for inspection
    last_tree: RefCell<Option<Rc<RefCell<MctsNode>>>>,
}

impl HumanlikeAgent<'_> {
    pub fn new<'a>(
        move_gen: &'a MoveGen,
        pesto: &'a PestoEval,
        egtb_prober: Option<EgtbProber>,
        mate_search_depth: i32,
        mcts_iterations: u32,
        mcts_time_limit_ms: u64,
        placeholder_ab_depth: i32,
        placeholder_q_depth: i32,
    ) -> HumanlikeAgent<'a> {
        HumanlikeAgent {
            move_gen,
            pesto,
            egtb_prober,
            mate_search_depth,
            mcts_iterations,
            mcts_time_limit_ms,
            placeholder_ab_depth,
            placeholder_q_depth,
            last_tree: RefCell::new(None),
        }
    }
}

impl Agent for HumanlikeAgent<'_> {
    fn get_move(&mut self, board: &mut BoardStack) -> Move {
        // 1. Mate Search
        let (eval, m, _nodes) = mate_search(board, self.move_gen, self.mate_search_depth, false);

        if eval >= 1000000 {
            return m;
        }

        // 2. MCTS Search
        let config = TacticalMctsConfig {
            max_iterations: self.mcts_iterations,
            time_limit: Duration::from_millis(self.mcts_time_limit_ms),
            mate_search_depth: self.mate_search_depth,
            ..Default::default()
        };

        let mut nn = None; // Use default stub or could be loaded from UCIEngine
        let (mcts_move, _stats, root) = tactical_mcts_search(
            board.current_state().clone(),
            self.move_gen,
            self.pesto,
            &mut nn,
            config
        );

        // Store the tree for inspection
        *self.last_tree.borrow_mut() = Some(root);

        mcts_move.expect("MCTS search returned None unexpectedly")
    }

    fn get_last_search_tree(&self) -> Option<Rc<RefCell<MctsNode>>> {
        self.last_tree.borrow().clone()
    }
}

impl Agent for SimpleAgent<'_> {
    fn get_move(&mut self, board: &mut BoardStack) -> Move {
        let (eval, m, _nodes) = mate_search(board, self.move_gen, self.mate_search_depth, self.verbose);
        if eval >= 1000000 {
            return m;
        }
        // ... (AlphaBeta search omitted for brevity, keeping simple implementation)
        m
    }
}]]>
</content>
</file>

<file path="src/tuning/mod.rs" tokens="1225" focus="false">
<reason>Architecturally Significant</reason>
<content>
<![CDATA[
use crate::board::Board;

pub mod texel;
pub mod data_loader;

#[derive(Debug, Clone)]
pub struct TexelPosition {
    pub board: Board,
    pub game_result: f64, // 0.0 = loss, 0.5 = draw, 1.0 = win (from White's perspective)
    pub game_phase: f64,  // 0.0 = endgame, 1.0 = opening
    pub description: String,
}

impl TexelPosition {
    pub fn new(fen: &str, result: f64, description: String) -> Option<Self> {
        let board = Board::new_from_fen(fen);
        
        // Calculate game phase based on material
        let game_phase = calculate_game_phase(&board);
        
        Some(TexelPosition {
            board,
            game_result: result,
            game_phase,
            description,
        })
    }
    
    pub fn from_pgn_result(fen: &str, pgn_result: &str, description: String) -> Option<Self> {
        let result = match pgn_result {
            "1-0" => 1.0,   // White wins
            "0-1" => 0.0,   // Black wins  
            "1/2-1/2" => 0.5, // Draw
            _ => return None, // Unknown result
        };
        
        Self::new(fen, result, description)
    }
}

/// Calculate game phase based on piece values (0.0 = endgame, 1.0 = opening)
fn calculate_game_phase(board: &Board) -> f64 {
    use crate::piece_types::*;
    
    let mut total_material = 0;
    
    // Count material for both sides
    for color in [WHITE, BLACK] {
        total_material += board.get_piece_bitboard(color, QUEEN).count_ones() * 9;
        total_material += board.get_piece_bitboard(color, ROOK).count_ones() * 5;
        total_material += board.get_piece_bitboard(color, BISHOP).count_ones() * 3;
        total_material += board.get_piece_bitboard(color, KNIGHT).count_ones() * 3;
        total_material += board.get_piece_bitboard(color, PAWN).count_ones() * 1;
    }
    
    // Starting position has ~78 points of material (2*Q + 4*R + 4*B + 4*N + 16*P = 2*9 + 4*5 + 4*3 + 4*3 + 16*1 = 78)
    let max_material = 78.0;
    let phase = (total_material as f64 / max_material).min(1.0);
    
    phase
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_texel_position_creation() {
        let position = TexelPosition::new(
            "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1",
            0.5,
            "Starting position".to_string()
        );
        
        assert!(position.is_some());
        let pos = position.unwrap();
        assert_eq!(pos.game_result, 0.5);
        assert!(pos.game_phase > 0.9); // Should be near opening
    }
    
    #[test]
    fn test_game_phase_calculation() {
        // Starting position should be ~1.0 (opening)
        let start_board = Board::new_from_fen("rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1");
        let start_phase = calculate_game_phase(&start_board);
        assert!(start_phase > 0.9);
        
        // King and pawn endgame should be ~0.0 (endgame)
        let endgame_board = Board::new_from_fen("8/8/8/4k3/4P3/4K3/8/8 w - - 0 1");
        let endgame_phase = calculate_game_phase(&endgame_board);
        assert!(endgame_phase < 0.1);
    }
    
    #[test]
    fn test_pgn_result_parsing() {
        let pos = TexelPosition::from_pgn_result(
            "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1",
            "1-0",
            "Test".to_string()
        );
        assert!(pos.is_some());
        assert_eq!(pos.unwrap().game_result, 1.0);
        
        let pos = TexelPosition::from_pgn_result(
            "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1",
            "0-1", 
            "Test".to_string()
        );
        assert!(pos.is_some());
        assert_eq!(pos.unwrap().game_result, 0.0);
        
        let pos = TexelPosition::from_pgn_result(
            "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1",
            "1/2-1/2",
            "Test".to_string()
        );
        assert!(pos.is_some());
        assert_eq!(pos.unwrap().game_result, 0.5);
    }
}]]>
</content>
</file>

<file path="src/tuning/texel.rs" tokens="2902" focus="false">
<reason>Hybrid Retrieval</reason>
<content>
<![CDATA[
//! Texel tuning implementation for optimizing evaluation parameters

use super::*;
use crate::eval::{PestoEval, EvalWeights};
use crate::move_generation::MoveGen;
use std::f64;

pub struct TexelTuner {
    positions: Vec<TexelPosition>,
    current_weights: EvalWeights,
    best_weights: EvalWeights,
    learning_rate: f64,
    k_factor: f64, // Scaling factor for sigmoid function
    best_error: f64,
}

impl TexelTuner {
    pub fn new(positions: Vec<TexelPosition>, initial_weights: EvalWeights) -> Self {
        let best_error = f64::INFINITY;
        
        TexelTuner {
            positions,
            current_weights: initial_weights.clone(),
            best_weights: initial_weights,
            learning_rate: 0.1,
            k_factor: 400.0, // Standard chess evaluation scaling
            best_error,
        }
    }
    
    pub fn set_learning_rate(&mut self, lr: f64) {
        self.learning_rate = lr;
    }
    
    pub fn set_k_factor(&mut self, k: f64) {
        self.k_factor = k;
    }
    
    /// Calculate evaluation error using mean squared error
    pub fn calculate_error(&self, weights: &EvalWeights, move_gen: &MoveGen) -> f64 {
        let mut total_error = 0.0;
        let evaluator = PestoEval::with_weights(weights.clone());
        
        for position in &self.positions {
            // Get evaluation in centipawns
            let eval_cp = evaluator.eval(&position.board, move_gen);
            
            // Convert to win probability using sigmoid: 1 / (1 + exp(-eval/k))
            let eval_prob = sigmoid(eval_cp as f64, self.k_factor);
            
            // Calculate squared error
            let error = (eval_prob - position.game_result).powi(2);
            total_error += error;
        }
        
        total_error / self.positions.len() as f64
    }
    
    /// Perform one iteration of gradient descent
    pub fn optimize_iteration(&mut self, move_gen: &MoveGen) -> f64 {
        let current_error = self.calculate_error(&self.current_weights, move_gen);
        
        // Try small adjustments to each parameter
        let mut improved_weights = self.current_weights.clone();
        let mut best_iteration_error = current_error;
        
        // Optimize material values
        self.optimize_material_values(&mut improved_weights, &mut best_iteration_error, move_gen);
        
        // Optimize piece-square table values
        self.optimize_pst_values(&mut improved_weights, &mut best_iteration_error, move_gen);
        
        // Optimize positional bonuses
        self.optimize_positional_bonuses(&mut improved_weights, &mut best_iteration_error, move_gen);
        
        // Update weights if improvement found
        if best_iteration_error < self.best_error {
            self.best_error = best_iteration_error;
            self.best_weights = improved_weights.clone();
            self.current_weights = improved_weights;
            
            // Adaptive learning rate
            self.learning_rate = (self.learning_rate * 1.05).min(1.0);
        } else {
            // Reduce learning rate if no improvement
            self.learning_rate *= 0.95;
        }
        
        best_iteration_error
    }
    
    fn optimize_material_values(&self, weights: &mut EvalWeights, best_error: &mut f64, move_gen: &MoveGen) {
        // Skip optimizing piece values as they remain const in our structure
        // Focus on mobility weights instead which affect material evaluation
        
        // Optimize mobility weights for each piece type
        let deltas = [1, 1, 1, 1]; // Small adjustments for mobility
        
        for piece_idx in 0..4 { // N, B, R, Q
            let delta = deltas[piece_idx];
            
            // Try increasing MG mobility weight
            let original_mg = weights.mobility_weights_mg[piece_idx];
            let original_eg = weights.mobility_weights_eg[piece_idx];
            
            weights.mobility_weights_mg[piece_idx] += delta;
            
            let error = self.calculate_error(weights, move_gen);
            if error < *best_error {
                *best_error = error;
            } else {
                // Try decreasing instead
                weights.mobility_weights_mg[piece_idx] = original_mg - delta;
                
                let error = self.calculate_error(weights, move_gen);
                if error < *best_error {
                    *best_error = error;
                } else {
                    // Try EG mobility weight
                    weights.mobility_weights_mg[piece_idx] = original_mg;
                    weights.mobility_weights_eg[piece_idx] += delta;
                    
                    let error = self.calculate_error(weights, move_gen);
                    if error < *best_error {
                        *best_error = error;
                    } else {
                        // Revert
                        weights.mobility_weights_eg[piece_idx] = original_eg;
                    }
                }
            }
        }
    }
    
    fn optimize_pst_values(&self, _weights: &mut EvalWeights, _best_error: &mut f64, _move_gen: &MoveGen) {
        // Skip PST optimization as piece-square tables remain const
        // This function is kept for interface compatibility
        // Future implementations could optimize king attack zone weighting or similar
    }
    
    fn optimize_positional_bonuses(&self, weights: &mut EvalWeights, best_error: &mut f64, move_gen: &MoveGen) {
        // Optimize key positional evaluation weights
        
        // Two bishops bonus [mg, eg]
        let original = weights.two_bishops_bonus;
        for &delta in &[3, -3] {
            weights.two_bishops_bonus[0] = original[0] + delta; // MG
            weights.two_bishops_bonus[1] = original[1] + delta; // EG
            
            let error = self.calculate_error(weights, move_gen);
            if error < *best_error {
                *best_error = error;
                break;
            }
        }
        if self.calculate_error(weights, move_gen) >= *best_error {
            weights.two_bishops_bonus = original;
        }
        
        // King safety pawn shield bonus
        let original = weights.king_safety_pawn_shield_bonus;
        for &delta in &[2, -2] {
            weights.king_safety_pawn_shield_bonus[0] = original[0] + delta;
            weights.king_safety_pawn_shield_bonus[1] = original[1] + delta;
            
            let error = self.calculate_error(weights, move_gen);
            if error < *best_error {
                *best_error = error;
                break;
            }
        }
        if self.calculate_error(weights, move_gen) >= *best_error {
            weights.king_safety_pawn_shield_bonus = original;
        }
        
        // Rook open file bonus
        let original = weights.rook_open_file_bonus;
        for &delta in &[3, -3] {
            weights.rook_open_file_bonus[0] = original[0] + delta;
            weights.rook_open_file_bonus[1] = original[1] + delta;
            
            let error = self.calculate_error(weights, move_gen);
            if error < *best_error {
                *best_error = error;
                break;
            }
        }
        if self.calculate_error(weights, move_gen) >= *best_error {
            weights.rook_open_file_bonus = original;
        }
        
        // Isolated pawn penalty
        let original = weights.isolated_pawn_penalty;
        for &delta in &[2, -2] {
            weights.isolated_pawn_penalty[0] = original[0] + delta;
            weights.isolated_pawn_penalty[1] = original[1] + delta;
            
            let error = self.calculate_error(weights, move_gen);
            if error < *best_error {
                *best_error = error;
                break;
            }
        }
        if self.calculate_error(weights, move_gen) >= *best_error {
            weights.isolated_pawn_penalty = original;
        }
    }
    
    /// Run full optimization for specified iterations
    pub fn tune(&mut self, move_gen: &MoveGen, max_iterations: usize) -> EvalWeights {
        println!(" Starting Texel Tuning");
        println!("========================");
        println!("Positions: {}", self.positions.len());
        println!("Initial error: {:.6}", self.calculate_error(&self.current_weights, move_gen));
        
        for iteration in 0..max_iterations {
            let error = self.optimize_iteration(move_gen);
            
            if iteration % 10 == 0 {
                println!("Iteration {}: Error = {:.6}, LR = {:.4}", 
                        iteration, error, self.learning_rate);
            }
            
            // Early stopping if learning rate becomes too small
            if self.learning_rate < 0.001 {
                println!("Learning rate too small, stopping early");
                break;
            }
        }
        
        println!("\n Tuning Complete!");
        println!("Final error: {:.6}", self.best_error);
        println!("Improvement: {:.6}", 
                self.calculate_error(&EvalWeights::default(), move_gen) - self.best_error);
        
        self.best_weights.clone()
    }
    
    pub fn get_best_weights(&self) -> &EvalWeights {
        &self.best_weights
    }
}

/// Sigmoid function for converting evaluation to win probability
fn sigmoid(eval_cp: f64, k: f64) -> f64 {
    1.0 / (1.0 + (-eval_cp / k).exp())
}

/// Create a simple test dataset for tuning
pub fn create_test_dataset() -> Vec<TexelPosition> {
    vec![
        // Opening positions
        TexelPosition::new("rnbqkbnr/pppppppp/8/8/4P3/8/PPPP1PPP/RNBQKBNR b KQkq e3 0 1", 0.5, "King's Pawn Opening".to_string()).unwrap(),
        TexelPosition::new("rnbqkbnr/ppp1pppp/8/3p4/4P3/8/PPPP1PPP/RNBQKBNR w KQkq d6 0 2", 0.5, "Open Game".to_string()).unwrap(),
        
        // Middlegame positions
        TexelPosition::new("r1bqkb1r/pppp1ppp/2n2n2/1B2p3/4P3/5N2/PPPP1PPP/RNBQK2R w KQkq - 0 4", 0.6, "Italian Game".to_string()).unwrap(),
        TexelPosition::new("rnbqkb1r/ppp2ppp/4pn2/3p4/2PP4/5N2/PP2PPPP/RNBQKB1R w KQkq - 0 4", 0.4, "Queen's Gambit Declined".to_string()).unwrap(),
        
        // Endgame positions
        TexelPosition::new("8/8/8/4k3/4P3/4K3/8/8 w - - 0 1", 0.7, "King and Pawn vs King".to_string()).unwrap(),
        TexelPosition::new("8/8/8/8/8/4k3/4p3/4K3 b - - 0 1", 0.3, "King and Pawn vs King (Black)".to_string()).unwrap(),
        
        // Tactical positions
        TexelPosition::new("r1bqkb1r/pppp1Qpp/2n2n2/4p3/2B1P3/8/PPPP1PPP/RNB1K1NR b KQkq - 0 4", 0.0, "Scholar's Mate".to_string()).unwrap(),
        TexelPosition::new("rnb1kbnr/pppp1ppp/8/4p3/5PPq/8/PPPPP2P/RNBQKBNR w KQkq - 1 3", 1.0, "Lgal's Mate".to_string()).unwrap(),
    ]
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::move_generation::MoveGen;
    
    #[test]
    fn test_sigmoid_function() {
        assert!((sigmoid(0.0, 400.0) - 0.5).abs() < 0.001);
        assert!(sigmoid(400.0, 400.0) > 0.7);
        assert!(sigmoid(-400.0, 400.0) < 0.3);
    }
    
    #[test]
    fn test_texel_tuner_creation() {
        let positions = create_test_dataset();
        let weights = EvalWeights::default();
        let tuner = TexelTuner::new(positions, weights);
        
        assert!(tuner.positions.len() > 0);
        assert_eq!(tuner.learning_rate, 0.1);
    }
    
    #[test]
    fn test_error_calculation() {
        let positions = create_test_dataset();
        let weights = EvalWeights::default();
        let tuner = TexelTuner::new(positions, weights);
        let move_gen = MoveGen::new();
        
        let error = tuner.calculate_error(&tuner.current_weights, &move_gen);
        assert!(error >= 0.0);
        assert!(error <= 1.0); // MSE should be between 0 and 1
    }
}]]>
</content>
</file>

<file path="src/benchmarks/strength_testing.rs" tokens="5431" focus="false">
<reason>Hybrid Retrieval</reason>
<content>
<![CDATA[
//! Comprehensive Strength Testing and Comparisons
//!
//! This module provides extensive benchmarking to test the strength improvements
//! from our mate-search-first MCTS approach and neural network policy guidance.

use crate::board::Board;
use crate::eval::PestoEval;
use crate::move_generation::MoveGen;
use crate::move_types::Move;
// use crate::search::alpha_beta::AlphaBeta;
// use crate::mcts::mcts_search;
use crate::mcts::neural_mcts::neural_mcts_search;
use crate::neural_net::NeuralNetPolicy;
use std::collections::HashMap;
use std::time::{Duration, Instant};
use std::fmt;

/// Test suite configuration
#[derive(Debug, Clone)]
pub struct StrengthTestConfig {
    /// Time limit per position (milliseconds)
    pub time_limit_ms: u64,
    /// MCTS iterations limit
    pub mcts_iterations: u32,
    /// Alpha-beta search depth
    pub ab_depth: i32,
    /// Mate search depth for MCTS
    pub mate_search_depth: i32,
    /// Path to neural network model (optional)
    pub neural_model_path: Option<String>,
}

impl Default for StrengthTestConfig {
    fn default() -> Self {
        StrengthTestConfig {
            time_limit_ms: 1000,  // 1 second per position
            mcts_iterations: 500,
            ab_depth: 6,
            mate_search_depth: 3,
            neural_model_path: Some("python/models/chess_model.pth".to_string()),
        }
    }
}

/// Engine variant for testing
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum EngineVariant {
    AlphaBeta,           // Pure alpha-beta search
    MctsClassical,       // MCTS with classical evaluation
    MctsMatePriority,    // MCTS with mate-search-first
    MctsNeuralNet,       // MCTS with neural network policy
    MctsComplete,        // MCTS with mate-search-first + neural network
}

impl fmt::Display for EngineVariant {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            EngineVariant::AlphaBeta => write!(f, "Alpha-Beta"),
            EngineVariant::MctsClassical => write!(f, "MCTS-Classical"),
            EngineVariant::MctsMatePriority => write!(f, "MCTS-Mate-Priority"),
            EngineVariant::MctsNeuralNet => write!(f, "MCTS-Neural"),
            EngineVariant::MctsComplete => write!(f, "MCTS-Complete"),
        }
    }
}

/// Result from a single position analysis
#[derive(Debug, Clone)]
pub struct PositionResult {
    pub position_name: String,
    pub fen: String,
    pub engine: EngineVariant,
    pub best_move: Option<Move>,
    pub evaluation: Option<i32>,
    pub time_taken_ms: u64,
    pub nodes_searched: Option<u64>,
    pub correct_move: bool,
    pub move_quality_score: f64,
}

/// Complete benchmark results
#[derive(Debug)]
pub struct StrengthTestResults {
    pub config: StrengthTestConfig,
    pub position_results: Vec<PositionResult>,
    pub engine_summaries: HashMap<EngineVariant, EngineSummary>,
    pub overall_comparison: OverallComparison,
}

/// Summary statistics for an engine variant
#[derive(Debug, Clone)]
pub struct EngineSummary {
    pub engine: EngineVariant,
    pub total_positions: usize,
    pub correct_moves: usize,
    pub accuracy_percentage: f64,
    pub average_time_ms: f64,
    pub average_move_quality: f64,
    pub tactical_score: f64,
    pub positional_score: f64,
    pub endgame_score: f64,
}

/// Overall comparison between engines
#[derive(Debug)]
pub struct OverallComparison {
    pub best_engine: EngineVariant,
    pub ranking: Vec<(EngineVariant, f64)>,
    pub mate_search_improvement: f64,
    pub neural_net_improvement: f64,
    pub combined_improvement: f64,
}

/// Main strength testing orchestrator
pub struct StrengthTester {
    move_gen: MoveGen,
    pesto_eval: PestoEval,
    // alpha_beta: AlphaBeta,
    config: StrengthTestConfig,
}

impl StrengthTester {
    pub fn new(config: StrengthTestConfig) -> Self {
        StrengthTester {
            move_gen: MoveGen::new(),
            pesto_eval: PestoEval::new(),
            // alpha_beta: AlphaBeta::new(PestoEval::new()),
            config,
        }
    }

    /// Run comprehensive strength tests across all engine variants
    pub fn run_comprehensive_test(&mut self) -> StrengthTestResults {
        println!(" Starting Comprehensive Strength Testing");
        println!("==========================================");
        
        let test_positions = self.create_test_suite();
        println!(" Testing {} positions across {} engine variants", 
                test_positions.len(), 5);
        
        let mut all_results = Vec::new();
        let engines = vec![
            EngineVariant::AlphaBeta,
            EngineVariant::MctsClassical,
            EngineVariant::MctsMatePriority,
            EngineVariant::MctsNeuralNet,
            EngineVariant::MctsComplete,
        ];
        
        for engine in &engines {
            println!("\n Testing {}", engine);
            let engine_results = self.test_engine_variant(*engine, &test_positions);
            all_results.extend(engine_results);
        }
        
        let analysis = self.analyze_results(all_results);
        self.print_results_summary(&analysis);
        
        analysis
    }
    
    /// Test a specific engine variant on all positions
    fn test_engine_variant(&mut self, engine: EngineVariant, positions: &[TestPosition]) -> Vec<PositionResult> {
        let mut results = Vec::new();
        
        for (i, position) in positions.iter().enumerate() {
            print!("  Position {}/{}... ", i + 1, positions.len());
            
            let start_time = Instant::now();
            let (best_move, evaluation, nodes) = self.analyze_position_with_engine(engine, &position.board);
            let time_taken = start_time.elapsed().as_millis() as u64;
            
            let correct_move = if let Some(expected_move) = position.best_move {
                best_move.map_or(false, |mv| mv == expected_move)
            } else {
                true // No specific move required
            };
            
            let move_quality = self.calculate_move_quality(&position.board, best_move, position.category);
            
            let result = PositionResult {
                position_name: position.name.clone(),
                fen: position.board.to_fen().unwrap_or_default(),
                engine,
                best_move,
                evaluation,
                time_taken_ms: time_taken,
                nodes_searched: nodes,
                correct_move,
                move_quality_score: move_quality,
            };
            
            println!(" {}ms", time_taken);
            results.push(result);
        }
        
        results
    }
    
    /// Analyze position with specific engine variant
    fn analyze_position_with_engine(&mut self, engine: EngineVariant, board: &Board) -> (Option<Move>, Option<i32>, Option<u64>) {
        let time_limit = Duration::from_millis(self.config.time_limit_ms);
        
        match engine {
            EngineVariant::AlphaBeta => {
                // Simple evaluation-based "best" move for now
                let (captures, non_captures) = self.move_gen.gen_pseudo_legal_moves(board);
                let mut best_move = None;
                let mut best_eval = if board.w_to_move { i32::MIN } else { i32::MAX };
                
                // Try captures first, then non-captures
                for mv in captures.iter().chain(non_captures.iter()) {
                    let new_board = board.apply_move_to_board(*mv);
                    if new_board.is_legal(&self.move_gen) {
                        let eval = self.pesto_eval.eval(&new_board, &self.move_gen);
                        if (board.w_to_move && eval > best_eval) || (!board.w_to_move && eval < best_eval) {
                            best_eval = eval;
                            best_move = Some(*mv);
                        }
                    }
                }
                (best_move, Some(best_eval), Some(1000))
            }
            
            EngineVariant::MctsClassical => {
                // Use simplified evaluation search without mate priority
                let best_move = self.simple_evaluation_search(board, time_limit);
                (best_move, None, None)
            }
            
            EngineVariant::MctsMatePriority => {
                // Use evaluation search with basic mate checking
                let best_move = self.mate_priority_evaluation_search(board, time_limit);
                (best_move, None, None)
            }
            
            EngineVariant::MctsNeuralNet => {
                let mut nn_policy = self.create_neural_policy();
                let best_move = neural_mcts_search(
                    board.clone(),
                    &self.move_gen,
                    &self.pesto_eval,
                    &mut nn_policy,
                    0, // No mate search
                    Some(self.config.mcts_iterations),
                    Some(time_limit),
                );
                (best_move, None, None)
            }
            
            EngineVariant::MctsComplete => {
                let mut nn_policy = self.create_neural_policy();
                let best_move = neural_mcts_search(
                    board.clone(),
                    &self.move_gen,
                    &self.pesto_eval,
                    &mut nn_policy,
                    self.config.mate_search_depth,
                    Some(self.config.mcts_iterations),
                    Some(time_limit),
                );
                (best_move, None, None)
            }
        }
    }
    
    /// Create neural network policy (with fallback)
    fn create_neural_policy(&self) -> Option<NeuralNetPolicy> {
        if let Some(ref model_path) = self.config.neural_model_path {
            Some(NeuralNetPolicy::new())
        } else {
            None
        }
    }
    
    /// Simple evaluation-based search for benchmarking
    fn simple_evaluation_search(&self, board: &Board, _time_limit: Duration) -> Option<Move> {
        let (captures, non_captures) = self.move_gen.gen_pseudo_legal_moves(board);
        let mut best_move = None;
        let mut best_eval = if board.w_to_move { i32::MIN } else { i32::MAX };
        
        // Try captures first, then non-captures
        for mv in captures.iter().chain(non_captures.iter()) {
            let new_board = board.apply_move_to_board(*mv);
            if new_board.is_legal(&self.move_gen) {
                let eval = self.pesto_eval.eval(&new_board, &self.move_gen);
                if (board.w_to_move && eval > best_eval) || (!board.w_to_move && eval < best_eval) {
                    best_eval = eval;
                    best_move = Some(*mv);
                }
            }
        }
        
        best_move
    }
    
    /// Evaluation search with basic mate checking
    fn mate_priority_evaluation_search(&self, board: &Board, time_limit: Duration) -> Option<Move> {
        // Simple mate check: look for checkmate in 1
        let (captures, non_captures) = self.move_gen.gen_pseudo_legal_moves(board);
        
        // Check captures first for quick mates
        for mv in captures.iter().chain(non_captures.iter()) {
            let new_board = board.apply_move_to_board(*mv);
            if new_board.is_legal(&self.move_gen) {
                // Check if opponent has no legal moves (mate or stalemate)
                let (opp_captures, opp_non_captures) = self.move_gen.gen_pseudo_legal_moves(&new_board);
                let has_legal_moves = opp_captures.iter().chain(opp_non_captures.iter())
                    .any(|opp_mv| {
                        let test_board = new_board.apply_move_to_board(*opp_mv);
                        test_board.is_legal(&self.move_gen)
                    });
                
                if !has_legal_moves && new_board.is_check(&self.move_gen) {
                    return Some(*mv); // Found mate!
                }
            }
        }
        
        // Fall back to evaluation search
        self.simple_evaluation_search(board, time_limit)
    }
    
    /// Calculate move quality score based on position evaluation
    fn calculate_move_quality(&self, board: &Board, chosen_move: Option<Move>, category: PositionCategory) -> f64 {
        let Some(mv) = chosen_move else { return 0.0; };
        
        let new_board = board.apply_move_to_board(mv);
        if !new_board.is_legal(&self.move_gen) {
            return 0.0; // Illegal move
        }
        
        let eval_after = self.pesto_eval.eval(&new_board, &self.move_gen);
        let eval_before = self.pesto_eval.eval(board, &self.move_gen);
        
        // Score based on evaluation improvement (perspective-aware)
        let eval_diff = if board.w_to_move { // White to move
            eval_after - eval_before
        } else {
            eval_before - eval_after
        };
        
        let base_score = match eval_diff {
            diff if diff > 200 => 1.0,   // Excellent move
            diff if diff > 50 => 0.8,    // Good move
            diff if diff > -20 => 0.6,   // Acceptable move
            diff if diff > -100 => 0.3,  // Poor move
            _ => 0.1,                    // Bad move
        };
        
        // Bonus for tactical positions
        match category {
            PositionCategory::Tactical => base_score * 1.2,
            PositionCategory::Endgame => base_score * 1.1,
            PositionCategory::Positional => base_score,
        }
    }
    
    /// Analyze all results and create comprehensive summary
    fn analyze_results(&self, results: Vec<PositionResult>) -> StrengthTestResults {
        let mut engine_summaries = HashMap::new();
        
        // Group results by engine
        let mut engine_results: HashMap<EngineVariant, Vec<&PositionResult>> = HashMap::new();
        for result in &results {
            engine_results.entry(result.engine).or_insert_with(Vec::new).push(result);
        }
        
        // Calculate summaries for each engine
        for (engine, engine_results) in engine_results {
            let summary = self.calculate_engine_summary(engine, &engine_results);
            engine_summaries.insert(engine, summary);
        }
        
        // Calculate overall comparison
        let comparison = self.calculate_overall_comparison(&engine_summaries);
        
        // Generate Elo estimates
        use crate::benchmarks::elo_estimation::EloCalculator;
        let elo_calculator = EloCalculator::default();
        let elo_estimates = elo_calculator.estimate_performance_ratings(&results);
        let elo_report = elo_calculator.generate_elo_report(&elo_estimates);
        
        println!("\n ELO ANALYSIS COMPLETE");
        elo_report.print_report();
        
        StrengthTestResults {
            config: self.config.clone(),
            position_results: results,
            engine_summaries,
            overall_comparison: comparison,
        }
    }
    
    /// Calculate summary statistics for an engine
    fn calculate_engine_summary(&self, engine: EngineVariant, results: &[&PositionResult]) -> EngineSummary {
        let total_positions = results.len();
        let correct_moves = results.iter().filter(|r| r.correct_move).count();
        let accuracy_percentage = if total_positions > 0 {
            (correct_moves as f64 / total_positions as f64) * 100.0
        } else {
            0.0
        };
        
        let average_time_ms = results.iter().map(|r| r.time_taken_ms as f64).sum::<f64>() / total_positions as f64;
        let average_move_quality = results.iter().map(|r| r.move_quality_score).sum::<f64>() / total_positions as f64;
        
        // Category-specific scores (simplified for now)
        let tactical_score = average_move_quality;
        let positional_score = average_move_quality;
        let endgame_score = average_move_quality;
        
        EngineSummary {
            engine,
            total_positions,
            correct_moves,
            accuracy_percentage,
            average_time_ms,
            average_move_quality,
            tactical_score,
            positional_score,
            endgame_score,
        }
    }
    
    /// Calculate overall comparison between engines
    fn calculate_overall_comparison(&self, summaries: &HashMap<EngineVariant, EngineSummary>) -> OverallComparison {
        // Create ranking based on combined score (accuracy + move quality)
        let mut ranking: Vec<(EngineVariant, f64)> = summaries
            .iter()
            .map(|(engine, summary)| {
                let combined_score = (summary.accuracy_percentage / 100.0) * 0.6 + summary.average_move_quality * 0.4;
                (*engine, combined_score)
            })
            .collect();
        
        ranking.sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap());
        
        let best_engine = ranking.first().map(|(engine, _)| *engine).unwrap_or(EngineVariant::AlphaBeta);
        
        // Calculate improvements
        let ab_score = summaries.get(&EngineVariant::AlphaBeta).map(|s| s.average_move_quality).unwrap_or(0.5);
        let mcts_classical_score = summaries.get(&EngineVariant::MctsClassical).map(|s| s.average_move_quality).unwrap_or(0.5);
        let mcts_mate_score = summaries.get(&EngineVariant::MctsMatePriority).map(|s| s.average_move_quality).unwrap_or(0.5);
        let mcts_neural_score = summaries.get(&EngineVariant::MctsNeuralNet).map(|s| s.average_move_quality).unwrap_or(0.5);
        let mcts_complete_score = summaries.get(&EngineVariant::MctsComplete).map(|s| s.average_move_quality).unwrap_or(0.5);
        
        let mate_search_improvement = ((mcts_mate_score - mcts_classical_score) / mcts_classical_score) * 100.0;
        let neural_net_improvement = ((mcts_neural_score - mcts_classical_score) / mcts_classical_score) * 100.0;
        let combined_improvement = ((mcts_complete_score - ab_score) / ab_score) * 100.0;
        
        OverallComparison {
            best_engine,
            ranking,
            mate_search_improvement,
            neural_net_improvement,
            combined_improvement,
        }
    }
    
    /// Print comprehensive results summary
    fn print_results_summary(&self, results: &StrengthTestResults) {
        println!("\n COMPREHENSIVE STRENGTH TEST RESULTS");
        println!("======================================");
        
        println!("\n ENGINE RANKINGS:");
        for (i, (engine, score)) in results.overall_comparison.ranking.iter().enumerate() {
            println!("  {}. {} - Score: {:.3}", i + 1, engine, score);
        }
        
        println!("\n KEY IMPROVEMENTS:");
        println!("  Mate-Search-First:  {:+.1}%", results.overall_comparison.mate_search_improvement);
        println!("  Neural Network:     {:+.1}%", results.overall_comparison.neural_net_improvement);
        println!("  Combined Approach:  {:+.1}%", results.overall_comparison.combined_improvement);
        
        println!("\n DETAILED STATISTICS:");
        for engine in &[
            EngineVariant::AlphaBeta,
            EngineVariant::MctsClassical,
            EngineVariant::MctsMatePriority,
            EngineVariant::MctsNeuralNet,
            EngineVariant::MctsComplete,
        ] {
            if let Some(summary) = results.engine_summaries.get(engine) {
                println!("\n   {}:", engine);
                println!("     Accuracy:      {:.1}% ({}/{})", 
                        summary.accuracy_percentage, 
                        summary.correct_moves, 
                        summary.total_positions);
                println!("     Move Quality:  {:.3}", summary.average_move_quality);
                println!("     Avg Time:      {:.0}ms", summary.average_time_ms);
            }
        }
        
        println!("\n CONCLUSION:");
        println!("  Best Engine: {}", results.overall_comparison.best_engine);
        if results.overall_comparison.combined_improvement > 0.0 {
            println!("   Our mate-search-first + neural network approach shows {:.1}% improvement!", 
                    results.overall_comparison.combined_improvement);
        } else {
            println!("    Need more tuning - combined approach shows {:.1}% change", 
                    results.overall_comparison.combined_improvement);
        }
    }
    
    /// Create comprehensive test suite with diverse positions
    fn create_test_suite(&self) -> Vec<TestPosition> {
        let mut positions = Vec::new();
        
        // Add tactical test positions
        positions.extend(self.create_tactical_positions());
        
        // Add positional test positions
        positions.extend(self.create_positional_positions());
        
        // Add endgame test positions
        positions.extend(self.create_endgame_positions());
        
        positions
    }
    
    /// Create tactical test positions
    fn create_tactical_positions(&self) -> Vec<TestPosition> {
        vec![
            TestPosition {
                name: "Back Rank Mate".to_string(),
                board: Board::new_from_fen("6k1/5ppp/8/8/8/8/8/4R2K w - - 0 1"),
                best_move: Move::from_uci("Re8"), // Remove # from move notation
                category: PositionCategory::Tactical,
            },
            TestPosition {
                name: "Starting Position".to_string(),
                board: Board::new(),  // Use standard starting position
                best_move: Move::from_uci("e2e4"),
                category: PositionCategory::Positional,
            },
            TestPosition {
                name: "Simple Endgame".to_string(),
                board: Board::new_from_fen("8/8/8/4k3/4P3/4K3/8/8 w - - 0 1"),
                best_move: Move::from_uci("Kd4"),
                category: PositionCategory::Endgame,
            },
        ]
    }
    
    /// Create positional test positions
    fn create_positional_positions(&self) -> Vec<TestPosition> {
        vec![
            TestPosition {
                name: "Central Control".to_string(),
                board: Board::new_from_fen("rnbqkbnr/pppppppp/8/8/4P3/8/PPPP1PPP/RNBQKBNR b KQkq e3 0 1"),
                best_move: Move::from_uci("e7e5"),
                category: PositionCategory::Positional,
            },
            TestPosition {
                name: "Development Priority".to_string(),
                board: Board::new_from_fen("rnbqkbnr/pppp1ppp/8/4p3/4P3/8/PPPP1PPP/RNBQKBNR w KQkq - 0 2"),
                best_move: Move::from_uci("g1f3"),
                category: PositionCategory::Positional,
            },
        ]
    }
    
    /// Create endgame test positions
    fn create_endgame_positions(&self) -> Vec<TestPosition> {
        vec![
            TestPosition {
                name: "King and Pawn vs King".to_string(),
                board: Board::new_from_fen("8/8/8/4k3/4P3/4K3/8/8 w - - 0 1"),
                best_move: Move::from_uci("e3d4"),
                category: PositionCategory::Endgame,
            },
            TestPosition {
                name: "Rook Endgame".to_string(),
                board: Board::new_from_fen("8/8/8/8/8/3k4/3r4/3K4 b - - 0 1"),
                best_move: Move::from_uci("d2d1"),
                category: PositionCategory::Endgame,
            },
        ]
    }
}

/// Individual test position
#[derive(Debug, Clone)]
pub struct TestPosition {
    pub name: String,
    pub board: Board,
    pub best_move: Option<Move>,
    pub category: PositionCategory,
}

/// Position category for specialized testing
#[derive(Debug, Clone, Copy)]
pub enum PositionCategory {
    Tactical,
    Positional,
    Endgame,
}

/// Save results to file for detailed analysis
impl StrengthTestResults {
    pub fn save_to_csv(&self, path: &str) -> std::io::Result<()> {
        use std::fs::File;
        use std::io::Write;
        
        let mut file = File::create(path)?;
        
        writeln!(file, "position,engine,time_ms,correct_move,move_quality,evaluation")?;
        
        for result in &self.position_results {
            writeln!(
                file,
                "{},{},{},{},{},{}",
                result.position_name,
                result.engine,
                result.time_taken_ms,
                result.correct_move,
                result.move_quality_score,
                result.evaluation.unwrap_or(0)
            )?;
        }
        
        println!(" Detailed results saved to: {}", path);
        Ok(())
    }
}]]>
</content>
</file>

<file path="ARCHITECTURE.md" tokens="2482" focus="false">
<reason>Semantic Match, Architecturally Significant</reason>
<content>
<![CDATA[
# Caissawary Chess Engine - Technical Architecture

This document provides a detailed technical overview of the Caissawary Chess Engine architecture, focusing on our novel mate-search-first MCTS approach and neural network integration.

##  Core Architecture Overview

```

                    Caissawary Chess Engine                 

  UCI Interface  Time Management  Position Analysis        

           Search Algorithms & Decision Making               
       
    Alpha-Beta        MCTS w/ Mate       Neural MCTS   
    + Enhancements    Search First       Integration   
       

                   Evaluation Systems                       
       
    Pesto Classic     Texel Tuning       Neural Net    
    Evaluation        Optimization       Policy/Value  
       

                 Core Chess Infrastructure                  
       
    Bitboard          Magic Bitboard     Move Types    
    Representation    Move Generation    & Validation  
       

```

##  Mate-Search-First MCTS Innovation

### Problem Statement
Traditional neural network chess engines face a fundamental challenge: expensive neural network evaluations on positions where exact analysis is possible. This is particularly problematic during training when the neural network is randomly initialized and provides poor guidance.

### Solution: Hybrid Classical-Modern Approach

Our mate-search-first MCTS performs the following at each leaf node:

```rust
fn mcts_leaf_evaluation(board: &Board) -> (f64, Vec<f32>) {
    // 1. First attempt: Classical mate search
    if let Some(mate_result) = mate_search(board, depth=3) {
        return (exact_value(mate_result), exact_policy(mate_result));
    }
    
    // 2. Fallback: Neural network evaluation
    neural_network.evaluate(board)
}
```

### Key Benefits

1. **Exact Tactical Analysis**: Forced wins/losses get perfect evaluation
2. **Reduced NN Dependency**: Fewer expensive neural network calls
3. **Training Acceleration**: Correct play in tactical positions from day 1
4. **Interpretable Results**: Classical analysis provides explainable decisions

### Implementation Details

**Mate Search Integration** (`src/mcts/mod.rs`):
- Depth-limited classical search (typically 3-5 plies)
- Alpha-beta with aggressive pruning for mate detection
- Return values: `(score, best_move, depth_to_mate)`

**MCTS Tree Integration** (`src/mcts/node.rs`):
- Exact results bypass neural network evaluation
- Immediate backpropagation of forced results
- Enhanced move ordering based on tactical threats

##  Neural Network Architecture

### Network Design

**ResNet-Style Architecture**:
```python
Input: 1788 tensor (piece_types  colors  extra_info  squares)
  
Initial Convolution: 17  256 channels
  
8 Residual Blocks (256 channels each)
  
    
   Policy Head          Value Head    
   256  4672           256  1       
 (move encoding)      (position eval) 
    
```

**Board Representation**:
- 17 channels total:
    - 12 channels: 6 piece types  2 colors
    - 1 channel: En Passant target square
    - 4 channels: Castling rights (White K/Q, Black k/q) - full planes of 1s
- 88 spatial dimensions preserve chess board structure
- Binary encoding: 1.0 if piece/feature present, 0.0 otherwise

**Move Encoding**:
- 4096 possible moves: 6464 from-to square encoding
- Handles all legal chess moves including promotions
- Probability distribution over legal moves

### Training Pipeline

**Data Collection** (`python/data_collection.py`):
```python
# Quality filtering criteria
min_player_rating = 1800
min_game_length = 20
max_game_length = 100
min_time_control = 180  # 3 minutes
```

**Position Extraction** (`python/training_pipeline.py`):
- Sample every 3rd move from middle game (moves 10-90)
- Filter out check positions (too tactical)
- Require minimum piece count (avoid trivial endgames)
- Engine analysis for training targets

**Training Loop**:
```python
loss = policy_loss(predicted_policy, target_policy) + \
       value_loss(predicted_value, target_value)

# Policy loss: Cross-entropy with actual moves
# Value loss: Mean squared error with game outcomes
```

##  Search Algorithm Enhancements

### Alpha-Beta Framework (`src/search/alpha_beta.rs`)

**Core Enhancements**:
- Iterative Deepening with aspiration windows
- Transposition table with Zobrist hashing
- Null move pruning with zugzwang detection
- Late move reductions (LMR) for non-critical moves
- Quiescence search with SEE (Static Exchange Evaluation)

**Move Ordering**:
1. Transposition table move (if available)
2. Killer moves (non-capture moves that caused beta cutoffs)
3. History heuristic (moves that historically performed well)
4. MVV-LVA (Most Valuable Victim - Least Valuable Attacker)

### MCTS Implementation (`src/mcts/`)

**Selection Phase**:
```rust
fn uct_select(node: &MctsNode) -> usize {
    let exploration = EXPLORATION_CONSTANT * 
        (parent.visits.ln() / child.visits).sqrt();
    
    child_index = argmax(child.q_value + exploration)
}
```

**Expansion Strategy**:
- Prioritize captures and checks first
- Use neural network policy for move priors
- Expand most promising unexplored moves

**Backpropagation**:
- Update visit counts and value accumulation
- Track variance for confidence estimation
- Support both exact (mate) and estimated values

##  Evaluation Systems

### Pesto Evaluation (`src/eval.rs`)

**Tapered Evaluation**:
```rust
fn tapered_eval(mg_score: i32, eg_score: i32, game_phase: i32) -> i32 {
    (mg_score * game_phase + eg_score * (256 - game_phase)) / 256
}
```

**Components**:
- **Material**: Piece values with game phase adjustments
- **Piece-Square Tables**: Position-dependent piece values
- **Pawn Structure**: Passed, isolated, doubled, backward pawns
- **King Safety**: Pawn shield, castling rights, attack evaluation
- **Piece Coordination**: Rook placement, bishop pairs
- **Mobility**: Legal move count weighted by piece type

### Texel Tuning (`src/tuning/`)

**Optimization Process**:
1. Collect positions with known outcomes (win/loss/draw)
2. Minimize error between evaluation and actual results
3. Use gradient descent on evaluation parameters
4. Validate improvements on held-out test set

**Parameter Groups**:
- Piece values (separate for middlegame/endgame)
- Piece-square table adjustments
- Pawn structure bonuses/penalties
- King safety factors
- Mobility weightings

##  Benchmarking & Analysis

### Strength Testing Framework (`src/benchmarks/strength_testing.rs`)

**Engine Variants**:
1. **Alpha-Beta**: Pure classical search baseline
2. **MCTS-Classical**: Standard MCTS with classical evaluation
3. **MCTS-Mate-Priority**: Our mate-search-first innovation
4. **MCTS-Neural**: MCTS with neural network guidance
5. **MCTS-Complete**: Combined mate-search + neural network

**Evaluation Metrics**:
- **Accuracy**: Percentage of positions with "correct" moves
- **Move Quality**: Evaluation improvement after move
- **Speed**: Time to decision per position
- **Elo Estimation**: Performance-based rating calculation

### Elo Calculation (`src/benchmarks/elo_estimation.rs`)

**Rating Formula**:
```rust
estimated_elo = baseline_elo + 
    accuracy_component + 
    quality_component + 
    speed_component

// Where components are:
accuracy_component = (accuracy - 0.5) * 200.0
quality_component = (move_quality - 0.6) * 300.0
speed_component = speed_bonus_or_penalty()
```

**Confidence Estimation**:
- Based on sample size and result consistency
- Higher confidence for more positions tested
- Statistical significance testing for comparisons

##  Performance Optimizations

### Memory Management
- **Bitboards**: 64-bit integers for efficient position representation
- **Move Generation**: Precomputed magic bitboard tables
- **Transposition Tables**: Hash-based caching of search results
- **Neural Network**: Efficient tensor operations with PyTorch

### Search Optimizations
- **Fail-Soft Alpha-Beta**: Extended alpha-beta bounds
- **Aspiration Windows**: Narrow search windows for faster iteration
- **Adaptive Depth**: Dynamic depth adjustment based on position complexity
- **Parallel Evaluation**: Concurrent neural network batching (future)

### Training Optimizations
- **Data Filtering**: Quality-based position selection
- **Batch Processing**: Efficient GPU utilization
- **Checkpointing**: Resume training from interruptions
- **Validation Monitoring**: Early stopping to prevent overfitting

##  Future Enhancements

### Immediate Improvements
- **Opening Books**: Integrate standard opening repertoires
- **Endgame Tablebases**: Perfect play in simplified positions
- **Time Management**: Sophisticated time allocation
- **Parallel Search**: Multi-threaded MCTS exploration

### Research Directions
- **Self-Play Training**: Generate training data through engine games
- **Architecture Search**: Automated neural network design optimization
- **Multi-Objective Training**: Balance tactical and positional play
- **Transfer Learning**: Adapt to chess variants and different playing styles

### Advanced Features
- **Explanation System**: Natural language move justification
- **Style Adaptation**: Mimic human player characteristics
- **Progressive Training**: Curriculum learning from simple to complex
- **Adversarial Robustness**: Defend against exploitative play

---

This architecture represents a novel approach to chess engine design, successfully bridging classical chess programming with modern AI techniques while maintaining interpretability and training efficiency.]]>
</content>
</file>

<file path="src/benchmarks/mod.rs" tokens="777" focus="false">
<reason>Architecturally Significant</reason>
<content>
<![CDATA[
use crate::boardstack::BoardStack;
use crate::move_types::Move;
use crate::move_generation::MoveGen;
use crate::eval::PestoEval;
use crate::agent::{Agent, SimpleAgent, HumanlikeAgent};
use std::time::{Duration, Instant};

pub mod tactical_suite;
pub mod performance;
pub mod strength_testing;
pub mod elo_estimation;
pub mod elo_tournament;

#[derive(Debug, Clone)]
pub struct BenchmarkResult {
    pub position_name: String,
    pub engine_name: String,
    pub time_taken: Duration,
    pub nodes_searched: u64,
    pub best_move: Option<Move>,
    pub found_mate: bool,
    pub mate_depth: Option<u8>,
}

#[derive(Debug)]
pub struct BenchmarkSummary {
    pub total_positions: usize,
    pub positions_solved: usize,
    pub average_time: Duration,
    pub total_nodes: u64,
    pub mate_accuracy: f64, // Percentage of mates found
}

impl BenchmarkSummary {
    pub fn from_results(results: &[BenchmarkResult]) -> Self {
        let total_positions = results.len();
        let positions_solved = results.iter().filter(|r| r.found_mate).count();
        let total_time: Duration = results.iter().map(|r| r.time_taken).sum();
        let average_time = if total_positions > 0 {
            total_time / total_positions as u32
        } else {
            Duration::from_millis(0)
        };
        let total_nodes: u64 = results.iter().map(|r| r.nodes_searched).sum();
        let mate_accuracy = if total_positions > 0 {
            (positions_solved as f64 / total_positions as f64) * 100.0
        } else {
            0.0
        };

        BenchmarkSummary {
            total_positions,
            positions_solved,
            average_time,
            total_nodes,
            mate_accuracy,
        }
    }

    pub fn print_summary(&self, engine_name: &str) {
        println!("\n=== {} Benchmark Results ===", engine_name);
        println!("Total Positions: {}", self.total_positions);
        println!("Positions Solved: {}", self.positions_solved);
        println!("Mate Accuracy: {:.1}%", self.mate_accuracy);
        println!("Average Time: {:.2}ms", self.average_time.as_millis());
        println!("Total Nodes: {}", self.total_nodes);
        if self.total_positions > 0 {
            println!("Nodes per Position: {:.0}", self.total_nodes as f64 / self.total_positions as f64);
        }
        println!("=======================================\n");
    }
}

lazy_static::lazy_static! {
    static ref BENCH_MOVE_GEN: MoveGen = MoveGen::new();
    static ref BENCH_PESTO_EVAL: PestoEval = PestoEval::new();
}

pub fn create_simple_agent() -> SimpleAgent<'static> {
    SimpleAgent::new(
        3,     // mate_search_depth
        8,     // ab_search_depth  
        16,    // q_search_max_depth
        false, // verbose
        &*BENCH_MOVE_GEN,
        &*BENCH_PESTO_EVAL,
    )
}

pub fn create_humanlike_agent() -> HumanlikeAgent<'static> {
    HumanlikeAgent::new(
        &*BENCH_MOVE_GEN,
        &*BENCH_PESTO_EVAL,
        None, // No EGTB for benchmarking
        3,    // mate_search_depth
        1000, // mcts_iterations
        5000, // mcts_time_limit_ms
        8,    // placeholder_ab_depth
        16,   // placeholder_q_depth
    )
}]]>
</content>
</file>

<file path="src/alpha_beta.rs" tokens="92" focus="false">
<reason>Hybrid Retrieval</reason>
<content>
<![CDATA[
/// Helper function to check if a move is a capture
fn is_capture(board: &Board, mv: &Move) -> bool {
    let target_square_bb = 1u64 << mv.to;
    let opponent_color = !board.w_to_move as usize;
    
    // Check if the target square is occupied by an opponent's piece
    (board.pieces_occ[opponent_color] & target_square_bb) != 0
} ]]>
</content>
</file>

<file path="src/piece_types.rs" tokens="96" focus="false">
<reason>Hybrid Retrieval</reason>
<content>
<![CDATA[
/// Represents the type of a chess piece.
pub const PAWN: usize = 0;
pub const KNIGHT: usize = 1;
pub const BISHOP: usize = 2;
pub const ROOK: usize = 3;
pub const QUEEN: usize = 4;
pub const KING: usize = 5;

/// Represents the color of a chess piece.
pub const WHITE: usize = 0;
pub const BLACK: usize = 1;
]]>
</content>
</file>

<file path="src/search/mod.rs" tokens="106" focus="false">
<reason>Architecturally Significant</reason>
<content>
<![CDATA[
pub mod alpha_beta;
pub mod quiescence;
pub mod iterative_deepening;
pub mod history;
pub mod mate_search;
mod koth;
mod see;

pub use history::{HistoryTable, MAX_PLY};
pub use mate_search::mate_search;
pub use quiescence::{quiescence_search, quiescence_search_tactical};
pub use iterative_deepening::{iterative_deepening_ab_search, aspiration_window_ab_search};
pub use koth::koth_center_in_3;
pub use see::see;
]]>
</content>
</file>

<file path="requirements.txt" tokens="53" focus="false">
<reason>Hybrid Retrieval</reason>
<content>
<![CDATA[
torch>=2.0.0
numpy>=1.24.0
python-chess>=1.9.0
matplotlib>=3.7.0
pandas>=2.0.0
seaborn>=0.12.0
]]>
</content>
</file>

</file_contents>

<omitted_files>
<file path="src/benchmarks/elo_tournament.rs" relevance="2.7">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="tests/integration/mcts_integration_tests.rs" relevance="2.7">
  <reason>Semantic Match</reason>
</file>
<file path="src/search/iterative_deepening.rs" relevance="2.7">
  <reason>Semantic Match</reason>
</file>
<file path="src/benchmarks/performance.rs" relevance="2.7">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="test_tactical_mcts.rs" relevance="2.7">
  <reason>Semantic Match</reason>
</file>
<file path="tests/unit/node_tests.rs" relevance="2.6">
  <reason>Semantic Match</reason>
</file>
<file path="src/benchmarks/elo_estimation.rs" relevance="2.6">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="src/benchmarks/tactical_suite.rs" relevance="2.6">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="PAPER_READY_IMPLEMENTATION_GUIDE.md" relevance="2.6">
  <reason>Semantic Match</reason>
</file>
<file path="tests/mcts_tests.rs" relevance="2.6">
  <reason>Semantic Match</reason>
</file>
<file path="src/magic_constants.rs" relevance="2.6">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="src/board_utils.rs" relevance="2.5">
  <reason>Architecturally Significant</reason>
</file>
<file path="src/bin/tactical_cache_demo.rs" relevance="2.5">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="src/bin/tactical_profiler.rs" relevance="2.5">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="tests/regression/recent_fixes_tests.rs" relevance="2.5">
  <reason>Semantic Match</reason>
</file>
<file path="TRAINING_GUIDE.md" relevance="2.5">
  <reason>Semantic Match</reason>
</file>
<file path="src/bin/neural_integration_demo.rs" relevance="2.4">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="src/bin/generate_training_data.rs" relevance="2.4">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="src/bin/benchmark.rs" relevance="2.4">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="tests/unit/selection_tests.rs" relevance="2.4">
  <reason>Semantic Match</reason>
</file>
<file path="tests/neural_integration_tests.rs" relevance="2.4">
  <reason>Semantic Match</reason>
</file>
<file path="src/bin/quick_test.rs" relevance="2.3">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="src/bin/verbose_search.rs" relevance="2.3">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="src/bin/verify_features.rs" relevance="2.3">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="python/training_pipeline.py" relevance="2.3">
  <reason>Semantic Match</reason>
</file>
<file path="src/bin/texel_tune.rs" relevance="2.2">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="src/bin/elo_tournament.rs" relevance="2.2">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="src/bin/see_integration_demo.rs" relevance="2.2">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="src/bin/self_play.rs" relevance="2.2">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="src/bin/mate_search_tt_demo.rs" relevance="2.2">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="src/bin/strength_test.rs" relevance="2.1">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="src/bin/benchmark_gates.rs" relevance="2.1">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="src/lib.rs" relevance="2.0">
  <reason>Architecturally Significant</reason>
</file>
<file path="src/tensor.rs" relevance="2.0">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="src/make_move.rs" relevance="2.0">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="src/training/mod.rs" relevance="2.0">
  <reason>Architecturally Significant</reason>
</file>
<file path="src/hash.rs" relevance="1.9">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="src/mcts/search_logger.rs" relevance="1.9">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="src/mcts/tactical.rs" relevance="1.8">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="src/mcts/inference_server.rs" relevance="1.8">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="src/mcts/node.rs" relevance="1.8">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="src/mcts/selection.rs" relevance="1.8">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="src/mcts/simulation.rs" relevance="1.7">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="src/mcts/unit_tests/tactical_tests.rs" relevance="1.7">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="src/mcts/unit_tests/selection_tests.rs" relevance="1.7">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="src/arena.rs" relevance="1.7">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="src/boardstack.rs" relevance="1.6">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="src/transposition.rs" relevance="1.6">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="src/bits.rs" relevance="1.6">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="src/board.rs" relevance="1.6">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="src/move_generation.rs" relevance="1.6">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="src/eval_constants.rs" relevance="1.6">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="src/eval.rs" relevance="1.6">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="src/search/mate_search.rs" relevance="1.5">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="src/search/see.rs" relevance="1.5">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="src/search/quiescence.rs" relevance="1.5">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="src/search/koth.rs" relevance="1.5">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="src/search/history.rs" relevance="1.5">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="src/utils.rs" relevance="1.4">
  <reason>Architecturally Significant</reason>
</file>
<file path="src/main.rs" relevance="1.4">
  <reason>Architecturally Significant</reason>
</file>
<file path="src/magic_bitboard.rs" relevance="1.4">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="scripts/run_paper_experiments.sh" relevance="1.4">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="scripts/generate_figures.py" relevance="1.4">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="scripts/test.sh" relevance="1.4">
  <reason>Hybrid Retrieval</reason>
</file>
<file path=".github/workflows/rust.yml" relevance="1.3">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="MCTS_TACTICAL_PRIORITY.md" relevance="1.3">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="tests/property/mod.rs" relevance="1.3">
  <reason>Architecturally Significant</reason>
</file>
<file path="tests/property/invariant_tests.rs" relevance="1.3">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="tests/eval_piece_bonus_tests.rs" relevance="1.3">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="tests/bitboard_tests.rs" relevance="1.3">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="tests/common/mod.rs" relevance="1.3">
  <reason>Architecturally Significant</reason>
</file>
<file path="tests/unit/graphviz_tests.rs" relevance="1.3">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="tests/unit/move_generation_tests.rs" relevance="1.2">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="tests/unit/mod.rs" relevance="1.2">
  <reason>Architecturally Significant</reason>
</file>
<file path="tests/unit/tensor_tests.rs" relevance="1.2">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="tests/unit/search_logger_tests.rs" relevance="1.2">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="tests/unit/board_tests.rs" relevance="1.2">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="tests/move_generation_tests.rs" relevance="1.2">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="tests/perft_tests.rs" relevance="1.2">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="tests/regression/mod.rs" relevance="1.2">
  <reason>Architecturally Significant</reason>
</file>
<file path="tests/make_move_tests.rs" relevance="1.2">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="tests/mate_portfolio_tests.rs" relevance="1.2">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="tests/repetition_tests.rs" relevance="1.2">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="tests/integration/mod.rs" relevance="1.1">
  <reason>Architecturally Significant</reason>
</file>
<file path="tests/eval_pawn_structure_tests.rs" relevance="1.1">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="MCTS_INSPECTOR_IMPLEMENTATION_GUIDE.md" relevance="1.1">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="python/export_model.py" relevance="1.1">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="python/train.py" relevance="1.1">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="python/orchestrate.py" relevance="1.1">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="python/model.py" relevance="1.1">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="python/README.md" relevance="1.1">
  <reason>Architecturally Significant</reason>
</file>
<file path="python/train_chess_ai.py" relevance="1.1">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="python/test_architectures.py" relevance="1.1">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="python/data_collection.py" relevance="1.1">
  <reason>Hybrid Retrieval</reason>
</file>
<file path="run_validation_experiments.sh" relevance="1.1">
  <reason>Hybrid Retrieval</reason>
</file>
</omitted_files>

</repository_context>